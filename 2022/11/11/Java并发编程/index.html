<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Java并发编程 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="Java并发编程 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="IELTS WritingTask 1Introduction -&gt; Overview -&gt; Detail -&gt; Detail (No Conclusion and opinions!) Notes: 时态不要错！！  PS: 看 便便 的两个 pdf 小作文模板  上升： v rise - rose - risen - rising	n rise v increase - in">
<meta property="og:type" content="article">
<meta property="og:title" content="IELTS Writing">
<meta property="og:url" content="http://example.com/2024/10/10/IELTS-Writing/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="IELTS WritingTask 1Introduction -&gt; Overview -&gt; Detail -&gt; Detail (No Conclusion and opinions!) Notes: 时态不要错！！  PS: 看 便便 的两个 pdf 小作文模板  上升： v rise - rose - risen - rising	n rise v increase - in">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903143929000.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240912122709201.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903154014772.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903170338309.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241008162149573.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903221950372.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240908183744208.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240909115534553.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241006134635925.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/36195076c5bf4f8798d6a3a1a7e8b009.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004223753876.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241003185429807.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241003190448385.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004194259889.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222854805.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222634264.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222706508.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004223109519.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222732028.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222806949.png">
<meta property="article:published_time" content="2024-10-10T07:06:24.000Z">
<meta property="article:modified_time" content="2024-10-10T07:07:10.746Z">
<meta property="article:author" content="王才雨">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903143929000.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>王才雨</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/dalaizi"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:1935863093@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1935863093&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(19)</small>
            
        </div>
    </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="19">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All "
           href="/2024/11/18/Netty/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Netty">Netty</span>
            <span class="post-date" title="2024-11-18 09:00:27">2024/11/18</span>
        </a>
        
        
        <a  class="All "
           href="/2024/10/10/IELTS-Writing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IELTS Writing">IELTS Writing</span>
            <span class="post-date" title="2024-10-10 15:06:24">2024/10/10</span>
        </a>
        
        
        <a  class="All "
           href="/2024/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="操作系统">操作系统</span>
            <span class="post-date" title="2024-04-18 11:20:09">2024/04/18</span>
        </a>
        
        
        <a  class="All "
           href="/2024/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RPC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解RPC">深入理解RPC</span>
            <span class="post-date" title="2024-04-03 13:06:31">2024/04/03</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <span class="post-date" title="2024-03-29 21:02:25">2024/03/29</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/20/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UNIX网络编程">UNIX网络编程</span>
            <span class="post-date" title="2024-03-20 15:03:46">2024/03/20</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/17/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2024-03-17 00:40:34">2024/03/17</span>
        </a>
        
        
        <a  class="All "
           href="/2024/02/25/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="后端开发面试题">后端开发面试题</span>
            <span class="post-date" title="2024-02-25 15:47:51">2024/02/25</span>
        </a>
        
        
        <a  class="All "
           href="/2024/01/05/Linux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux">Linux</span>
            <span class="post-date" title="2024-01-05 13:29:00">2024/01/05</span>
        </a>
        
        
        <a  class="All "
           href="/2023/11/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="力扣刷题">力扣刷题</span>
            <span class="post-date" title="2023-11-22 17:10:44">2023/11/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="动态代理">动态代理</span>
            <span class="post-date" title="2023-10-08 22:49:01">2023/10/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/04/08/%E9%A1%B9%E7%9B%AERPC%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="项目RPC框架">项目RPC框架</span>
            <span class="post-date" title="2023-04-08 19:49:23">2023/04/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/02/redis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="redis">redis</span>
            <span class="post-date" title="2023-01-02 17:46:17">2023/01/02</span>
        </a>
        
        
        <a  class="All "
           href="/2022/12/24/MySQL/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL">MySQL</span>
            <span class="post-date" title="2022-12-24 11:40:50">2022/12/24</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java并发编程">Java并发编程</span>
            <span class="post-date" title="2022-11-11 16:20:42">2022/11/11</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/30/JVM%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM调优">JVM调优</span>
            <span class="post-date" title="2022-10-30 20:09:07">2022/10/30</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解Java虚拟机">深入理解Java虚拟机</span>
            <span class="post-date" title="2022-10-19 10:40:02">2022/10/19</span>
        </a>
        
        
        <a  class="All "
           href="/2022/06/04/Java%E7%9F%A5%E8%AF%86%E7%82%B9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java知识点">Java知识点</span>
            <span class="post-date" title="2022-06-04 10:58:21">2022/06/04</span>
        </a>
        
        
        <a  class="All "
           href="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络">计算机网络</span>
            <span class="post-date" title="2022-02-06 18:11:21">2022/02/06</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-Java并发编程" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">Java并发编程</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2025-01-05 14:51:00'>2022-11-11 16:20</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">Java 并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OS-%E5%9F%BA%E7%A1%80"><span class="toc-text">OS 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-%E8%BF%9B%E7%A8%8B"><span class="toc-text">线程 &amp; 进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81-%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-text">用户态 &amp; 内核态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%EF%BC%88-%E6%9C%89%E7%A9%BA%E5%86%8D%E7%9C%8B-%EF%BC%89"><span class="toc-text">操作系统的通信方式（&#x3D;&#x3D;有空再看&#x3D;&#x3D;）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">进程通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">线程通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">线程的实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">内核线程实现：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">用户线程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="toc-text">混合实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">java线程实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%B8%B8%E8%80%83%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;1. 创建线程（常考）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B"><span class="toc-text">2. 查看线程进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">3. 线程运行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E6%A0%88%E5%B8%A7"><span class="toc-text">栈和栈帧</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">上下文切换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">4. 常用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81-%E6%B5%81%E8%BD%AC"><span class="toc-text">&#x3D;&#x3D;线程状态 &amp; 流转&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81%E3%80%91"><span class="toc-text">【初始状态】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81%E3%80%91"><span class="toc-text">【就绪状态】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E3%80%91"><span class="toc-text">【运行状态】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81%E3%80%91"><span class="toc-text">【阻塞状态】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81%E3%80%91"><span class="toc-text">【终止状态】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E4%B8%8E%E5%8D%8F%E7%A8%8B%EF%BC%88%EF%BC%81%EF%BC%89"><span class="toc-text">Java 与协程（！）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E5%8F%8A%E5%85%B6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">线程安全问题及其解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#park-unpark"><span class="toc-text">park &amp; unpark</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD%E7%9A%84%E9%94%81"><span class="toc-text">Java 中的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%BC%8F%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88%EF%BC%81%EF%BC%89"><span class="toc-text">阻塞式悲观锁（！）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-text">&#x3D;&#x3D;synchronized&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-text">Synchronized的锁升级过程说一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Synchronized%E6%98%AF%E5%85%AC%E5%B9%B3%E9%94%81%E5%90%97%EF%BC%9F"><span class="toc-text">Synchronized是公平锁吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-text">ReentrantLock是怎么实现公平锁的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81Monitor"><span class="toc-text">重量级锁Monitor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Lock"><span class="toc-text">Lock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%88-JMM-%EF%BC%89"><span class="toc-text">Java 内存模型（ JMM ）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">可见性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-text">什么是可见性问题？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">如何解决可见性问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F"><span class="toc-text">CAS 非阻塞方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-%E7%9B%B8%E5%85%B3-API"><span class="toc-text">CAS 相关 API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;线程池（重要）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecuter"><span class="toc-text">ThreadPoolExecuter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-text">工厂方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#newFixedThreadPool"><span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newCachedThreadPool"><span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newSingleThreadExecutor"><span class="toc-text">newSingleThreadExecutor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1"><span class="toc-text">提交任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">关闭线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS-%E5%8E%9F%E7%90%86%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;AQS 原理（重要）&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%A0%B8%E5%BF%83%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-text">三个核心组成部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%E6%96%B9%E5%BC%8F"><span class="toc-text">资源共享方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%81"><span class="toc-text">自定义锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock%E5%8E%9F%E7%90%86"><span class="toc-text">ReentrantLock原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B"><span class="toc-text">加锁流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-text">解锁过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore"><span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch"><span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-text">CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-text">线程安全集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9AJava-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6"><span class="toc-text">补充：Java 集合框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E6%99%AE%E9%80%9A-HashMap"><span class="toc-text">补充：普通 HashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-text">ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E7%BC%96%E7%A8%8B%E9%A2%98"><span class="toc-text">面试编程题</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java 并发编程"></a>Java 并发编程</h1><h2 id="OS-基础"><a href="#OS-基础" class="headerlink" title="OS 基础"></a>OS 基础</h2><h3 id="线程-进程"><a href="#线程-进程" class="headerlink" title="线程 &amp; 进程"></a>线程 &amp; 进程</h3><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240414120211582-1734251548090-1.png" alt="image-20240414120211582" style="zoom:50%;"> 

<ul>
<li><strong>本质区别</strong>：进程是操作系统【<strong>资源分配的最小单位</strong>】，而线程是【<strong>任务调度和执行的基本单位】</strong></li>
<li><strong>在开销方面</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小</li>
<li><strong>稳定性方面</strong>：进程中某个线程如果崩溃了，可能会导致整个进程都崩溃。而进程中的子进程崩溃，并不会影响其他进程。</li>
<li><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源</li>
<li><strong>包含关系</strong>：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程</li>
</ul>
<hr>
<ul>
<li><p><strong>进程</strong></p>
<ul>
<li>进程就是用来加载指令、管理内存、管理IO的，当一个程序被运行，从磁盘加载这个程序的代码到内存，就开启了一个进程。</li>
<li>进程可以看成<strong>程序的实例</strong>，大部分程序可以同时运行多个实例进程（浏览器），有的程序只能启动一个实例进程（网易云音乐、360安全卫士）</li>
<li>进程是<strong>【资源分配的最小单位】</strong></li>
</ul>
</li>
<li><p><strong>线程</strong></p>
<ul>
<li>一个进程可以分成一至多个线程。一个线程就是一个指令流，将一条条指令按顺序交给CPU执行。<strong>共享进程的资源<br>最小调度单元</strong></li>
<li>windows中进程不活动，只是线程的容器</li>
</ul>
</li>
<li><p>并行</p>
<ul>
<li>微观、宏观都并行。不同线程同一时间用不同CPU核</li>
</ul>
</li>
<li><p>并发</p>
<ul>
<li>微观串行，宏观并行。线程轮流使用CPU</li>
</ul>
</li>
<li><p>对于方法调用：</p>
<ul>
<li>同步：需要等待结果返回，才能继续进行</li>
<li>异步：不需要等待结果返回，就能继续进行</li>
</ul>
</li>
</ul>
<hr>
<p>&#x3D;&#x3D;面试题：进程和线程的区别？你提到进程是资源分配的基本单位，“资源”指的是什么？&#x3D;&#x3D;</p>
<p>当我们说“进程是资源分配的基本单位”时，“资源”主要包括以下几个方面：</p>
<ol>
<li><strong>内存资源</strong>：<ul>
<li>每个进程有独立的<u>虚拟内存地址空间</u>，包括代码段、数据段、堆、栈等。</li>
<li>不同进程之间的内存空间是隔离的。</li>
</ul>
</li>
<li><strong>CPU资源</strong>：<ul>
<li>进程需要 CPU 时间片来执行，操作系统通过调度程序<u>分配 CPU 时间给不同进程</u>。</li>
</ul>
</li>
<li><strong>文件描述符（I&#x2F;O资源）</strong>：<ul>
<li>进程打开的文件、网络套接字、设备等，这些资源是独立分配的，不同进程无法直接访问对方的文件描述符。</li>
</ul>
</li>
<li><strong>设备资源</strong>：<ul>
<li>如打印机、显卡等外部设备。进程通过操作系统的设备驱动程序访问这些资源。</li>
</ul>
</li>
<li><strong>其他系统资源</strong>：<ul>
<li>包括进程的句柄（PID）、信号量、管道、共享内存段等。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态 &amp; 内核态"></a>用户态 &amp; 内核态</h3><p>内核态和用户态是操作系统中的两种运行模式。它们的主要区别在于 <em><strong>权限</strong></em> 和可执行的操作：</p>
<ul>
<li>内核态（Kernel Mode）：在内核态下，CPU可以执行所有的指令和访问所有的硬件资源。这种模式下的操作具有更高的权限，主要用于操作系统内核的运行。</li>
<li>用户态（User Mode）：在用户态下，CPU只能执行部分指令集，无法直接访问硬件资源。这种模式下的操作权限较低，主要用于运行用户程序。</li>
</ul>
<p>内核态的底层操作主要包括：内存管理、进程管理、设备驱动程序控制、系统调用等。这些操作涉及到操作系统的核心功能，需要较高的权限来执行。分为内核态和用户态的原因主要有以下几点：</p>
<ul>
<li>安全性：通过对权限的划分，用户程序无法直接访问硬件资源，从而避免了恶意程序对系统资源的破坏。</li>
<li>稳定性：用户态程序出现问题时，不会影响到整个系统，避免了程序故障导致系统崩溃的风险。</li>
<li>隔离性：内核态和用户态的划分使得操作系统内核与用户程序之间有了明确的边界，有利于系统的模块化和维护。</li>
</ul>
<p>内核态和用户态的划分有助于保证操作系统的安全性、稳定性和易维护性。</p>
<hr>
<h3 id="操作系统的通信方式（-有空再看-）"><a href="#操作系统的通信方式（-有空再看-）" class="headerlink" title="操作系统的通信方式（&#x3D;&#x3D;有空再看&#x3D;&#x3D;）"></a>操作系统的通信方式（&#x3D;&#x3D;有空再看&#x3D;&#x3D;）</h3><p>当问到 <strong>“操作系统的通信方式”</strong>，通常指 <strong>进程间通信（Inter-Process Communication, IPC）</strong>，而不是线程通信。</p>
<p>原因是：</p>
<ul>
<li>操作系统主要负责管理进程及其资源分配，而线程属于进程的执行单元，同一进程内的线程共享内存，不需要操作系统提供专门的通信机制。</li>
<li>进程之间是独立的，拥有各自的内存空间，因此需要依靠操作系统提供的通信机制来交换数据。</li>
</ul>
<h4 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a><strong>进程通信</strong></h4><p>进程之间是相互独立的，通信需要操作系统的参与和支持。进程通信的常见方式包括：</p>
<ul>
<li><p>管道（Pipe）</p>
<ol>
<li><strong>匿名管道</strong>：<ul>
<li>用于父子进程之间的通信。</li>
<li>单向通信，通过 <code>pipe()</code> 系统调用创建。</li>
</ul>
</li>
<li><strong>命名管道（FIFO）</strong>：<ul>
<li>可用于无亲缘关系的进程通信。</li>
<li>通过文件系统路径创建（如 <code>mkfifo()</code>）。</li>
</ul>
</li>
</ol>
<p>管道的通信是<strong>基于内核缓冲区的单向数据流</strong>，适合简单的进程间通信场景，但有缓冲区大小限制，且<u>匿名管道只能用于有亲缘关系的进程。</u></p>
</li>
<li><p>消息队列（Message Queue）</p>
</li>
<li><p>共享内存（Shared Memory）</p>
</li>
<li><p>信号量（Semaphore）</p>
</li>
<li><p>套接字（Socket）</p>
</li>
<li><p>文件</p>
</li>
</ul>
<p>这些机制是 <strong>操作系统提供的通信方式</strong>。</p>
<p>例如：Redis 在生成 RDB 文件时会通过 <code>fork()</code> 创建一个子进程。子进程与主进程通过操作系统提供的 <strong>写时复制（Copy-On-Write, COW）</strong> 共享内存。初始时，父子进程共享相同的物理内存页面，只有在主进程对数据进行修改时，操作系统才会将发生修改的页面复制出来，这样子进程能持续访问原始数据快照，生成 RDB 文件，而主进程可以继续处理客户端的读写请求。</p>
<p>Redis 中的管道用于主进程和子进程的 <strong>状态同步</strong> 和 <strong>控制信号传递</strong>，例如子进程通知主进程 RDB 文件生成完成或遇到错误。而数据的共享和隔离由操作系统的写时复制机制负责。</p>
<h4 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a><strong>线程通信</strong></h4><p>线程共享进程的资源（如内存地址空间、文件描述符），通信相对简单，可以直接通过共享内存进行。常见的线程通信方式包括：</p>
<ul>
<li>全局变量（同一进程内线程共享）</li>
<li>条件变量（Condition Variable）</li>
<li>信号量（Semaphore）</li>
<li>互斥锁（Mutex）</li>
<li>线程安全队列</li>
</ul>
<p>线程通信通常在用户态实现，不依赖操作系统的专门支持，因此线程通信不属于操作系统通信机制的讨论范围。</p>
<h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a><strong>线程的实现方式</strong></h3><h4 id="内核线程实现："><a href="#内核线程实现：" class="headerlink" title="内核线程实现："></a>内核线程实现：</h4><p>也称为 1：1 实现。内核线程（KLT）就是<strong>由操作系统内核支持的线程</strong>，这种线程通过内核来完成线程切换，内核通过任务调度器对线程调度，并负责将线程的任务映射到各个处理器上</p>
<p>程序一般使用内核线程的高级接口——轻量级进程（LWP）。这种轻量级进程和内核线程 1：1 的关系称为一对一线程模型</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221110210513731-1734251548091-2.png" alt="image-20221110210513731" style="zoom:46%;">

<ul>
<li><p>优点：</p>
<p>由于内核线程的支持，每个轻量级进程成为一个独立的调度单元，不会出现整个进程阻塞的情况</p>
</li>
<li><p>缺点：</p>
<p>基于内核线程实现，上下文切换需要在用户态和内核态切换，调度代价高；</p>
<p>每个轻量级进程需要一个内核线程支持，消耗一定内核资源（如内核线程的栈空间），因此系统支持的轻量级进程数量有限</p>
</li>
</ul>
<h4 id="用户线程实现"><a href="#用户线程实现" class="headerlink" title="用户线程实现"></a>用户线程实现</h4><p>  这种进程和用户线程之间 1：N 的关系称为一对多的线程模型。狭义上的用户线程指<strong>完全建立在用户空间的线程库上</strong>，<strong>系统内核不能感知用户线程的存在和实现</strong>，换言之，用户空间中线程的创建、调度、销毁完全由用户级线程库控制，不涉及底层操作系统的支持。</p>
<ul>
<li><p>优点</p>
<p>没有系统内核的支援，用户线程的建立、同步、销毁、调度全在用户态完成，避免了内核态和用户态切换的性能损耗，能支持更大规模的线程数量</p>
</li>
<li><p>缺点</p>
<p>没有系统内核的援助，所有线程操作都需要用户程序自己去处理。由于操作系统只把处理器资源分配给进程，阻塞处理、线程映射到处理器上 等复杂操作要用户程序自己处理</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221110211848521-1734251548091-3.png" alt="image-20221110211848521" style="zoom:40%;"></li>
</ul>
<h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4>  <img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221110212114732-1734251548091-4.png" alt="image-20221110212114732" style="zoom:45%;">



<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20240302145818766-1734251548091-5.png" style="zoom: 67%;">



<h3 id="java线程实现"><a href="#java线程实现" class="headerlink" title="java线程实现"></a>java线程实现</h3><p>对于 HotSpot ，每个 java 线程直接映射到一个操作系统原生内核线程，中间没有额外的间接结构。因此，<strong>JVM 不会干涉线程调度</strong>（可以设置线程优先级给操作系统线程调度提建议），<strong>由操作系统全权决定。</strong></p>
<h4 id="1-创建线程（常考）"><a href="#1-创建线程（常考）" class="headerlink" title="&#x3D;&#x3D;1. 创建线程（常考）&#x3D;&#x3D;"></a>&#x3D;&#x3D;1. 创建线程（常考）&#x3D;&#x3D;</h4><ol>
<li>使用 <strong>匿名内部类</strong> <strong>继承</strong> <strong>Thread 类</strong> 创建线程，原理是通过直接<strong>重写</strong> <strong>Thread类</strong> 的 <code>run()</code>方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个继承 Thread 的匿名内部类</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;name&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  <span class="comment">//匿名子类重写了父类中的 run 方法</span></span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//本质是运行了自身覆盖的run代替了Thread.run()</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p>Thread 的源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Runnable target;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span>  <span class="comment">//函数式接口，说明只有一个抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <strong>匿名内部类</strong> <strong>实现</strong> <strong>Runnable 接口</strong>。 配合 Thread ,【线程】和【任务】分离。将 Runnable 任务当作参数投到 Thread 类中，执行 Thread 的 run 方法，而 Thread 的 run 方法转而去执行 Runnable 的 run 方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建线程对象</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task，<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//本质是通过Thread.run()调用了Runnable.run()</span></span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<p> 使用 Runnable 的优点：</p>
<ul>
<li><strong>更容易和线程池等高级 API 配合</strong>，因为任务和线程分离了，我们只需要将任务扔到线程池里就行，而不是之前那种任务和线程耦合在一起</li>
<li><strong>让任务类脱离了Thread继承体系</strong>，更灵活（组合优于继承）我的线程可以执行不同任务，一个任务也不用和一个线程相绑定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lambda</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="comment">//do somenthing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用<strong>匿名内部类</strong>继承 <strong>FutureTask</strong> 类， FutureTask 配合 Thread，执行有返回值的任务</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FutureTask接收Callable类型的参数，处理有返回结果的情况</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throw</span> Exception &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line"><span class="comment">//主线程阻塞，同步等待task执行完毕的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task.get();</span><br></pre></td></tr></table></figure>

<p>Runnable 和 Callable 都是一个<strong>函数式接口</strong>，有 @FunctionalInterface 接口（接口中只有一个抽象方法）。</p>
<p>Callable 和 Runnable 区别：</p>
<ul>
<li>Callable 规定方法是 call，Runnable 规定方法是 run。</li>
<li>Callable 执行任务<strong>有返回值</strong>，返回值通过 <code>Future.get()</code> 得到。run 没有返回值。</li>
<li>call 方法能<strong>抛出异常</strong>，run 不能。</li>
<li>运行 Callable 任务可以拿到一个 Future 对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过 Future 对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230314115015972-1734251548091-6.png" alt="image-20230314115015972" style="zoom:50%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230314115038448-1734251548091-7.png" alt="image-20230314115038448" style="zoom:50%;">

<h4 id="2-查看线程进程"><a href="#2-查看线程进程" class="headerlink" title="2. 查看线程进程"></a>2. 查看线程进程</h4><p><strong>windows：</strong></p>
<ul>
<li>任务管理器</li>
<li><code>tasklist</code> 查看进程</li>
<li><code>taskkill</code> 杀死进程</li>
</ul>
<p><strong>linux：</strong></p>
<ul>
<li><code>ps -fe</code> 查看所有进程</li>
<li><code>ps -fT -p &lt; pid&gt;</code> 查看某个进程的所有线程</li>
<li><code>kill</code> 杀死进程</li>
<li><code>top</code> 可以动态查看进程或线程的信息，包括 PID， 内存、CPU 占用率，显示资源占用情况</li>
<li><code>top -H -p &lt; pid&gt;</code> 查看某个进程的所有线程。-H :查看线程 -p：指定进程ID</li>
</ul>
<p><strong>java：</strong></p>
<ul>
<li><code>jps</code> :查看所有java进程</li>
<li><code>jstack &lt; pid&gt;</code>：查看某个java进程的所有线程状态, 信息详细，但是是抓一个快照</li>
<li><code>jconsole</code>： 查看某个 Java 进程中线程的运行情况（图形界面）</li>
</ul>
<h4 id="3-线程运行原理"><a href="#3-线程运行原理" class="headerlink" title="3. 线程运行原理"></a>3. 线程运行原理</h4><h5 id="栈和栈帧"><a href="#栈和栈帧" class="headerlink" title="栈和栈帧"></a><strong>栈和栈帧</strong></h5><p>JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p>
<ul>
<li>每个栈由多个<strong>栈帧（Frame）</strong>组成，对应着每次<strong>方法调用</strong>时所占用的内存 </li>
<li>每个线程只能有一个<strong>活动栈帧</strong>，对应着当前<strong>正在执行的那个方法</strong></li>
</ul>
<h5 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a><strong>上下文切换</strong></h5><p>CPU 不执行当前线程，转向执行另一线程，叫做 上下文切换</p>
<blockquote>
<p>什么情况可能导致上下文切换呢？<br>(1) 线程的CPU时间片用完了<br>(2) 垃圾回收停顿用户线程<br>(3) 有更高优先级的线程要执行<br>(4) 线程自己调用了 sleep、yield、wait、join、part、synchronized、lock等方法</p>
</blockquote>
<p>上下文切换需要操作系统<strong>保存当前线程状态</strong>，并恢复另一线程的执行。对应着java中的概念就是程序计数器，它会记住下一条jvm指令的执行地址，是线程私有的。</p>
<p><strong>状态包括程序计数器，栈中每个栈帧的信息，包括局部变量表、操作栈、返回地址等</strong>，所以，大量的线程切换会导致效率变低，影响性能。</p>
<h4 id="4-常用方法"><a href="#4-常用方法" class="headerlink" title="4. 常用方法"></a>4. 常用方法</h4><p><strong>Thread.start()</strong><br>让线程进入就绪状态，但不一定运行（这取决于OS的任务调度器）。线程运行会执行自己的run方法。start只能用一次，否则会<code>IllegalThreadStateException</code>报错</p>
<p><strong>Thread.run()</strong><br>1.构造Thread对象时传入了Runnable任务对象，就执行任务对象的run方法<br>2.无参构造Thread对象，需要执行自己重写的run方法</p>
<p><strong>Thread.sleep(long n)</strong><br>1.当前线程休眠，<strong>让出cpu，但不放弃锁</strong>，从 <code>RUNNABLE</code> 进入 <code>TIMED_WAITING</code> 状态</p>
<p>2.其他线程可以使用 <code>interrupt</code> 方法打断正在睡眠的线程，这时 sleep 方法会抛出 <code>InterruptedException</code> </p>
<p>3.睡眠结束后的线程未必会立刻得到执行 </p>
<p>4.建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</p>
<p><strong>Thread.yield()</strong></p>
<p>1.当前线程让出cpu，从<code>Running</code>变为<code>Runnable</code>就绪态</p>
<p>2.具体是否执行取决于OS任务调度器</p>
<p><strong>Thread.interrupt()</strong></p>
<p>1.打断正常运行的线程</p>
<blockquote>
<p>会使打断标记变成真，利用打断标记可让程序自行决定被打断后是否继续执行</p>
</blockquote>
<p>2打断阻塞的线程（sleep、join、wait）</p>
<blockquote>
<p>打断后会使打断标记变为假</p>
</blockquote>
<h3 id="线程状态-流转"><a href="#线程状态-流转" class="headerlink" title="&#x3D;&#x3D;线程状态 &amp; 流转&#x3D;&#x3D;"></a>&#x3D;&#x3D;线程状态 &amp; 流转&#x3D;&#x3D;</h3><p>操作系统角度</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102202943166-1734251548091-8.png" alt="image-20221102202943166" style="zoom:67%;">

<p><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20250103134537375.png" alt="image-20250103134537375"></p>
<h3 id="【初始状态】"><a href="#【初始状态】" class="headerlink" title="【初始状态】"></a><strong>【初始状态】</strong></h3><p>仅在语言层面创建 Java 线程对象，没有和操作系统线程关联，即没有执行 <code>Thread.start()</code></p>
<h3 id="【就绪状态】"><a href="#【就绪状态】" class="headerlink" title="【就绪状态】"></a><strong>【就绪状态】</strong></h3><p>线程已经和操作系统关联，可以由CPU调度执行。即在就绪状态的进程除 CPU 之外，其它的运行所需资源都已全部获得。</p>
<h3 id="【运行状态】"><a href="#【运行状态】" class="headerlink" title="【运行状态】"></a><strong>【运行状态】</strong></h3><p>CPU 正在运行的线程，如果时间片消耗完，或者调用 <code>yield()</code>，会进入<strong>就绪状态</strong>，导致<strong>上下文切换</strong></p>
<h3 id="【阻塞状态】"><a href="#【阻塞状态】" class="headerlink" title="【阻塞状态】"></a><strong>【阻塞状态】</strong></h3><p>线程因为某种原因放弃 CPU 使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。</p>
<p>阻塞的情况分三种：</p>
<ol>
<li><strong>等待阻塞：</strong>运行的线程执行 <code>wait()</code> 方法，该线程会释放占用的所有资源，JVM 会把该线程放入 <em>“等待池”</em> 中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法才能被唤醒，</li>
<li><strong>同步阻塞：</strong>运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入 <em>“锁池”</em> 中。</li>
<li>其他阻塞：运行的线程执行 <code>sleep()</code>或 <code>join()</code> 方法，或者发出了 I&#x2F;O 请求时，JVM会把该线程置为阻塞状态。当<code>sleep()</code> 状态超时、<code>join()</code> 等待线程终止或者超时，或者 I&#x2F;O 处理完毕时，线程重新转入就绪状态。</li>
</ol>
<p>【阻塞状态】与【可运行&#x2F;就绪状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑调度它们</p>
<h3 id="【终止状态】"><a href="#【终止状态】" class="headerlink" title="【终止状态】"></a><strong>【终止状态】</strong></h3><p>线程执行完了或者因异常退出了 <code>Runnable.run()</code> 方法，该线程结束生命周期。</p>
<p>Java API角度</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102203546452-1734251548091-9.png" alt="image-20221102203546452" style="zoom:67%;">



<h3 id="Java-与协程（！）"><a href="#Java-与协程（！）" class="headerlink" title="Java 与协程（！）"></a>Java 与协程（！）</h3><p><strong>内核线程调度</strong>的成本主要来自于**&#x3D;&#x3D;用户态&#x3D;&#x3D;和&#x3D;&#x3D;核心态&#x3D;&#x3D;的状态转化<strong>，</strong>状态转化<strong>的开销主要来自于</strong>响应中段<strong>、</strong>保护和恢复现场现场**的成本。</p>
<p><strong>协程是一种轻量级线程</strong>，提供一种更加灵活、轻量级的任务切换方式，其最初设计时采用<strong>协同式调度</strong>，即线程自己决定何时放弃执行权，而不是被强制性地抢占。这使得协程更加灵活，但也需要开发者自行实现调度逻辑。</p>
<p>有栈协程是一种具有自己独立调用栈的协程实现。它能够完整地保存和恢复调用栈，包括局部变量、函数调用关系等，使得在协程间切换时能够保留完整的执行现场。</p>
<p>协程的优势是轻量，因为它避免了内核线程的开销，但是需要在应用层面实现的内容特别多（调用栈、调度器等）</p>
<p>纤程是一种特殊的有栈协程，它的出现提供了一种新并发模型。一段使用纤程并发的代码会被分成两部分——执行过程和调度器。</p>
<ol>
<li>Linux平常使用吗</li>
<li>线程和进程的区别，还有什么类似进程和线程的吗</li>
<li>什么是协程</li>
<li>CPU满了怎么看，怎么办</li>
<li>Linux下rm正在写入的文件会发生什么？</li>
<li>那么该如何在不使用kill的情况下删除该文件</li>
<li>磁盘满了怎么看</li>
<li>进程状态以及特殊两种状态</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_54549527/article/details/130394205">https://blog.csdn.net/qq_54549527/article/details/130394205</a></p>
<ol>
<li>僵尸线程和孤儿线程是什么</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1594157">https://cloud.tencent.com/developer/article/1594157</a></p>
<ol>
<li>清空进程时什么进程还存活？</li>
</ol>
<p>在Linux中，清空进程的指令通常是指杀死（终止）进程的操作，最常见的指令是 <code>kill</code>。但即使杀死了一个进程，仍然可能会有一些进程存活下来。这取决于这些进程的关系和状态。以下是一些可能的情况：</p>
<ol>
<li><strong>子进程：</strong> 如果一个进程创建了子进程，即使父进程被杀死，子进程仍然可能存活。这是因为子进程的生命周期不受父进程的影响。</li>
<li><strong>守护进程：</strong> 守护进程通常在后台运行，并且独立于终端。即使终端关闭或用户退出，守护进程仍然可以继续运行。</li>
<li><strong>僵尸进程：</strong> 当一个进程终止时，它的父进程可能会调用 <code>wait()</code> 系统调用来获取子进程的退出状态。如果父进程没有调用 <code>wait()</code>，那么子进程就会变成僵尸进程。这种情况下，即使父进程被终止，僵尸进程仍然会存在，直到父进程调用 <code>wait()</code> 来获取子进程的退出状态并将其清理掉。</li>
<li><strong>被挂起的进程：</strong> 有些进程可能被挂起或处于等待状态，例如等待某个条件的发生或等待资源的释放。这些进程可能会在条件满足或资源释放后重新开始执行。</li>
</ol>
<h2 id="线程安全问题及其解决方法"><a href="#线程安全问题及其解决方法" class="headerlink" title="线程安全问题及其解决方法"></a>线程安全问题及其解决方法</h2><p>对于<strong>多个线程访问同一共享资源</strong>的情况，由于<strong>上下文切换</strong>有可能出现线程安全问题</p>
<p>比如 两个线程同时对共享变量i分别进行i++和i–操作，就可能出现</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102190405037.png" style="zoom:50%;">

<blockquote>
<p><strong>临界区：</strong></p>
<p>一段代码块内如果存在对<strong>共享资源的多线程读写操作</strong>，那么这段代码块被称为临界区</p>
</blockquote>
<blockquote>
<p><strong>竞态条件：</strong></p>
<p>多个线程在临界区内执行，由于<strong>代码的执行序列不同导致结果无法预测</strong>，称为发生竞态条件</p>
</blockquote>
<p><strong>面试题：写一个多线程导致竞态条件的例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[]args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>变量的线程安全分析</strong></p>
<ol>
<li><p>静态变量、成员变量：有可能被共享</p>
</li>
<li><p>局部变量：局部变量是线程私有的（在虚拟机栈的栈帧的局部变量表里面），本身不可能被共享，但是不排除局部变量引用所指向的对象是共享变量</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> num1;  <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> num2; <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> x;  <span class="comment">// 局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>常见的线程安全类：</strong></p>
<ol>
<li><p>基本类型的包装类</p>
</li>
<li><p>String：不可变类，内部逻辑有final修饰</p>
</li>
<li><p>StringBuffer：不可变类</p>
</li>
<li><p>Random</p>
</li>
<li><p>Vector</p>
</li>
<li><p>Hashtable</p>
</li>
<li><p>JUC包下的类</p>
</li>
</ol>
<p>注意：每个方法是原子的，但他们的组合不一定是原子的</p>
<h3 id="park-unpark"><a href="#park-unpark" class="headerlink" title="park &amp; unpark"></a>park &amp; unpark</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//他们是 LockSupport 类中的方法</span></span><br><span class="line"><span class="comment">//暂停当前线程</span></span><br><span class="line">LockSupport.park();</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(被暂停的线程对象)</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<ul>
<li>先 unpark 再 park ，会导致线程暂停不住。park &amp; unpark 可以先 unpark，但是 wait &amp; notify 不能先 notify</li>
<li>wait &amp; notify 必须配合 Object Monitor 使用，而 park &amp; unpark 不必</li>
<li>park &amp; unpark 以线程为单位【阻塞】和【唤醒】一个线程，而 notify 只能随机唤醒一个线程，notifyAll 唤醒所有线程</li>
</ul>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h4><p>每个线程都有自己的 Paker 对象（底层 C++ 实现），由 <code>_counter</code> , <code>_cond</code> , <code>_mutex</code> 组成</p>
<ul>
<li>线程调用 <code>Unsafe.park()</code> 方法<ul>
<li>检查 <code>_counter</code>，如果 <code>_ counter</code> 为 0 <ul>
<li>获得 <code>_mutex</code> 互斥锁，进入 <code>_cond</code> 条件变量阻塞，并设置 <code>_counter</code> 为 0</li>
</ul>
</li>
<li>检查 <code>_counter</code>，如果 <code>_counter</code> 为 1 <ul>
<li>线程无需阻塞，继续运行，并设置 <code>_counter</code> 为 0</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107174542671.png" style="zoom:67%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107174748878.png" style="zoom:67%;">

<ul>
<li>线程调用 <code>Unsafe.unpark(Thread-0)</code> 方法，设置 <code>_counter</code> 为 1<ul>
<li>唤醒 <code>_cond</code> 条件变量中的 Thread-0</li>
<li>恢复线程运行</li>
<li>设置 <code>_counter</code> 为 0</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107175347986.png" alt="image-20221107175347986" style="zoom:67%;">



<h2 id="Java-中的锁"><a href="#Java-中的锁" class="headerlink" title="Java 中的锁"></a>Java 中的锁</h2><p>Java 中的锁是一种用于控制并发访问资源的机制。它可确保在<strong>同一时间只有一个线程可以访问被锁定的资源</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/1321729">Java 锁面试题</a></p>
<h3 id="阻塞式悲观锁（！）"><a href="#阻塞式悲观锁（！）" class="headerlink" title="阻塞式悲观锁（！）"></a>阻塞式悲观锁（！）</h3><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="&#x3D;&#x3D;synchronized&#x3D;&#x3D;"></a>&#x3D;&#x3D;synchronized&#x3D;&#x3D;</h3><p>在 Java 中，<code>synchronized</code> 是用	于实现线程同步的关键字，它可以应用于 <em><strong>方法</strong></em> 或 <em><strong>代码块</strong></em>。主要目的是为了确保在多线程环境下对共享资源的访问是安全的，避免因为竞态条件而导致的数据不一致或不正确的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.方法 级别的 synchronized，一次只能有一个线程执行该方法。</span></span><br><span class="line"><span class="comment">// 其他线程如果尝试调用被锁定的方法，它们会被阻塞，直到获得锁的线程执行完毕释放锁。</span></span><br><span class="line"><span class="comment">// 静态方法锁住的是方法所在类的class对象，实例方法锁住的是方法所在的对象。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 同步的方法体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.代码块级别的 synchronized</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">someMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 非同步的代码</span></span><br><span class="line">    <span class="keyword">synchronized</span> (lockObject) &#123;</span><br><span class="line">        <span class="comment">// 同步的代码块，使用 lockObject 作为锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 非同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多线程竞争锁图示：</p>
<p>synchronized 实际是用对象锁保证了临界区内代码的原子性，临界区内的代码对外是不可分割的，不会被线程切<br>换所打断。</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20241219232436870.png" alt="image-20241219232436870" style="zoom:80%;">

<h3 id="Synchronized的锁升级过程说一下"><a href="#Synchronized的锁升级过程说一下" class="headerlink" title="Synchronized的锁升级过程说一下"></a>Synchronized的锁升级过程说一下</h3><p>synchronized <strong>锁对象</strong> 的升级过程包括三种状态：无锁状态、偏向锁状态和轻量级锁状态。</p>
<ul>
<li><em><strong>无锁状态</strong></em>：初始时 锁对象 处于无锁状态，没有任何线程对其进行加锁操作。</li>
<li><em><strong>偏向锁状态</strong></em>：当某个线程获取了对象的锁时（偏向于该线程），对象会进入偏向锁状态。此时，如果其他线程想要获取该对象的锁，会触发偏向锁撤销，升级为轻量级锁。</li>
<li><em><strong>轻量级锁状态</strong></em>：当多个线程争夺同一个锁时，对象的状态会从偏向锁升级为轻量级锁。轻量级锁使用CAS操作来尝试获取锁，如果获取锁失败，会升级为重量级锁。</li>
<li><em><strong>重量级锁状态</strong></em>：当多个线程无法通过轻量级锁的CAS操作获得锁时，会升级为重量级锁。在重量级锁状态下，会使用操作系统的 mutex 互斥锁来实现锁的争抢。</li>
</ul>
<h3 id="Synchronized是公平锁吗？"><a href="#Synchronized是公平锁吗？" class="headerlink" title="Synchronized是公平锁吗？"></a>Synchronized是公平锁吗？</h3><p>Synchronized 不属于公平锁，ReentrantLock 是公平锁。</p>
<h3 id="ReentrantLock是怎么实现公平锁的？"><a href="#ReentrantLock是怎么实现公平锁的？" class="headerlink" title="ReentrantLock是怎么实现公平锁的？"></a>ReentrantLock是怎么实现公平锁的？</h3><p>面我们来看一下公平锁与非公平锁的加锁方法的源码。公平锁的锁获取源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; <span class="comment">//这里判断了 hasQueuedPredecessors()</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            </span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非公平锁的锁获取源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">//这里没有判断      hasQueuedPredecessors()</span></span><br><span class="line"></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line"></span><br><span class="line">        setState(nextc);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过对比，我们可以看出公平锁与非公平锁的 <code>lock()</code> 方法唯一的区别就在于公平锁在获取锁时多了一个限制条件：<code>hasQueuedPredecessors()</code> 为 false，这个方法就是判断在等待队列中是否已经有线程在排队了。</p>
<p>这也就是公平锁和非公平锁的核心区别，<strong>如果是公平锁，那么一旦已经有线程在排队了，当前线程就不再尝试获取锁；对于非公平锁而言，无论是否已经有线程在排队，都会尝试获取一下锁，获取不到的话，再去排队。</strong>这里有一个特例需要我们注意，针对 tryLock() 方法，它不遵守设定的公平原则。</p>
<p>例如，当有线程执行 tryLock() 方法的时候，一旦有线程释放了锁，那么这个正在 tryLock 的线程就能获取到锁，即使设置的是公平锁模式，即使在它之前已经有其他正在等待队列中等待的线程，简单地说就是 tryLock 可以插队。</p>
<p>看它的源码就会发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用的就是 <code>nonfairTryAcquire()</code>，表明了是不公平的，和锁本身是否是公平锁无关。综上所述，公平锁就是会按照多个线程申请锁的顺序来获取锁，从而实现公平的特性。</p>
<p>非公平锁加锁时不考虑排队等待情况，直接尝试获取锁，所以存在后申请却先获得锁的情况，但由此也提高了整体的效率。</p>
<h4 id="重量级锁Monitor"><a href="#重量级锁Monitor" class="headerlink" title="重量级锁Monitor"></a><strong>重量级锁Monitor</strong></h4><p>首先，我们要了解一下对象头的结构，对象头用于存储对象的元信息</p>
<p>对于普通对象</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102204314101.png" style="zoom: 67%;"> 

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102204336250.png" style="zoom: 67%;"> 

<p><em><strong>标记字（Mark Word）</strong></em>是 Java 对象头的一部分，用于存储对象的一些状态信息。它的主要作用是在并发环境中进行对象的锁定和标记，以支持多线程的同步和垃圾回收。</p>
<p>在经典的 HotSpot JVM 中，标记字的结构可能包含以下信息：</p>
<p><strong>（1）锁信息：</strong></p>
<ul>
<li><p>存储对象的锁状态，用于实现同步。常见的锁状态包括：</p>
<ul>
<li><p><em><strong>无锁</strong></em> 状态：对象没有被锁定。</p>
</li>
<li><p><em><strong>偏向锁</strong></em> 状态：对象被线程偏向于某个特定的线程，避免多线程竞争。</p>
</li>
<li><p><em><strong>轻量级锁</strong></em> 状态：对象被多个线程竞争，使用 CAS 操作尝试获得锁。</p>
</li>
<li><p><em><strong>重量级锁</strong></em> 状态：对象被多个线程竞争，使用操作系统的互斥量实现锁。</p>
</li>
</ul>
</li>
</ul>
<p><strong>（2）GC 相关信息：</strong></p>
<ul>
<li>存储垃圾回收器的一些信息，用于辅助垃圾回收。例如，对象是否可回收、对象的分代年龄等。</li>
</ul>
<p><strong>（3）其他特殊状态：</strong></p>
<ul>
<li>一些特殊状态信息，如 HashCode、分代年龄、偏向线程的 ID 等。</li>
</ul>
<p>每个 Java 对象都关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）后，对象头的 Mark Word 就设置成了指向Monitor 的指针，而它原来的内容则会在 Monitor 中暂存，解锁以后在归还给对象头</p>
<p><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221102204815624.png" alt="image-20221102204815624"></p>
<ul>
<li><p>刚开始 Monitor 中的 Owner 为 null</p>
</li>
<li><p>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner</p>
</li>
<li><p>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKED</p>
</li>
<li><p>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的</p>
</li>
<li><p>中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程</p>
</li>
<li><p>注意：</p>
<blockquote>
<p>synchronized 必须是进入到同一个对象的 monitor 才有加锁效果</p>
<p>不加 synchronized 的对象不会关联监视器</p>
</blockquote>
</li>
</ul>
<p><strong>轻量级锁</strong></p>
<p>使用场景：一个对象虽然有多线程要加锁，但是加锁时间错开，可以用轻量级锁来优化</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103190222699.png" alt="image-20221103190222699" style="zoom:80%;">

<ul>
<li><p>创建锁记录对象，给个线程栈帧中都包含一个锁记录结构，内部可以锁定对象的Mark Word</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103190405232.png" alt="image-20221103190405232" style="zoom:80%;">
</li>
<li><p>让锁记录中Object reference指向锁对象，用cas替换object中的Mark Word，将Mark Word暂存到锁记录中</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103190601922.png" alt="image-20221103190601922" style="zoom:80%;">
</li>
<li><p>cas替换成功，对象头存储了锁记录地址和状态00（标识轻量级锁）</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103190733248.png" alt="image-20221103190733248" style="zoom:80%;">
</li>
<li><p>cas失败：</p>
<ul>
<li>其他线程已经持有改object的轻量级锁，发生锁竞争，锁膨胀为重量级锁</li>
<li>执行锁重入，就再添加一条Lock Record作为重入的计数<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103191132502.png" alt="image-20221103191132502" style="zoom:80%;"></li>
</ul>
</li>
<li><p>解锁时</p>
<ul>
<li>如果有取值为null的锁记录，说明有锁重入，这时充值锁记录，表示重入计数-1</li>
<li>锁记录值不为null，使用cas将Mark Word的值恢复给对象头（失败的话说明锁已经膨胀，要进行重量级锁的解锁过程）</li>
</ul>
</li>
</ul>
<p>​	<strong>锁膨胀</strong></p>
<p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁，这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103191919421.png" alt="image-20221103191919421" style="zoom:80%;">

<ul>
<li><p>Thead-1进行轻量级加锁时，Thread-0已经为对象加轻量级锁。此时进行锁膨胀</p>
<ul>
<li><p>为object申请Monitor锁，让object指向重量级锁地址</p>
</li>
<li><p>自己进入Monitor的EntryList，状态为BLOCKED</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221103192157312.png" alt="image-20221103192157312" style="zoom:80%;"></li>
</ul>
</li>
<li><p>Thread-0解锁时，用cas将Mark Word恢复给对象头，失败。进入重量级锁解锁流程，按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中BLOCKED的线程</p>
<p><strong>自旋优化</strong></p>
<p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就可以避免阻塞</p>
<p>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势</p>
</li>
</ul>
<p><strong>偏向锁</strong></p>
<p>使用场景：轻量级锁再没有竞争时，每次重入都要执行cas操作，引入偏向锁作为优化，只有第一次使用 CAS 将线程ID设置到对象的Mark Word头，之后发现 这个线程ID是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p>
<p><strong>wait notify原理</strong></p>
<ul>
<li>Owner线程发现条件不满足，调用wait方法，即进入WaitSet变为WAITING状态，为阻塞状态，不占用时间片，并且会放弃锁</li>
<li>BLOCKED线程会在Owner线程释放时被唤醒</li>
<li>WAITING线程在Owner线程调用notify或notifyAll时被唤醒，但这不意味着立即获得锁，仍需进入EntryList重新竞争</li>
</ul>
<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>利用实现 Lock 接口的类实现锁，例如 ReentrantLock</p>
<p>特点：可中断、可设置超时时间、可设置为公平锁、支持多个条件变量、可重入</p>
<p><strong>死锁问题</strong></p>
<ul>
<li><p>解决方法</p>
<ul>
<li>线程申请资源时，一次性得请求他所需要的所有资源。若无法满足则不能执行。</li>
<li>进程在申请新的资源时，释放已占有的资源。后面若还需要它们，则需要重新申请。</li>
<li>将系统中的资源顺序编号，规定进程只能依次申请资源。</li>
</ul>
</li>
<li><p>死锁 和 阻塞 的区别</p>
<ul>
<li>阻塞是由于资源不足引起的排队等待的现象</li>
<li>死锁是至少两个对象相互持有对方所需要的资源，而都在等待对方释放资源</li>
</ul>
</li>
<li><p><strong>避免</strong>死锁著名算法</p>
<ul>
<li>银行家算法，动态检测资源分配，确保“循环等待”条件永远不成立</li>
<li>每个进程事先预报需要的最大资源，算法确保系统处于 safety 状态</li>
</ul>
<blockquote>
<p>预防死锁要破坏四个必要条件，代价大，不可行</p>
</blockquote>
</li>
</ul>
<h3 id="Java-内存模型（-JMM-）"><a href="#Java-内存模型（-JMM-）" class="headerlink" title="Java 内存模型（ JMM ）"></a>Java 内存模型（ JMM ）</h3><p>JMM 用来屏蔽各种硬件和操作系统的内存访问差异，以实现让 java 程序在各种平台下都能达到一致的内存访问效果</p>
<p>JMM 定义了主存、工作内存抽象概念，底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等</p>
<p>JMM 的主要目的是定义程序中各种共享变量的访问规则，即关注在虚拟机中把变量的值存储到工作内存和从工作内存中取出变量这样的底层细节</p>
<blockquote>
<p>注意：</p>
<p>这里的共享变量包括 实例字段、静态字段、数组对象的元素</p>
<p>不包括 方法参数、局部变量，因为它们是线程私有，不存在共享问题</p>
</blockquote>
<p>内存间的交互操作</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
<th>作用范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>锁定</td>
<td>主内存</td>
<td>把一个变量标识为一条线程独占的状态</td>
</tr>
<tr>
<td>unlock</td>
<td>解锁</td>
<td>主内存</td>
<td>把一个处于锁定状态的变量释放出来</td>
</tr>
<tr>
<td>&#x3D;&#x3D;read&#x3D;&#x3D;</td>
<td>读取</td>
<td>主内存</td>
<td>把变量的值从主存传输到工作内存中，以便随后的 load 使用</td>
</tr>
<tr>
<td>&#x3D;&#x3D;load&#x3D;&#x3D;</td>
<td>载入</td>
<td>工作内存</td>
<td>把 read 操作从主存得到的变量值放到工作内存的变量副本中</td>
</tr>
<tr>
<td>use</td>
<td>使用</td>
<td>工作内存</td>
<td>把工作内存的变量值传给执行引擎，对应需要使用变量的值的字节码指令</td>
</tr>
<tr>
<td>assign</td>
<td>赋值</td>
<td>工作内存</td>
<td>把执行引擎接收到值赋给工作内存的变量，对应给变量赋值的字节码指令</td>
</tr>
<tr>
<td>store</td>
<td>存储</td>
<td>工作内存</td>
<td>把工作内存变量值传给主存，以供后续 write 使用</td>
</tr>
<tr>
<td>write</td>
<td>写入</td>
<td>主内存</td>
<td>把 store 操作从工作内存中得到的变量值放到主内存的变量中</td>
</tr>
</tbody></table>
<blockquote>
<p>把变量从 主内存 拷贝到 工作内存 中，按顺序执行 read、load 操作</p>
<p>把变量从 工作内存 拷贝到 主内存 中，按顺序执行 store、write 操作</p>
<p>只要求按顺序执行，不要求连续执行</p>
</blockquote>
<p>JMM体现在以下几个方面：</p>
<blockquote>
<p>原子性：指令不受上下文切换的影响</p>
<p>可见性：指令不受cpu缓存的影响，一个指令对主存数据的修改，对另一个线程可见</p>
<p>有序性：指令不受cpu指令并行优化的影响</p>
</blockquote>
<h4 id="可见性问题"><a href="#可见性问题" class="headerlink" title="可见性问题"></a><strong>可见性问题</strong></h4><h5 id="什么是可见性问题？"><a href="#什么是可见性问题？" class="headerlink" title="什么是可见性问题？"></a><strong>什么是可见性问题？</strong></h5><p><strong>可见性问题是指当多个线程访问共享变量时，一个线程对共享变量的修改可能对其他线程不可见。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptrdException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span>(run) &#123; <span class="comment">//do something &#125;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现象：main 线程对 run 变量的修改对 t 线程不可见，t 线程无法停止</p>
<p>原因：</p>
<p>​	1.初始状态，t 线程从 <strong>主内存</strong> 读取 run 变量值到工作内存</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221105141156908.png" style="zoom: 50%;"> 



<p>​	2.因为 t 线程要频繁从主存读取 run 值，JIT 编译器会将 run 值缓存到自己的 <strong>工作内存</strong> 的高速缓存中，减少对主存的访问，提高效率</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221105141411364.png" style="zoom: 60%;"> 

<ol start="3">
<li>1 秒后，main 线程修改了 run 变量值，并同步到主存，而 t 线程仍然从自己的 工作内存 读取变量，结果永远是旧值</li>
</ol>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221105141644115.png" style="zoom:60%;"> 

<h5 id="如何解决可见性问题"><a href="#如何解决可见性问题" class="headerlink" title="如何解决可见性问题"></a>如何解决可见性问题</h5><ul>
<li><p>使用 <code>volatile</code>关键字：确保共享变量的修改对所有线程都是可见的。</p>
</li>
<li><p>使用锁：通过加锁和解锁操作来保证对共享变量的访问互斥性和可见性。</p>
</li>
<li><p>使用原子类：使用原子类（如<code>AtomicBoolean</code>、<code>AtomicInteger</code>）对共享变量的修改实现线程安全和可见性。</p>
</li>
</ul>
<p>volatile 修饰成员变量和静态成员变量，避免线程从工作缓存中查找变量值，必须从主内存获取</p>
<blockquote>
<p><strong>注意：</strong> synchronized 可保证原子性、可见性，但是属于重量级操作，性能低；<code>System.out.println()</code> 也会保证读取变量在主存中读取</p>
</blockquote>
<p><strong>有序性</strong></p>
<p>JVM 在不影响正确性的前提下，会调整语句的执行顺序，其内在原理是 CPU 的指令重排序优化。</p>
<blockquote>
<p>每条指令可分为 取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回 5 个阶段，这些指令的各个阶段可通过<strong>重排序</strong>和<strong>组合</strong>实现<strong>指令级并行</strong>。现代CPU支持多条指令流水线，并不能缩短单条指令执行时间，却提高了指令的吞吐率</p>
</blockquote>
<p><strong>volatile 原理</strong></p>
<ul>
<li>volatile 变量在各个线程的工作内存中不存在一致性问题，保证可见性</li>
</ul>
<p>底层使用内存屏障（Memory Barrier）：</p>
<ul>
<li>对 volatile 变量的写指令后加入写屏障</li>
<li>对 volatile 变量的读指令前加入读屏障</li>
</ul>
<blockquote>
<p><strong>内存屏障</strong></p>
<ul>
<li><p>可见性</p>
<ul>
<li>写屏障 保障该屏障之前的，对共享变量的改动，都同步到主存中</li>
<li>读屏障 保障该屏障之后的，对共享变量的读取，加载的是主存中的最新数据</li>
</ul>
</li>
<li><p>有序性</p>
<ul>
<li>写屏障 保障该屏障之前的代码，在指令重排时，不会排在写屏障之后</li>
<li>读屏障 保障该屏障之后的代码，在指令重排时，不会排在读屏障之前</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>double-checked locking问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singletion</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singletion</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singletion <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">//双重锁，使得只有第一次调用才需要进入同步块创建实例，高效</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">//也许有其他线程已经创建实例，所以再判断一次</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singletion</span>();</span><br><span class="line">                        <span class="comment">//保证先invokespecial（调用构造方法），再 putstatic（给INSTANCE赋值）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>特点：</p>
<blockquote>
<ol>
<li>懒惰初始化</li>
<li>首次使用 getInstance（）才需要加锁，后续使用无需加锁</li>
<li>volatile 使得 给INSTANCE 赋值之前的代码 调用构造方法 按顺序执行</li>
</ol>
</blockquote>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221105163706708.png" alt="image-20221105163706708" style="zoom:50%;">

<p><strong>happens-before</strong></p>
<p>总结了一个线程对共享变量的写，对其他线程的读可见的 7 种情况</p>
<blockquote>
<ol>
<li>线程对一个锁对象解锁前对变量的写操作，对于接下来对同一个锁对象加锁的线程而言，该变量可见</li>
<li>线程对 violate 变量的写，对其他线程对变量的读可见</li>
<li>线程 start 对变量的写，对线程开始后对变量的读可见</li>
<li>线程结束后对变量的写，对其他线程得知它结束后的读可见(t.isAlive或t.join)</li>
<li>线程 t1 打断 t2 (interrupt) 前对变量的写，对于其他线程得知 t2 被打断后对该变量的读可见（t2.isInterrupted）</li>
<li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li>
<li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z</li>
</ol>
</blockquote>
<h3 id="CAS-非阻塞方式"><a href="#CAS-非阻塞方式" class="headerlink" title="CAS 非阻塞方式"></a>CAS 非阻塞方式</h3><p>CAS（Compare and Swap）实现<strong>无锁</strong>方式，利用<strong>失败重试</strong>的方式，使用了底层硬件的原子性操作，保证共享变量的线程安全。CAS 操作包括三个参数：内存地址（或变量值）、期望值和新值。CAS 的执行过程如下：</p>
<ol>
<li><strong>读取内存地址中的当前值。</strong></li>
<li><strong>比较当前值与期望值是否相等。</strong></li>
<li><strong>如果相等，则将内存地址中的值更新为新值。如果不相等，则说明其他线程已经修改了该值，CAS 操作失败。</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AccountSafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line">    <span class="comment">//省略其他代码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">            <span class="comment">//comapreAndSet 做检查，set前，先比较prev 与当前值是否一致</span></span><br><span class="line">            <span class="comment">//一致，修改成功，返回 true</span></span><br><span class="line">            <span class="comment">//不一致，失败重试</span></span><br><span class="line">            <span class="keyword">if</span>(balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106192113983.png" alt="image-20221106192113983" style="zoom:67%;">

<blockquote>
<p>CAS底层是 lock cmpxchg 指令（X86架构），在单核 CPU 和多核 CPU 下保障【比较-交换】操作的原子性</p>
<ul>
<li>多核状态下，某个核执行到带 lock 的指令，CPU 会让总线锁住，直至指令执行完毕。</li>
</ul>
</blockquote>
<p><strong>volatile</strong></p>
<p>volatile 修饰共享变量，使得线程避免从工作内存中查找变量的值，而是必须到主存中获取，保证一个线程对 volatile 变量的修改，对另一个线程可见</p>
<p>&#x3D;&#x3D;CAS 必须借助 volatile 才能读取到共享变量的新值并实现【比较并交换】效果&#x3D;&#x3D; </p>
<p><strong>CAS 特点总结</strong></p>
<ul>
<li><p>无锁效率高</p>
<ul>
<li>无锁状态下，即使重试失败，线程也在高速运行，不会发生上下文切换，节省了保存现场、恢复现场等时间。而 synchronized 会让线程没有获得锁的时候发生阻塞</li>
<li>注意：适用于线程数少，CPU 核心数多的情况</li>
</ul>
</li>
<li><p>基于乐观锁思想</p>
<ul>
<li>最乐观的估计，认为自己能获得锁，采用失败重试的方法</li>
</ul>
</li>
</ul>
<h3 id="CAS-相关-API"><a href="#CAS-相关-API" class="headerlink" title="CAS 相关 API"></a>CAS 相关 API</h3><p><strong>原子整数</strong></p>
<ul>
<li>AtomicBoolean</li>
<li>AtomicLong</li>
<li>AtomicInteger</li>
</ul>
<p><strong>原子引用</strong></p>
<ul>
<li>AtomicReference</li>
<li>AtomicMarkableReference</li>
<li>AtomicStampedReference</li>
</ul>
<p><strong>原子数组</strong></p>
<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
<p><strong>字段更新器</strong></p>
<ul>
<li><p>AtomicIntegerFieldUpdater</p>
</li>
<li><p>AtomicLongFieldUpdater</p>
</li>
<li><p>AtomicReferenceFieldUpdater</p>
<blockquote>
<p>注意：</p>
<p>字段更新器只能对 volatile 修饰的字段使用！</p>
</blockquote>
</li>
</ul>
<p><strong>原子累加器</strong></p>
<ul>
<li><p>LongAdder 比 AtomicLong 高效</p>
<blockquote>
<p>LongAdder 在有竞争的时候，设置多个累加单元，不同的线程在不同的累加单元上工作，最后再将结果汇总。这样线程们在累加时操作不同的 cell 变量，减少 CAS 失败重试，提高性能</p>
</blockquote>
</li>
<li><p>LongAdder 类的几个关键域</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加单元数组，懒惰初始化</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Cell[] cells;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基础值，若没有竞争，则用 cas 累加这个域</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">long</span> base;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 cells 创建或扩容时，设置为 1 ，表示加锁</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> cellsBusy;</span><br></pre></td></tr></table></figure>

<ul>
<li>Cell 累加单元</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//防止缓存行伪共享</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Cell</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> value;</span><br><span class="line">    Cell(<span class="type">long</span> x) &#123; value = x; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cas 方式累加</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">cas</span><span class="params">(<span class="type">long</span> prev, <span class="type">long</span> next)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="built_in">this</span>, valueOffset, prev, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//other codes</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 CPU 与内存的速度差异很大，所以设置缓存预读数据来提高效率。缓存以缓存行（64 byte）为单位。</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106202418512.png" alt="image-20221106202418512" style="zoom:67%;">

<p>缓存的加入会造成数据副本的产生，同一份数据存储在不同核心的缓存行中。为保证数据一致性，如果某个 CPU 核心更改数据，其他 CPU 核心对应的缓存行必须失效</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106203849311.png" alt="image-20221106203849311" style="zoom:67%;">

<p>因为 Cell 是数组形式，内存中连续存放。同一数据存储在不同 CPU 的缓存行里，任何线程对数据的修改都会造成对方缓存行的失效</p>
<p>@sun.misc.Contended 原理是使用注解的对象或字段，前后各增加 128 byte 的 padding ，让 CPU 将对象预读至缓存时占用不同的缓存行，这样，不会造成对方缓存行的失效</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106204350338.png" alt="image-20221106204350338" style="zoom:67%;">

<p><strong>LongAdder 累加执行流程</strong></p>
<ol>
<li>进入 add</li>
</ol>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106210238709.png" alt="image-20221106210238709" style="zoom:80%;">

<ol start="2">
<li>进入 longAccumulate</li>
</ol>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106210420237.png" alt="image-20221106210420237" style="zoom:80%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106235240490.png" alt="image-20221106235240490" style="zoom:80%;">

<p>​	每个线程刚进入 longAccumulate 时，会尝试对应一个 cell 对象（找到一个坑位）</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221106235334469.png" alt="image-20221106235334469" style="zoom:80%;">



<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>我和gpt的对话 ：<a target="_blank" rel="noopener" href="https://chatgpt.com/share/67774578-017c-800a-85c9-d5bde34d4c7f">https://chatgpt.com/share/67774578-017c-800a-85c9-d5bde34d4c7f</a></p>
<h2 id="线程池（重要）"><a href="#线程池（重要）" class="headerlink" title="&#x3D;&#x3D;线程池（重要）&#x3D;&#x3D;"></a>&#x3D;&#x3D;线程池（重要）&#x3D;&#x3D;</h2><h2 id="ThreadPoolExecuter"><a href="#ThreadPoolExecuter" class="headerlink" title="ThreadPoolExecuter"></a>ThreadPoolExecuter</h2><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107011107666.png" style="zoom:60%;">

<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a><strong>构造方法</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,        //核心线程数              </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,		//最大线程数	</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,		//救急线程存活时间</span></span><br><span class="line"><span class="params">                          TimeUnit unit,			//救急线程时间单位</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,   //阻塞队列</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,		//线程工厂-为线程起个好名字</span></span><br><span class="line"><span class="params">                          RejectionExecutionHandler handler)</span>;  <span class="comment">//拒绝策略</span></span><br></pre></td></tr></table></figure>

<p><strong>重要参数：</strong></p>
<ol>
<li><strong>核心线程数（Core Pool Size）：</strong><ul>
<li>核心线程数是线程池中保持活动状态的最小线程数。即使线程是空闲的，核心线程也不会被回收。这样可以减少线程的创建和销毁开销，提高性能。</li>
</ul>
</li>
<li><strong>最大线程数（Maximum Pool Size）：</strong><ul>
<li>最大线程数是线程池中允许存在的最大线程数目。当核心线程都被占用，而任务队列也满了的情况下，线程池会创建新的线程，直到达到最大线程数。超过最大线程数的任务将被拒绝执行。</li>
</ul>
</li>
<li><strong>任务队列（BlockingQueue）：</strong><ul>
<li>任务队列用于存储还未执行的任务。当线程池的线程数已经达到核心线程数，并且所有核心线程都在执行任务时，新的任务会被放入任务队列中等待执行。任务队列可以是无界队列或有界队列。</li>
</ul>
</li>
<li><strong>线程存活时间（Keep Alive Time）：</strong><ul>
<li>线程存活时间是非核心线程在空闲状态下的最长存活时间。当线程池中的线程数大于核心线程数，并且有些线程处于空闲状态时，超过存活时间的线程将被终止，以减少资源消耗。</li>
</ul>
</li>
<li><strong>拒绝策略（Rejected Execution Handler）：</strong><ul>
<li>当任务无法被线程池执行时采取的策略。常见的拒绝策略包括：<ul>
<li><code>AbortPolicy</code>：默认策略，直接抛出 <code>RejectedExecutionException</code>。</li>
<li><code>CallerRunsPolicy</code>：由提交任务的线程执行该任务。</li>
<li><code>DiscardPolicy</code>：直接丢弃无法处理的任务。</li>
<li><code>DiscardOldestPolicy</code>：丢弃任务队列中最老的任务，然后重新尝试执行新任务。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>&#x3D;&#x3D;**核心线程 **和 <strong>救急线程</strong> 的区别&#x3D;&#x3D;<ul>
<li>创造条件不同：<ul>
<li>有新任务需要执行，只要核心线程数没有达到 corePoolSize，就会创建</li>
<li>救急线程需要在<strong>阻塞队列已满</strong>，并且 <code>maximumPoolSize - corePoolSize</code> 还有容量的情况下，有了新任务才会创建救急线程</li>
</ul>
</li>
<li>生存时间不同：<ul>
<li>核心线程<strong>一旦创建就一直存活</strong>，除非任务执行异常，任务和线程可能”同归于尽“</li>
<li>救急线程不会一直存活，空闲状态超过 <code>keepAliveTime</code> 就会灭亡</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Executors 是一个工厂类，提供了一些静态方法用于创建不同类型的线程池。</span></span><br><span class="line">        <span class="comment">//这里是创建了固定大小的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskNumber</span> <span class="operator">=</span> i;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Task &quot;</span> + taskNumber + <span class="string">&quot; executed by thread: &quot;</span> + Thread.currentThread().getName());	</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这个例子创建了一个固定大小为3的线程池，提交了5个任务。每个任务都会在一个线程中执行。最后，通过调用shutdown方法关闭线程池。</span></span><br></pre></td></tr></table></figure>



<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a><strong>工作流程</strong></h3><p><strong>（1）</strong>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会<strong>创建一个新线程来执行任务</strong></p>
<p><strong>（2）</strong>当线程数达到 <code>corePoolSize</code> 并没有空闲线程，这时再加入任务，<strong>新的任务会加入 <code>workQueue</code> 队列排队</strong>，直至有空闲线程</p>
<p><strong>（3）</strong>如果队列选择有界队列，当任务数超过队列大小，会<strong>创建 <code>maximumPoolSize - corePoolSize</code> 数目的救急线程</strong></p>
<p><strong>（4）</strong>如果线程达到 <code>maximumPoolSize</code> 仍然有新任务加入，会<strong>执行拒绝策略</strong>。</p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107134143690.png" style="zoom:80%;">

<p><strong>（5）</strong>高峰期后，救急线程如果空闲，等待一段时间后会自动结束（时间由 <code>keepAliveTime</code> 控制）</p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a><strong>工厂方法</strong></h3><p><code>Executors</code> 是一个工厂类，提供了一些静态方法用于创建不同类型的线程池。</p>
<h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a><strong>newFixedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThread)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThread, nThread,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MillSECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;特点：&#x3D;&#x3D;</p>
<ul>
<li>核心线程数 &#x3D; 最大线程数（<strong>无救急线程</strong>）</li>
<li>阻塞队列<strong>无界</strong></li>
</ul>
<p>&#x3D;&#x3D;应用场景：&#x3D;&#x3D;</p>
<ul>
<li>任务量已知，相对耗时</li>
</ul>
<h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a><strong>newCachedThreadPool</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;特点：&#x3D;&#x3D;</p>
<ul>
<li>没有核心线程，<strong>全是救急线程</strong>，救急线程可以<strong>无限创建</strong>，空闲生存时间为<strong>60 秒</strong></li>
<li><code>SynchronousQueue</code> 队列特点，没有容量，没有线程来取放不进去</li>
</ul>
<p>应用场景：</p>
<ul>
<li>任务数密集，执行时间较短</li>
</ul>
<h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a><strong>newSingleThreadExecutor</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">        						<span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用场景：</p>
<ul>
<li>希望多个线程排队执行，<strong>线程数固定为 1</strong>，任务数多于 1时，会放入无界队列。任务执行完毕，这唯一的线程也不会释放</li>
</ul>
<p>区别：</p>
<ul>
<li>自己创建一个单线程串行执行任务，如果任务执行失败而终止，则没有任何补救措施。而线程池会新建一个线程，保障线程池的正常工作</li>
<li><code>Executors.newSingleThreadExecutor()</code>线程数始终为 1，不能修改<ul>
<li><code>FinalizableDelegatedExecutorService</code> 应用的是装饰器模式，只暴露了 <code>ExecutorService</code> 接口，因此不能调用 <code>ThreadPoolExecutor</code> 中的特有方法</li>
</ul>
</li>
</ul>
<h3 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a><strong>提交任务</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行无返回值任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行有返回值任务，用 Future 获得结果</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行一个任务集合</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    	<span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? entends Callable&lt;T&gt;&gt; tasks, </span></span><br><span class="line"><span class="params">                             	<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    	<span class="keyword">throws</span> InterruptedException;</span><br><span class="line"><span class="comment">//执行一个任务集合，返回最先执行完成的任务，并取消其他所有任务</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    	<span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    	<span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure>

<h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a><strong>关闭线程池</strong></h3><p><strong>shutdown</strong></p>
<ul>
<li>线程池状态变成 SHUTODOWM<ul>
<li>不会接受新任务</li>
<li>已提交任务会执行完</li>
<li>不会阻塞调用线程的执行</li>
</ul>
</li>
</ul>
<p><strong>shutdownNow</strong></p>
<ul>
<li>线程池状态变为 STOP<ul>
<li>不会接受新任务</li>
<li>队列中的任务也停止</li>
<li>用 interrupt 的方法中断正在执行的任务</li>
</ul>
</li>
</ul>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h3><ul>
<li>降低资源消耗<ul>
<li><strong>重复利用</strong>已经创建的线程，避免线程反复创建、销毁带来的损耗</li>
</ul>
</li>
<li>提高响应速度<ul>
<li>任务到达时，不需要等待线程创建就能立即执行</li>
</ul>
</li>
<li>提高线程可管理性<ul>
<li>线程控制在一定数量，避免线程过多不合理消耗资源，甚至OOM使用线程池统一分配、调优、监控</li>
</ul>
</li>
<li>封装过程<ul>
<li>Executor 框架把<strong>任务的提交和执行进行解耦</strong>，只要定义好任务，提交到线程池，不用关心任务是如何执行，被哪个线程执行，什么时候执行</li>
</ul>
</li>
</ul>
<h2 id="AQS-原理（重要）"><a href="#AQS-原理（重要）" class="headerlink" title="&#x3D;&#x3D;AQS 原理（重要）&#x3D;&#x3D;"></a>&#x3D;&#x3D;AQS 原理（重要）&#x3D;&#x3D;</h2><p>AQS 是 <strong>JUC 包中非常核心的抽象类</strong>，全程 <code>AbstractQueuedSynchronizer</code>，它为多线程访问共享资源提供了一个队列同步器，是<strong>阻塞式锁和相关同步器工具的框架</strong>。</p>
<p>在 JUC 包下，很多组件都依赖 AQS 实现的，如 Lock、Semaphore、CountDownLatch 等等。AQS 提供了一个通用的框架，使得<strong>开发者可以相对轻松地构建自定义的同步工具，比如锁、信号量等</strong>。AQS 提供了一些核心的方法和机制，如获取锁（<code>acquire</code>）、释放锁（<code>release</code>）、条件等待（<code>await</code>、<code>signal</code>）等。通过在具体的同步工具类中继承 AQS 并实现这些方法，开发者可以很方便地定义自己的同步规则。</p>
<h3 id="三个核心组成部分"><a href="#三个核心组成部分" class="headerlink" title="三个核心组成部分"></a><strong>三个核心组成部分</strong></h3><ul>
<li><code>volatile</code> 修饰的 <strong><code>state</code> 变量，作为锁的标志</strong>。<ul>
<li><code>getState</code> - 获取 state 状态</li>
<li><code>setState</code> - 设置 state 状态</li>
<li><code>compareAndSetState</code> - cas 设置 state 状态，失败重试到一定次数需要进阻塞队列，因为 AQS 实现的是阻塞锁</li>
</ul>
</li>
<li>双向链表维护的 FIFO <strong>线程等待队列</strong>，类似于 Monitor 的 EntryList （区别是Monitor是 C++ 实现）</li>
<li><strong>条件变量</strong>实现等待、唤醒线程，支持多个条件变量，类似 Monitor 的WaitSet（区别是 Monitor 的 WaitSet 只有一个）</li>
</ul>
<h3 id="资源共享方式"><a href="#资源共享方式" class="headerlink" title="资源共享方式"></a><strong>资源共享方式</strong></h3><ul>
<li>独占模式<ul>
<li>同一时刻只有一个线程能获取竞态资源，如 <code>ReentrantLock</code></li>
</ul>
</li>
<li>共享模式<ul>
<li>同一时刻，多个线程可以同时获得竞态资源，如 <code>CountDownLatch</code>、<code>Semaphore</code></li>
</ul>
</li>
</ul>
<h3 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a><strong>自定义锁</strong></h3><ul>
<li><p>集成 AQS，自定义多线程竞争的实现逻辑。子类需要定义如何维护 state 状态，控制如何获取锁和释放锁</p>
<blockquote>
<p>子类要实现的方法：</p>
<p><code>tryAcquire</code> <code>tryRelease</code> <code>tryAcquireShared</code> <code>tryReleaseShared</code> <code>isHeldExclusively</code></p>
</blockquote>
</li>
<li><p>获取锁</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if try acquire lock fail</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">    <span class="comment">// thread into queue,be blocked by park</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>释放锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if try release lock success</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// awake blocking queue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107191313559.png" alt="image-20221107191313559" style="zoom:67%;">

<h4 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a><strong>加锁流程</strong></h4><ul>
<li>没有竞争时</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107191501964.png" alt="image-20221107191501964" style="zoom:67%;">

<ul>
<li>第一个竞争出现时，Thread-1 执行了<ul>
<li>CAS 尝试把 state 由 0 改成 1，结果失败</li>
<li>进入 tryAcquire 逻辑，这时 state 还是 1，依然失败</li>
<li>进入 addWaiter 逻辑，构造 Node 队列</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107191917280.png" alt="image-20221107191917280" style="zoom:67%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107191932742.png" alt="image-20221107191932742" style="zoom:67%;">

<ul>
<li>当前线程进入 acquireQueued 逻辑<ul>
<li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li>
<li>如果自己是紧邻着 head，那么再次 tryAcquire 尝试获取锁，这时 state 仍为 1，失败</li>
<li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，返回 false</li>
<li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，这时 state 仍为 1，失败</li>
<li>再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回 true</li>
<li>进入 parkAndCheckInterrupt</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107192255935.png" alt="image-20221107192255935" style="zoom:67%;">

<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107192310701.png" alt="image-20221107192310701" style="zoom:67%;">

<h4 id="解锁过程"><a href="#解锁过程" class="headerlink" title="解锁过程"></a><strong>解锁过程</strong></h4><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107192423295.png" alt="image-20221107192423295" style="zoom:67%;">

<ul>
<li>Thread-0 释放锁，进入 tryRelease 流程，如果成功<ul>
<li>设置 exclusiveOwnerThread 为 null</li>
<li>state &#x3D; 0 （注意这里顺序不能改变，因为 setState 逻辑中有volatile，写屏障保证 exclusiveOwnerThread 的修改也具有可见性）</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107192748256.png" alt="image-20221107192748256" style="zoom:67%;">

<ul>
<li>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程</li>
<li>找到队列中离 head 最近的一个 Node，unpark 恢复其运行</li>
<li>回到 Thread-1 的 acquireQueued 流程</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107192906130.png" alt="image-20221107192906130" style="zoom:67%;">

<ul>
<li><p>如果加锁成功</p>
<ul>
<li>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</li>
<li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li>
<li>原本的 head 因为从链表断开，而可被垃圾回收</li>
</ul>
</li>
<li><p>如果加锁不成功</p>
<ul>
<li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107193047838.png" alt="image-20221107193047838" style="zoom:67%;">

<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>当读操作远远多于写操作时，使用【读写锁】让【读读并发】，提高性能。读-写、写-写 依然互斥</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//do something    </span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong></p>
<ul>
<li>读锁不支持条件变量</li>
<li>重入时升级不支持：一个线程在持有读锁的情况下去获取写锁，会导致锁的永久等待</li>
<li>重入时降级支持：一个线程持有写锁的情况下可以获取读锁</li>
</ul>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><strong>基本使用</strong></p>
<p>信号量，限制能同时访问共享资源的线程上限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">//获取许可</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                semaphore.acquire();  <span class="comment">//没有获取许可的线程在此阻塞</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//code need to restrict number of threads-concurrent</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//释放许可</span></span><br><span class="line">                samephore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>原理</strong></p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107194337764.png" alt="image-20221107194337764" style="zoom:67%;">

<ul>
<li>三个线程 cas 竞争成功，两个线程 cas 竞争失败，进入 AQS 队列 park 阻塞</li>
</ul>
<p><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107194620961.png" alt="image-20221107194620961"></p>
<ul>
<li>一个线程 4 释放了自己的 permits， state + 1</li>
</ul>
<p><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107194728979.png" alt="image-20221107194728979"></p>
<ul>
<li>另一个阻塞线程 0 竞争成功，设置自己为 head 节点，断开原来的 head 节点， unpark 接下来的线程 3 节点。但是由于没有许可，所以线程 3 在尝试不成功后进入 park 阻塞</li>
</ul>
<p><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221107195112371.png" alt="image-20221107195112371"></p>
<p><strong>优点</strong></p>
<ul>
<li>与通过 控制线程数来控制并发度 的方法相比，通过 Semaphore 控制并发数可以控制的更加细粒度，因为真正需要有并发数限制的代码只需要放在 acquire 和 release 之间，其他仍可以由更多线程执行</li>
</ul>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>用来进行线程同步协作，等待所有线程完成倒计时。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> staric <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedExecption &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            latch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>为什么不用 join，也能达到当前线程等待其他线程运行结束后在开始运行。</p>
<p>原因：Thread.join  如果用线程池的话，一个线程可能一直不会结束，就一直等待。</p>
</blockquote>
<p>应用：同步等待多个线程调用结束，可以用 Future 接收线程调用结果</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏，与 CountDownLatch 类似，同样用于线程协作。多个线程在屏障前等待，直到所有线程都到达这个屏障时，再一起执行后面的动作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, () -&gt; &#123;</span><br><span class="line">    <span class="comment">//do something after all threads break the barrier</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do sothing</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await();  <span class="comment">//线程数不足，阻塞等待</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="comment">//come code) &#123;</span></span><br><span class="line">        <span class="comment">// othercode</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="comment">//do sothing</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await();  <span class="comment">//足够，开始运行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span>(<span class="comment">//come code) &#123;</span></span><br><span class="line">        <span class="comment">// othercode</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong> CyclicBarrier 和 CountDownLatch 区别在于</p>
<ul>
<li><p>CyclicBarrier 线程遇到 await 都会阻塞，然后一起返回；CountDownLatch 遇到 CountDown 不会阻塞，遇到 await 会阻塞</p>
</li>
<li><p>CyclicBarrier 可重用，类似【人满发车】；CountDownLatch 计数一旦指定，不可修改为指定值，不能重用,用完了要重新初始化一个</p>
</li>
</ul>
</blockquote>
<h1 id="线程安全集合类"><a href="#线程安全集合类" class="headerlink" title="线程安全集合类"></a>线程安全集合类</h1><h2 id="补充：Java-集合框架"><a href="#补充：Java-集合框架" class="headerlink" title="补充：Java 集合框架"></a><strong>补充：Java 集合框架</strong></h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/java/java-collections.html">https://www.runoob.com/java/java-collections.html</a></p>
<p>Java 集合类是对于数据结构的实现，所有类位于 java.util 包下，由两种接口派生出来，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键&#x2F;值对映射。</p>
<ul>
<li><strong>Collection</strong><ul>
<li>List<ul>
<li>ArrayList</li>
<li>LinkedList</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet</li>
<li>TreeSet</li>
<li>LinkedHashSet</li>
</ul>
</li>
<li>Queue</li>
</ul>
</li>
<li><strong>Map</strong><ul>
<li><ul>
<li>HashMap</li>
<li>TreeMap</li>
</ul>
</li>
</ul>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/java-coll-2020-11-16.png" style="zoom: 67%;"> 

<p><strong>线程安全集合类</strong></p>
<p><img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108155306063.png" alt="image-20221108155306063"></p>
<p>线程安全集合类分类</p>
<ul>
<li>遗留类</li>
<li>Collections 装饰类</li>
<li>JUC 类<ul>
<li>Blocking 大部分实现基于锁，阻塞方式</li>
<li>CopyOnWrite 类容器修改开销大</li>
<li>Concurrent 类容器<ul>
<li>内部多使用 cas 优化，吞吐量高</li>
<li>弱一致性<ul>
<li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍 历，这时内容是旧的</li>
<li>求大小弱一致性，size 操作未必是 100% 准确</li>
<li>读取弱一致性</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>遍历时如果发生修改，对于非安全容器，使用 fail-fast 机制让遍历立即失败，抛出 ConcurrentModificationException</p>
</blockquote>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>看这个：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/350099474%EF%BC%88%E5%A5%BD%E6%96%87%E7%AB%A0%EF%BC%89">https://zhuanlan.zhihu.com/p/350099474（好文章）</a></p>
<h3 id="补充：普通-HashMap"><a href="#补充：普通-HashMap" class="headerlink" title="补充：普通 HashMap"></a><strong>补充：普通 HashMap</strong></h3><blockquote>
<p> hash code</p>
</blockquote>
<blockquote>
<ul>
<li>hash 函数实现一种算法，通过该算法得到一个 hashcode，并放置在 hash table 中的对应位置</li>
<li>每个对象都有 hashcode，hashcode 代表对象在hash table 中的位置</li>
<li>hashcode 的存在主要为了查找的快捷性，先通过 hashcode 比较，再用 equals 方法比较两个对象是否相等</li>
<li>如果两个对象 equals 相等，那么这两个对象的 HashCode 一定相同</li>
<li>如果两个对象的 HashCode 相同，不代表两个对象就相同，只能说明两个对象在散列存储结构中存在了同一个桶下标上</li>
<li>equals 方法重写，建议 hashcode 也一起重写。这是为了保证两个 equals 相等的对象 hashcode也相等</li>
</ul>
</blockquote>
<ul>
<li><p>HashMap</p>
<ul>
<li><p>HashMap 是最常用的集合类框架，数据结构为 数组 + 链表或红黑树</p>
</li>
<li><pre><code class="java">static class Node&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123;
    final int hash;
    final K key;
    V value;
    Node&lt;K, V&gt; next;
&#125;
//Node 是内部类
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 存储元素过程</span><br><span class="line"></span><br><span class="line">    - 计算键的 hashcode ，定位到桶下标</span><br><span class="line">    - 如果没有元素，直接插入</span><br><span class="line">    - 如果有元素，判断是否 equal </span><br><span class="line"></span><br><span class="line">  - 参数</span><br><span class="line"></span><br><span class="line">    - 初始容量大小：默认16</span><br><span class="line">    - 加载因子：默认0.75f。超过会扩容</span><br><span class="line"></span><br><span class="line">  - 版本区别</span><br><span class="line"></span><br><span class="line">    - jdk1.7 位桶 + 链表</span><br><span class="line">    - jdk1.8 位桶 + 链表/红黑树：链表长度大于8且节点数组长度大于64的时候，就把链表下所有的节点转为红黑树，否则继续采用扩容策略</span><br><span class="line"></span><br><span class="line">- 线程安全问题——扩容死链</span><br><span class="line"></span><br><span class="line">  - jdk1.7 多线程同时对一个 HashMap 扩容的过程中，由于要将原表中的结点移植到新表的桶下标中，在形成链表的过程中可能有死链的情况</span><br><span class="line">  - jdk 1.8 调整扩容算法，新链表的形成采用尾插法，不会造成死链，但可能出现丢失数据等线程安全问题</span><br><span class="line"></span><br><span class="line">### **线程安全的 HashMap**</span><br><span class="line"></span><br><span class="line">#### **jdk 7**</span><br><span class="line"></span><br><span class="line">由许多（2 的 N 次方个） Segment 组合而成一个 segments 数组，每个 Segment 可看作一个 HashMap 对象，包含一个 HashEntry 数组，数组中每个 HashEntry 既是一个键值对，又是一个链表的头节点</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java并发编程/image-20221111180122508.png&quot; alt=&quot;image-20221111180122508&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java并发编程/image-20221111180138608.png&quot; alt=&quot;image-20221111180138608&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">put 操作流程</span><br><span class="line"></span><br><span class="line">- 通过 key 定位到 Segment，在对应的 Segment 中进行具体的 put</span><br><span class="line">- 尝试获得锁，获取失败则执行 `scanAndLockForPut()` 自旋获得锁，重试次数超过 `MAX_SCAN_RETRIES` 则改为阻塞锁获取</span><br><span class="line">- 加锁后遍历该 HashEntry，为空需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容，不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value（默认`onlyIfAbsent`为false）</span><br><span class="line">- 释放锁</span><br><span class="line"></span><br><span class="line">#### **jdk8**</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;Java并发编程/image-20221111181520062.png&quot; alt=&quot;image-20221111181520062&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">put 操作流程</span><br><span class="line"></span><br><span class="line">- 根据 key 计算出 hashcode，然后开始遍历 table</span><br><span class="line">- 判断是否需要初始化</span><br><span class="line">- f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功</span><br><span class="line">- 如果当前位置的 hashcode == MOVED == -1,则需要进行扩容</span><br><span class="line">- 如果都不满足，则利用 synchronized 锁写入数据</span><br><span class="line">- 如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树</span><br><span class="line"></span><br><span class="line">## LinkedBlockingQueue</span><br><span class="line"></span><br><span class="line">**入队、出队流程**</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;</span><br><span class="line">    	implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123;</span><br><span class="line">    static class Node&lt;E&gt; &#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        /**</span><br><span class="line">         * 1.next 是真正的后继节点</span><br><span class="line">         * 2.next 是自己，表示出队</span><br><span class="line">         * 3.next 是null，没有后继节点</span><br><span class="line">         */</span><br><span class="line">        Node(E x) &#123;item = x;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
<li><p>初始化链表 <code>last = head = new Node&lt;E&gt;(null);</code> Dummy 节点占位，item 为 null</p>
</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108160059498.png" alt="image-20221108160059498" style="zoom:50%;">

<ul>
<li>第一个节点入队 <code>last = last.next = node; </code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108160246755.png" alt="image-20221108160246755" style="zoom:80%;">

<ul>
<li>又一个节点入队 <code>last = last.next = node;</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108160354474.png" alt="image-20221108160354474" style="zoom:80%;">

<ul>
<li>出队</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; h = head;</span><br><span class="line">Node&lt;E&gt; first = h.next;</span><br><span class="line">h.next = h;  <span class="comment">//will GC</span></span><br><span class="line">head = first;</span><br><span class="line"><span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">first.item = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br></pre></td></tr></table></figure>

<ul>
<li>找到 Dummy <code>h = head</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108160914144.png" alt="image-20221108160914144" style="zoom:80%;">

<ul>
<li>找到第一个元素 <code>first = h.next</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108160952192.png" alt="image-20221108160952192" style="zoom:80%;">

<ul>
<li>让 Dummy 出队 <code>h.next = h</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108161040997.png" alt="image-20221108161040997" style="zoom:80%;">

<ul>
<li>第一个元素变成 Dummy <code>head = first</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108161145230.png" alt="image-20221108161145230" style="zoom:80%;">

<ul>
<li>获取出队元素值<code>E x = first.item; first.item = null; return x ;</code></li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108161206826.png" alt="image-20221108161206826" style="zoom:80%;">

<p><strong>加锁分析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于 put（阻塞）offer（非阻塞）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于 take（阻塞）poll（非阻塞）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>两把锁分析</p>
<ul>
<li>同一时刻，允许两个线程（生产者、消费者）同时执行。生产者 - 生产者，消费者 - 消费者串行</li>
</ul>
</li>
<li><p>Dummy 作用</p>
<ul>
<li>保证队列中一直有元素，不会因为两个线程同时初始化队列产生线程安全问题</li>
<li>保证两把锁锁住不同对象</li>
</ul>
</li>
<li><p>线程安全分析</p>
<ul>
<li><p>节点数 &gt;&#x3D; 2 （包括 Dummy）</p>
<blockquote>
<p>putLock 保证 last 节点 线程安全， takeLock 保证 head 节点 线程安全。两把锁保证出队、入队无竞争</p>
</blockquote>
</li>
<li><p>节点数 &lt; 2 （只有 Dummy）</p>
<blockquote>
<p>take 线程会被 notEmpty 条件阻塞</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>源码分析</strong></p>
<p>put 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 构造新加入的节点，懒惰初始化</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 构造锁对象</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putlock;</span><br><span class="line">    <span class="comment">// count 维护元素计数</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 上锁</span></span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 队列满了，就先等待</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capcity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有空位，入队，计数加一</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="comment">// 还有空位？ 叫醒别的 put 线程</span></span><br><span class="line">        <span class="keyword">if</span>(c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果队列中只有一个元素，叫醒 take 线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 这里调用 notEmpty.signal() 而非 notEmpty.signalAll() 是为了减小竞争</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>take 操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">			notEmpty.await();</span><br><span class="line"> 		&#125;</span><br><span class="line"> 		x = dequeue();</span><br><span class="line"> 		c = count.getAndDecrement();</span><br><span class="line"> 		<span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line"> 			notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//other code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点：</p>
<p>都有 put 唤醒 put，take 唤醒 take，以及相互唤醒的操作，为了避免信号不足</p>
</blockquote>
<p><strong>性能比较</strong></p>
<table>
<thead>
<tr>
<th>LinkedBlockingQueue</th>
<th>ArrayBlockingQueue</th>
</tr>
</thead>
<tbody><tr>
<td>支持有界（capacity）</td>
<td>强制有界</td>
</tr>
<tr>
<td>链表</td>
<td>数组</td>
</tr>
<tr>
<td>懒惰初始化</td>
<td>提前初始化 Node 数组</td>
</tr>
<tr>
<td>每次入队生成新的 Node</td>
<td>Node 提前创建好</td>
</tr>
<tr>
<td>两把锁，锁住头&#x2F;尾</td>
<td>一把锁</td>
</tr>
</tbody></table>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p><strong>特点</strong></p>
<ul>
<li><p>类似于 <code>LinkedBlockingQueue</code></p>
<ul>
<li>有两把锁，锁住队列头和尾，同一时刻允许生产者和消费者两个线程同时执行</li>
<li>有 Dummy 节点，保证两把锁锁住不同对象，保证线程安全</li>
</ul>
</li>
<li><p>不同于<code>LinkedBlockingQueue</code></p>
<ul>
<li>&#x3D;&#x3D;锁用 CAS 实现&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<p><strong>应用</strong></p>
<ul>
<li>Tomcat 的 Connector 结构中，Acceptor 生产者向 Poller 消费者传递事件消息时，采用了<code>ConcurrentLinkedQueue </code>将<code>SocketChannel</code>给 Poller 使用</li>
</ul>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221111163950793.png" alt="image-20221111163950793" style="zoom:70%;">



<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p><code>CopyOnWriteArraySet</code> 是它的马甲，即 其内部方法都调用了 <code>CopyOnWriteArrayList</code> 的方法。 Set 保证元素无重复的方法是 <code>CopyOnWriteArraySet.add(E e) </code>调用了 <code>CopyOnWriteArrayList.addIfAbsent(E e)</code></p>
<p>底层实现采用&#x3D;&#x3D;写入时拷贝&#x3D;&#x3D;的思想，增删改操作会将底层数组拷贝一份，更改操作在新数组上执行，实现&#x3D;&#x3D;读读并发&#x3D;&#x3D;、&#x3D;&#x3D;读写并发&#x3D;&#x3D;、&#x3D;&#x3D;写写互斥&#x3D;&#x3D;</p>
<p>新增操作加锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123; </span><br><span class="line">        <span class="comment">//获取旧数组</span></span><br><span class="line">        Object[] es = getArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> es.length;</span><br><span class="line">        <span class="comment">//拷贝新数组（比较耗时，但不影响其他读线程）</span></span><br><span class="line">        es = Array.copyOf(es, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//添加新元素</span></span><br><span class="line">        es[len] = e;</span><br><span class="line">        <span class="comment">//替换旧数组</span></span><br><span class="line">        setArray(es);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：源码版本为 Java 11，在 Java 1.8 中 使用的是可重入锁</p>
</blockquote>
<p>其他操作未加锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer &lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (Object x : getArray()) &#123;</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E)x;</span><br><span class="line">        action.accept()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景：</p>
<p>&#x3D;&#x3D;读多写少&#x3D;&#x3D;，写操作需要拷贝数组，性能消耗更大，但能保证线程安全；读操作可以并发，更为高效</p>
<p><strong>get 弱一致性</strong></p>
<img src="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20221108170550392.png" alt="image-20221108170550392" style="zoom:70%;">

<table>
<thead>
<tr>
<th>时间点</th>
<th>操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Thread-0 getArray</td>
</tr>
<tr>
<td>2</td>
<td>Thread-1 gerArray</td>
</tr>
<tr>
<td>3</td>
<td>Thread-1 setArray(arrayCopy)</td>
</tr>
<tr>
<td>4</td>
<td>Thread-0 array[index]  &#x2F;&#x2F;读取的是未经修改的旧数组</td>
</tr>
</tbody></table>
<p><strong>迭代器弱一致性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">Iterator&lt;Integer&gt; iter = list.iterator();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">    System.out.println(iter.next());  <span class="comment">//迭代器输出的是旧数组的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：弱一致性未必不好</p>
<ul>
<li>数据库 MVCC 是弱一致性的体现</li>
<li>高并发和一致性是矛盾的，需要权衡</li>
</ul>
</blockquote>
<h2 id="面试编程题"><a href="#面试编程题" class="headerlink" title="面试编程题"></a>面试编程题</h2><p>&#x3D;&#x3D;<strong>面试编程题：两个线程交替打印 A1B2C3……</strong>&#x3D;&#x3D;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlternatePrint</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 用于线程间通信的锁对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">letterThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;Z&#x27;</span>; c++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.print(c); <span class="comment">// 打印字母</span></span><br><span class="line">                    lock.notify(); <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait(); <span class="comment">// 当前线程进入等待状态</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                lock.notify(); <span class="comment">// 确保另一个线程不会永久等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">numberThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.print(i); <span class="comment">// 打印数字</span></span><br><span class="line">                    lock.notify(); <span class="comment">// 唤醒另一个线程</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        lock.wait(); <span class="comment">// 当前线程进入等待状态</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                lock.notify(); <span class="comment">// 确保另一个线程不会永久等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动两个线程</span></span><br><span class="line">        letterThread.start();</span><br><span class="line">        numberThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;<strong>面试编程题：写一个死锁的程序</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>面试编程题：写一个生产者、消费者的程序</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>面试编程题：写一个没有 volatile 导致指令重排序使得结果不一致的程序</strong>&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;<strong>面试编程题：写一个简单的线程池</strong>&#x3D;&#x3D;</p>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 王才雨
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
