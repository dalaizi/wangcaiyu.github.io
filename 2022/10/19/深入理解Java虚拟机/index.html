<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>深入理解Java虚拟机 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="深入理解Java虚拟机 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="设计模式设计原则（1）封装变化把会变化的部分取出并封装起来，好让其他部分不会受到影响，这样可以导致代码的变化所引起的后果变少，代码更加可控并且不容易出问题。 大多数的模式都着眼于软件变化的主题，允许系统局部改变独立于其他部分。 （2）针对接口编程，而不是针对实现编程这里的接口不一定指的interface关键字，而是说针对超类型编程，即利用多态，动态绑定对应的执行方法。 （3）多用组合，少用继承“有">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式">
<meta property="og:url" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="设计模式设计原则（1）封装变化把会变化的部分取出并封装起来，好让其他部分不会受到影响，这样可以导致代码的变化所引起的后果变少，代码更加可控并且不容易出问题。 大多数的模式都着眼于软件变化的主题，允许系统局部改变独立于其他部分。 （2）针对接口编程，而不是针对实现编程这里的接口不一定指的interface关键字，而是说针对超类型编程，即利用多态，动态绑定对应的执行方法。 （3）多用组合，少用继承“有">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828104248465-63944401.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828104317270-396665969.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828104346692-775629068.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828104418901-669910264.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828104448461-445720531.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828104623355-395020836.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828104734741-460291300.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828104804100-330974965.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828104906200-389642996.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828105013587-1221184350.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828105112948-636045824.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828105217637-747315886.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828105302840-760912427.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828105452228-722350841.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/state.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828105608720-1043309143.png">
<meta property="og:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/mediator_pattern_uml_diagram.jpg">
<meta property="article:published_time" content="2024-03-29T13:02:25.000Z">
<meta property="article:modified_time" content="2024-03-29T13:03:08.723Z">
<meta property="article:author" content="王才雨">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1566782-20190828104248465-63944401.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>王才雨</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/dalaizi"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:1935863093@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1935863093&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(16)</small>
            
        </div>
    </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="16">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All "
           href="/2024/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RPC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解RPC">深入理解RPC</span>
            <span class="post-date" title="2024-04-03 13:06:31">2024/04/03</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <span class="post-date" title="2024-03-29 21:02:25">2024/03/29</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/20/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UNIX网络编程">UNIX网络编程</span>
            <span class="post-date" title="2024-03-20 15:03:46">2024/03/20</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/17/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2024-03-17 00:40:34">2024/03/17</span>
        </a>
        
        
        <a  class="All "
           href="/2024/02/25/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="后端开发面试题">后端开发面试题</span>
            <span class="post-date" title="2024-02-25 15:47:51">2024/02/25</span>
        </a>
        
        
        <a  class="All "
           href="/2024/01/05/Linux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux">Linux</span>
            <span class="post-date" title="2024-01-05 13:29:00">2024/01/05</span>
        </a>
        
        
        <a  class="All "
           href="/2023/11/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="力扣刷题">力扣刷题</span>
            <span class="post-date" title="2023-11-22 17:10:44">2023/11/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="动态代理">动态代理</span>
            <span class="post-date" title="2023-10-08 22:49:01">2023/10/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/04/08/%E9%A1%B9%E7%9B%AERPC%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="项目RPC框架">项目RPC框架</span>
            <span class="post-date" title="2023-04-08 19:49:23">2023/04/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/02/redis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="redis">redis</span>
            <span class="post-date" title="2023-01-02 17:46:17">2023/01/02</span>
        </a>
        
        
        <a  class="All "
           href="/2022/12/24/MySQL/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL">MySQL</span>
            <span class="post-date" title="2022-12-24 11:40:50">2022/12/24</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java并发编程">Java并发编程</span>
            <span class="post-date" title="2022-11-11 16:20:42">2022/11/11</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/30/JVM%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM调优">JVM调优</span>
            <span class="post-date" title="2022-10-30 20:09:07">2022/10/30</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解Java虚拟机">深入理解Java虚拟机</span>
            <span class="post-date" title="2022-10-19 10:40:02">2022/10/19</span>
        </a>
        
        
        <a  class="All "
           href="/2022/06/04/Java%E7%9F%A5%E8%AF%86%E7%82%B9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java知识点">Java知识点</span>
            <span class="post-date" title="2022-06-04 10:58:21">2022/06/04</span>
        </a>
        
        
        <a  class="All "
           href="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络">计算机网络</span>
            <span class="post-date" title="2022-02-06 18:11:21">2022/02/06</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-深入理解Java虚拟机" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">深入理解Java虚拟机</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-04-09 21:27:24'>2022-10-19 10:40</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">深入理解 Java 虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">第二章 Java内存区域与内存溢出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%EF%BC%88JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-text">1. 运行时数据区域（JVM 内存结构）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%EF%BC%89"><span class="toc-text">1.1 程序计数器（线程私有）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;1.2 虚拟机栈（线程私有）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">1.3 本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%A0%86%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;1.4 堆（线程共享）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;1.5 方法区（线程共享）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">1.6 直接内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">2. Java 内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-text">3. 对象的访问定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">3.1 对象的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">3.2 对象的内存布局</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">第三章 垃圾收集器与内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1"><span class="toc-text">1.判断对象是否死亡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">1.1 引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">1.2 可达性分析算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.3 引用类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">2. 垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-text">2.1 分代收集理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">2.2 标记-清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">2.3 标记-复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">2.4 标记-整理算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HotSpot%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-text">3. HotSpot算法实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B8%E5%9E%8B%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">4. 典型的垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial"><span class="toc-text">Serial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PerNew"><span class="toc-text">PerNew</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">Serial Old收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">Parallel Old收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS"><span class="toc-text">&#x3D;&#x3D;CMS&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">G1收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-text">5. 垃圾收集器的权衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;6. 内存分配与回收策略（重要）&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E7%AB%A0-JVM%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%8F%8A%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98"><span class="toc-text">第四、五章 JVM监控和故障处理及内存调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">第六章 类文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%85%B3%E6%80%A7%E5%9F%BA%E7%9F%B3"><span class="toc-text">无关性基石</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">Class文件结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-text">第七章 虚拟机类加载机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%97%B6%E6%9C%BA"><span class="toc-text">1. 类加载时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">2. 类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%8A%A0%E8%BD%BD"><span class="toc-text">2.1 加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E9%AA%8C%E8%AF%81"><span class="toc-text">2.2 验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%87%86%E5%A4%87"><span class="toc-text">2.3 准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E8%A7%A3%E6%9E%90"><span class="toc-text">2.4 解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.5 初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text">虚拟机字节码执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-text">运行时栈帧结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text">方法调用</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="深入理解-Java-虚拟机"><a href="#深入理解-Java-虚拟机" class="headerlink" title="深入理解 Java 虚拟机"></a>深入理解 Java 虚拟机</h1><h2 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 Java内存区域与内存溢出异常"></a>第二章 Java内存区域与内存溢出异常</h2><h3 id="1-运行时数据区域（JVM-内存结构）"><a href="#1-运行时数据区域（JVM-内存结构）" class="headerlink" title="1. 运行时数据区域（JVM 内存结构）"></a>1. 运行时数据区域（JVM 内存结构）</h3><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240220002259810.png" style="zoom:50%;">

<h4 id="1-1-程序计数器（线程私有）"><a href="#1-1-程序计数器（线程私有）" class="headerlink" title="1.1 程序计数器（线程私有）"></a>1.1 <strong>程序计数器</strong>（线程私有）</h4><p>是一块较小的内存空间，可以理解为<strong>当前线程所执行的字节码行号指示器</strong>，字节码解释器的工作就是通过改变这个计数器的值选取下一条要执行的字节码指令。</p>
<p>虚拟机的多线程通过线程轮流切换、分配处理器执行时间来实现，任意时刻一个内核只会执行一条线程中的指令。因此，为了线程切换后能恢复正确的执行位置，每个线程需要各自享有一个独立的程序计数器。</p>
<p>如果线程执行的是一个 Java 方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果是本地方法，PC计数器为空。</p>
<p>不会出现 OOM 错误</p>
<h4 id="1-2-虚拟机栈（线程私有）"><a href="#1-2-虚拟机栈（线程私有）" class="headerlink" title="&#x3D;&#x3D;1.2 虚拟机栈（线程私有）&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.2 <strong>虚拟机栈（线程私有）</strong>&#x3D;&#x3D;</h4><p> 每个线程单独享有一个虚拟机栈，栈中的元素是<strong>栈帧</strong>，栈帧中包含<strong>局部变量表、操作栈、动态连接、方法出口</strong>等信息，<strong>一个方法从调用到结束对应着栈帧的入栈和出栈</strong>。</p>
<p><strong>局部变量表</strong>存储了基本数据类型、引用类型、returnAddress 类型，存储以Slot 为单位。<strong>每个方法要用栈帧中局部变量表多大的空间编译时就确定了</strong>，运行时不会改变。但是注意，空间指的槽的数量，槽的大小由虚拟机自行决定。</p>
<p>虚拟机栈可能出现两种异常情况：</p>
<ul>
<li>如果<strong>线程申请的虚拟机栈的深度大于虚拟机允许的最大空间</strong>，会造成**<code>StackOverflowError</code>**；</li>
<li>如果虚拟机栈容量是可拓展的，那么在栈拓展过程中遇到本机内存空间不够的情况，会 <strong>OOM</strong> 的错误（HotSpot 默认栈不可拓展）</li>
</ul>
<h4 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 <strong>本地方法栈</strong></h4><p>它的作用和虚拟机栈类似，只是为本地方法服务</p>
<h4 id="1-4-堆（线程共享）"><a href="#1-4-堆（线程共享）" class="headerlink" title="&#x3D;&#x3D;1.4 堆（线程共享）&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.4 <strong>堆（线程共享）</strong>&#x3D;&#x3D;</h4><p>Java 堆是线程共享的，他是<strong>所有对象实例和数组创建的地方</strong>。</p>
<p>堆中的内存可以不是物理连续，但一定要是逻辑连续的，但是在遇到大对象的创建时（例如大数组对象）HotSpot 也会要求物理连续来节省内存访问与分配的开销。</p>
<p>java堆虽然是线程共享的，但是为了节省分配新对象的开销，我们可能会在堆中划分出<strong>多个线程私有的分配缓冲区（TLAB）</strong>，从而解决线程不安全的问题。</p>
<p>堆既可以被实现成固定大小的，也可以是可扩展的，主流的 Java 虚拟机可扩展来（通过参数 -Xmx 和 -Xms 设定）。如果在堆中没有内存完成实例分配，并且堆也不能再扩展时，抛出 OOM 异常。</p>
<h4 id="1-5-方法区（线程共享）"><a href="#1-5-方法区（线程共享）" class="headerlink" title="&#x3D;&#x3D;1.5 方法区（线程共享）&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.5 <strong>方法区</strong>（线程共享）&#x3D;&#x3D;</h4><p>方法区用来存储已经被虚拟机已加载的 <strong>类型信息</strong>、<strong>静态变量(static)</strong> 以及 **常量(static final)**、即时编译后的 <strong>代码缓存</strong> 等信息。虽然《Java 虚拟机规范》中把方法区描述为堆的逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。</p>
<p>在 JDK8 以前，我们用永久代来实现方法区，实际上也是把垃圾收集器的分代设计拓展到方法区。之后我们利用元空间实现方法区。元空间来自本地内存，所以这样设计不容易内存溢出。</p>
<p><strong>运行时常量池</strong></p>
<ul>
<li><p>运行时常量池（Runtime Constant Pool）是<strong>方法区</strong>的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有的<strong>常量池表</strong>，用来存储编译生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。这些内容会在类加载之后存放在<strong>运行时常量池</strong>中。除此保存Class文件中描述的符号引用外，它还把由符号引用翻译出来的<strong>直接引用</strong>也存在里面。</p>
</li>
<li><p>相较于 Class 文件常量池表，运行时常量池有<strong>动态性</strong>，在程序运行过程中也可以向常量池表中添加新常量。</p>
</li>
</ul>
<p><strong>字符串常量池</strong></p>
<ul>
<li>字符串常量池是存储所有字符串字面量的地方，包括<strong>使用双引号（<code>&quot;&quot;</code>）创建的字符串常量和通过调用<code>String</code>类的<code>intern()</code>方法手动添加到常量池中的字符串</strong>。</li>
<li>字符串常量池位于<strong>堆内存</strong>中的一部分或者在早期的 JVM 版本中位于<strong>方法区</strong>中。</li>
<li>字符串常量池的主要目的是提高字符串的重用率，以节省内存。如果多个字符串常量具有相同的值，它们会共享同一个内存地址。</li>
</ul>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240318153208596.png" alt="image-20240318153208596" style="zoom:55%;"> 

<h4 id="1-6-直接内存"><a href="#1-6-直接内存" class="headerlink" title="1.6 直接内存"></a>1.6 <strong>直接内存</strong></h4><p>直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p>本机直接内存的分配不会受到 Java堆 大小的限制，但是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置 -Xmx 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。</p>
<h3 id="2-Java-内存模型"><a href="#2-Java-内存模型" class="headerlink" title="2. Java 内存模型"></a>2. Java 内存模型</h3><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38348646">https://zhuanlan.zhihu.com/p/38348646</a></p>
<p>由上述对 JVM 内存结构的描述中，我们知道了堆和方法区是线程共享的。而局部变量，方法定义参数和异常处理器参数就不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java 线程之间的通信由 Java 内存模型（JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/v2-b098a84eb7598d70913444a991d1759b_1440w.webp" alt="img"></p>
<p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<p>下面通过示意图来说明这两个步骤：</p>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/v2-2c452d147bf0d09b14b770d3990740cb_1440w.webp" alt="img"></p>
<p>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。</p>
<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<p><strong>重排序</strong></p>
<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</p>
<p>这里说的重排序可以发生在好几个地方：编译器、运行时、JIT等，比如编译器会觉得把一个变量的写操作放在最后会更有效率，编译后，这个指令就在最后了（前提是只要不改变程序的语义，编译器、执行器就可以这样自由的随意优化），一旦编译器对某个变量的写操作进行优化（放到最后），那么在执行之前，另一个线程将不会看到这个执行结果。</p>
<p>当然了，写入动作可能被移到后面，那也有可能被挪到了前面，这样的“优化”有什么影响呢？这种情况下，其它线程可能会在程序实现“发生”之前，看到这个写入动作（这里怎么理解，指令已经执行了，但是在代码层面还没执行到）。通过内存屏障的功能，我们可以禁止一些不必要、或者会带来负面影响的重排序优化，在内存模型的范围内，实现更高的性能，同时保证程序的正确性。</p>
<p>下面我们来看一个重排序的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Reordering &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> y;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设这段代码有2个线程并发执行，线程A执行writer方法，线程B执行reader方法，线程B看到y的值为2，因为把y设置成2发生在变量x的写入之后（代码层面），所以能断定线程B这时看到的x就是1吗？</p>
<p>当然不行！ 因为在writer方法中，可能发生了重排序，y的写入动作可能发在x写入之前，这种情况下，线程B就有可能看到x的值还是0。</p>
<p>在Java内存模型中，描述了在多线程代码中，哪些行为是正确的、合法的，以及多线程之间如何进行通信，代码中变量的读写行为如何反应到内存、CPU缓存的底层细节。</p>
<p>在Java中包含了几个关键字：volatile、final和synchronized，帮助程序员把代码中的并发需求描述给编译器。JMM中定义了它们的行为，确保正确同步的Java代码在所有的处理器架构上都能正确执行。</p>
<p><strong>总结</strong></p>
<ol>
<li><p>内存模型是考察coder对一门语言的理解能力，从而进一步延伸到对JVM优化，和平时学习的深度上，是Java面试中最重要的一部分。</p>
</li>
<li><p>并发产生的bug非常难以调试，通常在测试代码中难以复现，当系统负载上来之后，一旦发生，又很难去捕捉，为了确保程序能够在任意环境正确的执行，最好是提前花点时间好好思考，虽然很难，但还是比调试一个线上bug来得容易的多。</p>
</li>
</ol>
<h3 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a>3. 对象的访问定位</h3><h4 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h4><ul>
<li>首先，虚拟机遇到一条字节码new指令时，会首先去检查<strong>这个指令的参数能否在常量池中定位到一个类的符号引用</strong>，并检查这个符号引用代表的类是否被加载解析初始化过了，要是没有就先执行类的加载过程</li>
<li>然后，在类加载检查通过后，虚拟机为新对象在堆中分配内存（所需大小在类加载完成过后便可确定）。有两种分配方式：<br><strong>指针碰撞</strong>：<br>内存规整，用过的和没用过的内存各自分开，中间用指针作为分界点指示器，分配内存就是把指针往空闲空间方向移动一段与对象大小相等的距离。<br><strong>空闲列表</strong>：<br>记录那些内存可用<br>举个栗子1.Serial，ParNew自带压缩整理，内存分配算法用的是碰撞指针，简单高效<br>2.CMS基于清除算法，空间杂乱。为了对象分配更快，设计了叫Linear Allocation Buffer 的分配缓冲区，利用空闲列表得到一大块分配缓冲区后，在里面仍然可以用指针碰撞来分配。</li>
<li>内存分配完成后，给除了对象头外的内存空间初始化为<strong>零值</strong>.如果 使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用</li>
<li>接下来，对对象头进行必要的设置，例如他的类元信息、对象的哈希码（实际上用到Object::hashCode()才会计算）、对象的GC分代年龄信息等</li>
<li>执行&lt;init&gt;()方法，即构造函数（对于程序来说这才是真正的创建对象）</li>
</ul>
<h4 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h4><p><strong>对象头</strong><br>1.储存对象自身的运行时数据，包括哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等<br>2.类型指针，即对象指向它的类型元数据的指针。如果对象是数组，对象头还要记录数组长度<br><strong>实例数据</strong><br>对象真正存储的有效信息，父类和子类的字段。相同宽度的字段总是分配到一起存放，在满足这个条件的前提下，父类变量会出现在子类前。如果-XX ：Compact Fields 参数为true，那子类之中较窄的变量也能插入父类变量的空隙中，以节省空间<br><strong>对齐填充</strong><br>占位符，任何对象的大小必须是8字节的整数倍</p>
<p><strong>句柄引用访问</strong><br>线程的虚拟机栈的栈帧中的本地变量表的reference类型数据，它存放的并不是在堆中的对象实例本身，而是指向了一个句柄池。句柄池存放着类类型指针和对象实例指针。这样通过二次访问的方式我们找到对象实例，但是访问效率肯定不如直接访问高。<br>垃圾回收进行对象实例位置移动是很常见的现象，而移动对象只需要改变句柄指针的内容，而不用改变reference的值，这是句柄访问的优点</p>
<p><strong>直接指针访问</strong><br>对象的布局分布必须考虑存放访问类型数据的相关信息，reference存的直接就是对象地址。速度快，节省了一次指针定位的时间开销</p>
<h2 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h2><p>GC 要做三件事，哪些内存需要回收（对象是否死亡）、什么时候回收、怎么回收（回收算法）</p>
<h3 id="1-判断对象是否死亡"><a href="#1-判断对象是否死亡" class="headerlink" title="1.判断对象是否死亡"></a>1.判断对象是否死亡</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 <strong>引用计数法</strong></h4><p>对象中添加引用计数器，每当有一个地方引用它，计数器加一，引用失效，计数器减一。计数器为零的对象可被回收</p>
<p>&#x3D;&#x3D;问题：无法解决对象之间循环引用的问题&#x3D;&#x3D;</p>
<h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 <strong>可达性分析算法</strong></h4><p>从一系列 <code>GC Roots</code> 根对象，按照引用关系向下搜索，搜索过程走过的路径为引用链，如果某个对象到GC Roots间没有任何引用链相连，证明对象是垃圾</p>
<blockquote>
<p><code>GC Roots</code>对象可以是</p>
</blockquote>
<blockquote>
<ul>
<li>虚拟机栈（<strong>栈帧中的本地变量表</strong>）中引用的对象，例如各个线程被调用的方法堆栈中的参数、局部变量、临时变量等</li>
<li><strong>方法区中静态属性、常量</strong>引用的对象。例如字符串常量池中的引用</li>
<li>被<strong>同步锁(synchronized)持有</strong>的对象</li>
<li>虚拟机内部的引用，如基本数据类型对应的 Class 对象，异常对象（<code>NullPointException</code> <code>OutOffMemoryError</code>） 系统类加载器</li>
</ul>
</blockquote>
<p>宣告对象死亡需要 两个标记过程：</p>
<blockquote>
<ol>
<li><p>如果对象在可达性分析后发现没有和GC Roots相连的引用链，那会被第一次标记</p>
</li>
<li><p>然后再一次筛选，筛选的条件是是否有必要执行Finalize（）方法</p>
<p>2.1 如果对象没有覆盖finalize()方法，或finalize()方法已经被调用过一次，那么方法不会被执行，对象死亡</p>
<p>2.2 如果对象有必要执行finalize()方法，则会被放置在F-Queue队列中，由虚拟机自动创建的、低调度优先级的 Finalizer 线程去执行 Finalize() 方法，看能否自救成功（比如把this赋值给某个成员变量）</p>
</li>
</ol>
</blockquote>
<h4 id="1-3-引用类型"><a href="#1-3-引用类型" class="headerlink" title="1.3 引用类型"></a>1.3 引用类型</h4><ul>
<li>强引用<ul>
<li>即普遍存在的引用赋值，强引用的对象不会回收</li>
</ul>
</li>
<li>软引用<ul>
<li>描述有用但非必须的对象，内存不够时回收，SoftReference 类实现软引用</li>
</ul>
</li>
<li>弱引用<ul>
<li>描述非必须对象，发生GC时会被回收，WeakReference 类实现弱引用</li>
</ul>
</li>
<li>虚引用<ul>
<li>唯一作用对象被回收时得到一个系统通知，不能通过虚引用得到实例，PhantomReference 类实现虚引用</li>
</ul>
</li>
</ul>
<h3 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h3><h4 id="2-1-分代收集理论"><a href="#2-1-分代收集理论" class="headerlink" title="2.1 分代收集理论"></a>2.1 <strong>分代收集理论</strong></h4><p>（1）弱分代假说：绝大多数对象朝生夕灭<br>（2）强分代假说：熬过多次垃圾收集的对象难以消灭<br>（3）跨代引用假说：跨代引用相对于同代引用占极少数，几存在相互引用关系的两个对象，倾向于同时生存、同时消亡</p>
<blockquote>
<p>所以，不用为了少量的跨代引用去扫描整个老年代，也不用浪费空间专门记录每个对象是否存在以及存在哪些跨代引用。</p>
<p>只需在新生代上建立一个全局数据结构 <strong>记忆集</strong> ，该结构把老年代划分成若干小块，标识老年代哪块有跨代引用。</p>
<p>MinorGC 时，只将包含跨代引用的内存的对象加入 GC Roots扫描，虽然引用关系改变时有维护开销，但比每次扫描整个老年代要划算</p>
</blockquote>
<h4 id="2-2-标记-清除算法"><a href="#2-2-标记-清除算法" class="headerlink" title="2.2 标记-清除算法"></a>2.2 <strong>标记-清除算法</strong></h4><p>（1）&#x3D;&#x3D;标记&#x3D;&#x3D;：标记出要回收的对象</p>
<p>（2）&#x3D;&#x3D;清除&#x3D;&#x3D;：回收掉标记的对象</p>
<p><strong>缺点：</strong></p>
<ul>
<li>&#x3D;&#x3D;执行效率不稳定&#x3D;&#x3D;，如果堆中包含大量对象并且大部分要回收，会进行大量的标记和清除动作，&#x3D;&#x3D;执行效率随对象数量增长而降低&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;内存空间碎片化&#x3D;&#x3D;，以后分配大对象可能无法找到连续的内存而触发另一次垃圾回收</li>
</ul>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307101808110.png"></p>
<h4 id="2-3-标记-复制算法"><a href="#2-3-标记-复制算法" class="headerlink" title="2.3 标记-复制算法"></a>2.3 <strong>标记-复制算法</strong></h4><p>为解决<strong>面对大量可回收对象执行效率低</strong>问题，提出“半区复制”，将可用内存按容量划分成两块，将存活对象复制到另外一块，然后已使用的内存空间清理掉</p>
<p><strong>优点：</strong></p>
<ul>
<li>对于<strong>多数对象都是可回收的情况</strong>，复制少数存活对象性能好</li>
<li>因为针对半区进行内存回收，不会出现<strong>空间碎片</strong></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果<strong>大多数对象存活，复制开销大</strong></li>
<li><strong>浪费一半空间</strong>，如果不想浪费50%空间，就要<strong>分配担保</strong></li>
</ul>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307102148014.png"></p>
<blockquote>
<p>复制算法实现新生代，分成Eden区和两块Survivor区，比例8：1：1</p>
<p>每次分配内存只使用Eden和一块Survivor，GC时将存活对象一次性复制到另一块Survivor（新生代可用空间为整个新生代容量的90%）</p>
<p><strong>分配担保</strong>：<strong>当Survivor空间不足以容纳一次 Minor GC 后存活的对象</strong>，需要通过分配担保机制进入老年代</p>
</blockquote>
<h4 id="2-4-标记-整理算法"><a href="#2-4-标记-整理算法" class="headerlink" title="2.4 标记-整理算法"></a>2.4 <strong>标记-整理算法</strong></h4><p>（1）&#x3D;&#x3D;标记&#x3D;&#x3D;：可回收对象</p>
<p>（2）&#x3D;&#x3D;整理&#x3D;&#x3D;：<strong>让所有存活对象向空间一端移动，然后直接清理掉边界以外的内存</strong></p>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307103904391.png"></p>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>移动存活对象</strong>并<strong>更新引用</strong>负担重，并且要全程<strong>暂停用户线程</strong>（STW）。让内存回收更复杂</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>让内存分配和访问更高效，因为<strong>没有碎片化空间</strong>。总体上虽然增加延迟，但是提高了吞吐量</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>标记-复制 算法完全不考虑移动、整理存活对象，空间碎片造成内存分配、内存访问更复杂（比如 通过“分区空闲分配链表”解决），影响系统吞吐量</li>
<li>整理存活对象——<strong>内存回收</strong>更复杂，系统吞吐量高；不整理——<strong>内存分配</strong>更复杂，GC停顿时间短</li>
<li>关注<strong>吞吐量</strong>的<strong>Parallel Scavenge</strong>使用整理算法；关注<strong>延迟</strong>的<strong>CMS</strong>使用复制算法</li>
</ul>
<h3 id="3-HotSpot算法实现细节"><a href="#3-HotSpot算法实现细节" class="headerlink" title="3. HotSpot算法实现细节"></a>3. HotSpot算法实现细节</h3><p><strong>根节点枚举</strong><br>固定可作为GC Roots的节点主要在全局性的引用（常量、静态属性）和执行上下文（本地变量表）中，找到这些根节点，并不需要逐个寻找。虚拟机用OopMap数据结构记录哪些地方存在对象引用，一旦类加载动作完成时，HotSpot会把对象内什么偏移量上是什么类型的数据计算出来，即时编译过程中也在特定位置会记录下栈里和寄存器里哪些位置是引用<br><strong>安全点</strong><br>在OopMap的协助下，HotShot快速准确完成GC Roots枚举。实际上HotShot没有为每条指令都生成OopMap，而只是在特定位置记录这些信息，称为安全点。垃圾收集强制要求必须执行到安全点后才能暂停<br><strong>记忆集</strong><br>记忆集是一种用于记录从非收集区指向收集区的指针集合的抽象数据结构。收集器只需要通过记忆集判断出某一块非收集区是否存在指向收集区的指针就可以了，并不需要了解跨代指针的全部细节<br><strong>卡表</strong>定义了记忆集的记录精度、与堆内存的映射关系<br><strong>写屏障</strong><br>通过写屏障维护卡表状态，看作对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生环形通知，供程序做额外动作。直到G1出现前，其他收集器只用了写后屏障。<br>除了写屏障的开销外，卡表在高并发场景下面临“伪共享”问题。当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，会彼此影响导致性能降低。解决方法是不使用无条件的写屏障<br><strong>并发的可达性分析</strong><br>遍历对象图，采用三色标记。如果和用户线程并发，可能有两种后果：<br>1.原本消亡的对象标记成存活，产生浮动垃圾<br>2.原本存活的对象标记成消亡，不能容忍。产生条件为</p>
<blockquote>
<p>赋值器插入了一条或多条黑色到白色对象的新引用<br>删除了全部灰色到该白色对象的直接或间接引用</p>
</blockquote>
<p>解决方法：<br>1.增量更新：黑色对象一旦插入指向白色对象的引用后，就把他变成灰色。如 CMS<br>2.原始快照（SATB）：记录下删除的引用，以灰色对象为根，重新扫描一次 如 G1 Shenandoah</p>
<h3 id="4-典型的垃圾收集器"><a href="#4-典型的垃圾收集器" class="headerlink" title="4. 典型的垃圾收集器"></a>4. 典型的垃圾收集器</h3><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307105438999.png" style="zoom:67%;"> 

<h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a><strong>Serial</strong></h4><p>单线程收集器，它只会使用一个处理器或一条收集线程去完成垃圾收集工作，并且要暂停其他所有工作线程STW，知道收集结束是HotShot在<strong>客户端</strong>模式下默认的新生代收集器。与其他收集器的单线程比，简单高效，额外内存消耗最少。对于处理器核心数较少的环境来说，Serial由于没有线程交互的开销，可以得到最高的单线程收集效率。</p>
<h4 id="PerNew"><a href="#PerNew" class="headerlink" title="PerNew"></a><strong>PerNew</strong></h4><p>多线程并行收集器，运行于<strong>服务器</strong>模式下的虚拟机，可以配合CMS工作<br>服务器模式下推荐的组合，曾经是PerNew+CMS，现在是G1。现在可以理解为，PerNew合并到CMS，成为CMS专门处理新生代的组成部分</p>
<blockquote>
<p>并行（Parallel）：描述多条垃圾回收线程之间的关系。同一时间有多条回收线程协同工作，默认用户线程处于等待状态<br>并发（Concurrent）：描述垃圾回收线程和用户线程之间的关系，同一时间两种线程都在运行。由于用户线程未冻结，所以程序仍然能相应服务器请求，但由于垃圾收集线程占用了一部分系统资源，此时应用程序处理的吞吐量受影响</p>
</blockquote>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a><strong>Parallel Scavenge收集器</strong></h4><p>类似PerNew是多线程并行收集器，关注点是达到一个可控制的<strong>吞吐量</strong>（吞吐量是处理器用于运行用户代码的时间和处理器总消耗时间的比值），也叫“吞吐量优先处理器”<br>停顿时间越短，越适合需要与用户交互或需要保证服务响应质量的程序<br>高吞吐量可以高效利用处理器资源，适合在后台运算而不需要而不需要太多交互分析的任务<br>控制吞吐量的参数</p>
<blockquote>
<p>最大垃圾收集停顿时间 -XX: MaxGCPauseMillis<br>直接设置吞吐量大小 -XX: GCTimeRatio<br>自适应调节开关 -XX: +UseAdaptiveSizePolicy，动态调整新生代大小、比例，晋升老年代对象老年代大小等细节参数，以提供最合适的停顿时间或最大的吞吐量</p>
</blockquote>
<p><strong>自适应调节策略</strong>也是Parallel Scavenge区别于ParNew的重要特征</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a><strong>Serial Old收集器</strong></h4><p>单线程收集器，老年代，标记整理算法<br>客户端模式：和Serial结合<br>服务器模式：作为CMS收集器并发失败的后备方案</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a><strong>Parallel Old收集器</strong></h4><p>多线程并行收集，老年代，标记整理算法<br>注重吞吐量或处理器资源比较稀缺时，可以考虑 Parallel Scavenge+Parallel Old</p>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="&#x3D;&#x3D;CMS&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>CMS</strong>&#x3D;&#x3D;</h4><p>第一款真正意义上<strong>支持并发</strong>的垃圾收集器，以<strong>获取最短停顿时间</strong>为目标<br>应用场景：互联网网站或者基于浏览器的B&#x2F;S系统的服务器上，关注<strong>响应速度</strong>和<strong>交互体验</strong></p>
<p>CMS <code>concurrent mark swap</code>基于 <strong>标记-清除</strong> 算法实现：<br><strong>（1）初始标记</strong> <code>STW 标记GC Roots 能直接关联到的对象</code><br><strong>（2）并发标记</strong><code>（增量更新）从GC Roots 直接关联的对象开始遍历整个对象图的过程</code><br><strong>（3）重新标记</strong> <code>修正并发标记期间，因用户程序继续运作导致标记产生变动的对象的标记记录</code><br>（4）**并发清除 **<code>由于不需要移动存活对象，可以和用户线程并发</code></p>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307110124989.png"></p>
<p>&#x3D;&#x3D;<strong>优点：</strong>&#x3D;&#x3D;</p>
<ul>
<li>并发收集、低停顿</li>
</ul>
<p>&#x3D;&#x3D;<strong>缺点：</strong>&#x3D;&#x3D;</p>
<ul>
<li><p>&#x3D;&#x3D;对处理器资源十分敏感&#x3D;&#x3D;。&#x3D;&#x3D;并发&#x3D;&#x3D;阶段虽然不会导致用户线程停顿，但会因为占用了一部分线程而导致应用程序变慢，&#x3D;&#x3D;降低总吞吐量&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;无法处理浮动垃圾&#x3D;&#x3D;，可能产生并发失败而导致STW的Full GC</p>
<blockquote>
<p>CMS并发标记和并发清除阶段，由于用户线程还在运行，不断产生未被标记的新垃圾，只能下一次GC再清理掉。所以 CMS 不能像其他收集器一样等到老年代几乎被填满再收集，它必须预留空间满足程序分配新对象的需要，否则就会出现并发失败<code>Concurrent Mode Failure</code>，冻结用户线程，临时启用 <code>Serial Old</code> 进行老年代垃圾收集</p>
<p>所以，参数<code>-XX:CMSInitiatingOccupancyFraction</code>设置太高然而容易因产生大量并发失败二降低性能</p>
</blockquote>
</li>
<li><p>3.基于 &#x3D;&#x3D;标记-清除&#x3D;&#x3D; 算法实现，产生大量内存碎片。当没用空间分配新对象时，提前触发 <code>Full GC</code></p>
</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a><strong>G1收集器</strong></h4><p>取代<code>Parallel Scavenge+Parallel Old</code>组合，成为<strong>服务端</strong>模式下的默认垃圾收集器</p>
<p><strong>&#x3D;&#x3D;Mixed GC 模式&#x3D;&#x3D;<strong>：面向堆内存任何部分来组成回收集，衡量标准不再是它属于哪一代，而是</strong>哪块内存存放的垃圾最多，回收收益最大</strong></p>
<p>开创<strong>基于Region的堆内存布局</strong>，把Java堆划分成多个大小相等的独立区域（Region），每个 Region 可以根据需要扮演 Eden、Survior、老年代。G1 根据 Region 扮演的不同角色采用 不同的处理策略。</p>
<p>Region 的 <strong><code>Humongouns</code>区域，存储大对象</strong>。大小超过 Region 一半就是大对象</p>
<blockquote>
<p><code>-XX: G1HeapRegionSize</code> 设定 Region大小（1MB- 32MB，2^N）超大对象存放于多个Humogous Region，并被视为老年代</p>
</blockquote>
<p><strong>为什么G1能建立可预测的停顿时间模型？</strong></p>
<p><strong>将Region作为单次回收的最小单元</strong>，关注Region里面垃圾堆积的<strong>价值</strong>，即回收所获得的空间大小以及回收所需时间的经验值。后台维护优先级列表，根据用户用户允许的停顿时间，优先处理那些回收收益最大的Region</p>
<p>跨Region区引用问题：<br>每个Region维护自己的记忆集，记录别的Region指向自己的指针，并标记这些指针在哪些卡页范围内。本质是哈希表，key是别的Region的起始地址，value是集合存储卡表的索引号，。由于Region数量比传统分代收集器的分代数量多，所以有更高的内存占用</p>
<p>基于标记整理算法实现：<br>1.初始标记<br>2.并发标记：原始快照（SATB）。为保证新对象分配，每个Region设计了两个TAMS指针，新分配的对象地址在两个TAMS之上，被隐式标记，默认存活<br>3.最终标记<br>4.筛选回收</p>
<p>优点：指定最大停顿时间、分Region内存布局、按收益动态确定回收集、无内存碎片<br>缺点：内存占用、额外执行负荷</p>
<h3 id="5-垃圾收集器的权衡"><a href="#5-垃圾收集器的权衡" class="headerlink" title="5. 垃圾收集器的权衡"></a>5. 垃圾收集器的权衡</h3><p>三指标： 吞吐量、延迟、内存占用<br>1.应用程序的主要关注点是什么？</p>
<blockquote>
<p>数据分析、科学计算，目标是尽快算出结果——吞吐量<br>SLA应用，停顿时间影响服务质量，严重可能导致事务超时——延迟<br>客户端应用或嵌入式应用——内存占用</p>
</blockquote>
<p>2.运行应用的基础设施如何？</p>
<blockquote>
<p>硬件规格，涉及到的系统架构是x86-32&#x2F;64、SPARC还是ARM&#x2F;Aarch64；处理器数量、分配内存大小；操作系统</p>
</blockquote>
<p>3.JDK发行商、版本</p>
<h3 id="6-内存分配与回收策略（重要）"><a href="#6-内存分配与回收策略（重要）" class="headerlink" title="&#x3D;&#x3D;6. 内存分配与回收策略（重要）&#x3D;&#x3D;"></a>&#x3D;&#x3D;6. 内存分配与回收策略（重要）&#x3D;&#x3D;</h3><p><strong>对象优先在Eden分配</strong></p>
<p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起⼀次 Minor GC。</p>
<p><strong>大对象直接进入老年代</strong></p>
<p>大对象就是指需要大量连续内存空间的 Java 对象，HotSpot 虚拟机提供 <code>-XX: PretenureSizeThreshold</code> 参数，超过该参数的对象会直接在老年代分配，从而避免 Eden 和两个 Survior 区之间来回复制，产生大量内存复制操作</p>
<p><strong>长期存活对象进入老年代</strong></p>
<p>虚拟机给每个对象定义了一个对象年龄(Age)计数器，存储在对象头中(详见第2章)。对象通常在 Eden 区里诞生，如果经过第一次 Minor  GC 后仍然存活，并且能被 Survivor 容纳的话，该对象会被移动到 Survivor 空间中，并且将其对象年龄设为1岁。对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 设置。</p>
<p><strong>动态对象年龄判断：</strong></p>
<p>虚拟机并不永远要求对象的年龄必须达到 <code>-XX: MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 <code>-XX: MaxTenuringThreshold</code> 中要求的年龄。</p>
<p><strong>空间分配担保</strong></p>
<p>Minor GC前，检查老年代最大可用连续空间是否大于新生代所有对象总空间。成立则进行，不成立检查是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，大于则尝试进行一次 Minor GC，小于或者不允许担保失败，进行 Full GC。</p>
<h2 id="第四、五章-JVM监控和故障处理及内存调优"><a href="#第四、五章-JVM监控和故障处理及内存调优" class="headerlink" title="第四、五章 JVM监控和故障处理及内存调优"></a>第四、五章 JVM监控和故障处理及内存调优</h2><p><strong>性能监控和故障处理工具</strong><br>jsp：输出虚拟机中运行的进程状态信息<br>jstat：持续观察虚拟机内存中各个分区的使用率以及GC的统计数据<br>jmap：查看堆内存的使用情况<br>jstack：查看java进程内线程堆栈信息，结合日志可以迅速定位到问题线程<br>JMC：分析本地应用以及连接远程ip使用，提供实时分析线程、内存、CPU、GC等信息的可视化界面</p>
<h2 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 类文件结构"></a>第六章 类文件结构</h2><h3 id="无关性基石"><a href="#无关性基石" class="headerlink" title="无关性基石"></a>无关性基石</h3><ul>
<li><p>语言无关性</p>
<ul>
<li>实现语言无关性的基础是【虚拟机】和【字节码存储格式】</li>
<li>虚拟机不与任何程序语言绑定，它只和“Class文件”这种特定的二进制文件格式所关联</li>
<li>其他任何语言的实现者都可以将 Java 虚拟机作为语言的运行基础，以 Class 文件作为产品的交付媒介</li>
</ul>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116132246640.png" alt style="zoom:50%;">
</li>
<li><p>平台无关性</p>
<ul>
<li>各种不同平台的【Java虚拟机】，以及所有平台都统一支持的【程序存储格式——字节码】，是构成平台无关性的基石</li>
<li>开发商开发出的各种平台上的虚拟机，屏蔽掉了各个平台操作系统和机器指令集的不同性，不同平台的虚拟机识别相同的 Class 文件，实现 Java 等语言的“一次编译，到处运行”</li>
</ul>
</li>
</ul>
<h3 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h3><p>Java 技术保持良好的向后兼容性，Class 文件结构的稳定功不可没</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是类或接口不一定都要定义在文件里（比如可以动态生成，直接送入类加载器中）<br>Class文件是以8个字节为基础单位的二进制流，各个数据项严格按顺序紧凑排列在文件当中，中间没有任何分隔符。当遇到占用8字节以上空间的数据项时，会按照高位在前方式分割成若干8个字节</p>
<p>Class 文件只有两种数据类型：</p>
<ul>
<li>无符号数：是基本数据类型，以 u1，u2，u4，u8 表示对应字节的无符号数，描述数字、索引引用、数量值、按照UTF-8编码构成的字符串值</li>
<li>表：多个无符号数或其他表作为数据项构成的复合数据结构，”_info“ 结尾。整个 Class 文件本质也可看做一张表</li>
</ul>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116142558649.png" alt style="zoom:50%;">

<p><strong>魔数</strong></p>
<p>​	占 4 字节，确认文件是否为一个能被虚拟机接受的文件（不用拓展名识别身份，更安全），值为 0xCAFEBABE</p>
<p><strong>版本号</strong></p>
<pre><code>1. 前两个字节是次版本号，不常用，主要用于测试版本
1. 后两个字节是主版本号，高版本 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件。《Java虚拟机规范》规定，即使文件格式未发生变化，虚拟机也拒绝运行超过其版本号的 Class 文件
</code></pre>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116143341963.png" alt style="zoom:50%;">

<blockquote>
<p>比如，一个版本号为 0x0032 （十进制 50）的 Class 文件，只能被 JDK 6 或以上版本的虚拟机执行 </p>
</blockquote>
<p><strong>常量池</strong></p>
<ol>
<li><p>Class 文件中第一个出现的表类型数据项目，存放字面量和符号引用</p>
</li>
<li><p>常量池入口有 u2 类型数据，表示常量池容量计数值（constant_pool_count）</p>
<blockquote>
<p>注意：计数从 1 开始</p>
<p>比如，常量池容量为 0x0016（十进制 22），表示常量池有 21 项常量 （1-21），如果某些指向常量池的索引值为 0，表示不引用任何一个常量池项目</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>字面量</p>
<blockquote>
<p> 类似常量，如文本字符串、被声明为final的常量值等</p>
</blockquote>
</li>
<li><p>符号引用：</p>
<blockquote>
<p>被模块导出或者开放的包<br>类和接口的全限定名<br>字段的名称和描述符<br>方法的名称和描述符<br>方法句柄和方法类型<br>动态调用点和动态常量</p>
</blockquote>
</li>
</ul>
<p>​		当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中<br><strong>访问标志</strong><br>​	1. 常量池结束后，紧接着两字节表示访问标志（access_flag），识别一些类或接口的访问信息，包括：Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明final等<br>​	1. access_flag 共 16 个标志位可用，只定义了 9 个，没用到的一律为 0</p>
<h2 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d432a94be182">https://www.jianshu.com/p/d432a94be182</a></p>
<p>Java 虚拟机把描述类的数据从 <strong>Class 文件</strong>加载到<strong>内存</strong>，并对数据进行校验、解析、初始化等过程，最终形成可被虚拟机直接使用的 Java 类型，称为虚拟机类的加载机制。</p>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116163240786.png" alt style="zoom:40%;"> 

<p>Java 中，类的加载、链接、初始化都是在，程序运行期间完成的：</p>
<ul>
<li><p>缺点：提前编译带来困难，类加载增加性能开销</p>
</li>
<li><p>运行期动态加载、动态连接，提高可拓展性、灵活性</p>
<blockquote>
<p>应用：Applet、JSP、OSGi、</p>
</blockquote>
</li>
</ul>
<h3 id="1-类加载时机"><a href="#1-类加载时机" class="headerlink" title="1. 类加载时机"></a>1. 类加载时机</h3><p><strong>加载、验证、准备、初始化、卸载</strong> 这五个阶段顺序确定，<strong>解析</strong>阶段不一定，可以在初始化以后再进行，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。注意，这里的几个阶段是按顺序开始，而不是按顺序进行或完成的，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用、激活另外一个阶段。</p>
<p><strong>主动引用</strong></p>
<p>《Java虚拟机规范》没有强制约束类什么时候加载，但是规定了【有且仅有】六种情况要立刻进行类的 初始化：</p>
<ul>
<li>遇到<code>new</code> 、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这四条字节码指令<ul>
<li><code>new</code>实例化对象</li>
<li>设置或读取一个类型的静态字段（被<code>final</code>修饰、已在编译期把结果放进常量池的静态字段除外）</li>
<li>调用一个类型的静态方法时</li>
</ul>
</li>
<li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用时</li>
<li>初始化类时，发现父类还没初始化，要先初始化父类</li>
<li>先初始化主类</li>
<li>如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果为<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>、 <code>REF_newInvokeSpecial</code>四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</li>
<li>一个接口定义了默认方法<code>default</code>，如果这个接口的实现类发生初始化，接口要在它之前初始化</li>
</ul>
<p>注意：对于静态字段，<strong>只有直接定义这个字段的类才会被初始化</strong>，因此通过子类引用父类定义的静态字段，只会触发父类初始化而不会触发子类<br>接口不能用static语句块，但编译器也会接口生成<clinit>()类构造器，用于初始化接口定义的成员变量。接口初始化不要求父接口全部完成初始化，只有在真正使用到父接口时（如引用接口定义的的常量）才会初始化</clinit></p>
<p><strong>被动应用</strong></p>
<ul>
<li>通过子类调用父类的静态字段，不会导致子类初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>通过数组来引用类，不会导致此类初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发定义常量的类的初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>补充</strong></p>
<ul>
<li>访问【编译期常量】<ul>
<li>常量的值可以在编译期间确定，访问该常量时不会引起常量所在类的初始化</li>
</ul>
</li>
<li>访问【运行期常量】<ul>
<li>常量的值不可以在编译期间确定，访问该常量时会引起常量所在类的初始化</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>接口初始化不要求父接口初始化，真正用到父接口（引用接口中定义的常量）才会初始化（除了含<code>default</code>方法的接口）</li>
</ul>
<h3 id="2-类加载过程"><a href="#2-类加载过程" class="headerlink" title="2. 类加载过程"></a>2. 类加载过程</h3><h4 id="2-1-加载"><a href="#2-1-加载" class="headerlink" title="2.1 加载"></a>2.1 <strong>加载</strong></h4><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240401081118080.png" alt="image-20240401081118080" style="zoom: 80%;"> 

<p>加载阶段主要<strong>查找并加载类的二进制数据</strong>。在该阶段，虚拟机需要完成以下3件事情：</p>
<ul>
<li><p>通过一个类的【全限定名】获取类的二进制字节流</p>
<blockquote>
<p>没有要求怎样获取、从哪里获取，具有很强的灵活性</p>
<p>比如：从 ZIP 压缩包获取——JAR、WAR；网络中获取——Web Applet；动态代理；由其他文件生成——JSP 等</p>
</blockquote>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为【方法区】的运行时数据结构</p>
</li>
<li><p>内存中生成一个代表这个类的的【java.lang.Class对象】，作为方法区这个类的各种数据的访问入口</p>
</li>
</ul>
<p>相对于类加载的其他阶段，一个<strong>非数组类</strong>的<strong>加载</strong>阶段是开发人员可控性最强的阶段，因为该阶段既可以使用系统提供的<strong>引导类加载器</strong>来完成，也可以由<strong>用户自定义的类加载器</strong>去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。</p>
<p>对于<strong>数组类</strong>，其本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终靠类加载器去创建。一个数组类的创建过程遵循以下规则：</p>
<ul>
<li>如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组类将在加载该组件类型的类加载器的类名称空间上被标识。</li>
<li>如果数组的组件类型不是引用类型（如int[]数组），Java虚拟机将会把数组类标记为与引导类加载器关联。</li>
<li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认为public。</li>
</ul>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个<code>java.lang.Class</code>类的对象，这个对象将作为程序访问方法区中的这些数据的外部接口。</p>
<h4 id="2-2-验证"><a href="#2-2-验证" class="headerlink" title="2.2 验证"></a>2.2 <strong>验证</strong></h4><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240401082204443.png" alt="image-20240401082204443" style="zoom:80%;"> 

<p>验证阶段的目的是为了<strong>确保Class文件的字节流中包含的信息符合当前虚拟机的要求</strong>，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<p>（1）<strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，而且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以<strong>0xCAFEBABE</strong>开头。</li>
<li>主、次版本号是否在当前虚拟机的处理范围之内。</li>
<li>常量池中的常量是否有不被支持的常量类型。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>
</ul>
<p>第一阶段的验证点远不止这些，该验证阶段的主要目的是<strong>保证输入的字节流能正确地解析并存储于方法区内，格式上符合描述一个Java类型信息的要求</strong>。该阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段都是基于方法区的存储结构进行的，不会再直接操作字节流。 </p>
<p>（2）<strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点：</p>
<ul>
<li>这个类是否有除了java.lang.Object之外的父类。</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾。</li>
</ul>
<p>（3）<strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换是有效的。</li>
</ul>
<p>（4）<strong>符号引用验证</strong>：最后一个阶段的校验发生在解析阶段，其对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验以下内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的访问性是否可被当前类访问。</li>
</ul>
<p>符号引用验证的目的是<strong>确保解析动作能正常执行</strong>，如果无法通过符号引用验证，那么将会抛出异常。该阶段是一个非常重要的、但不是一定必要的阶段。</p>
<p>1.文件格式验证</p>
<blockquote>
<p>验证字节流是否符合Class文件格式的规范：</p>
<ul>
<li>是否一魔数0xCAFEBABE开头</li>
<li>主、次版本号是否在当前虚拟机接受范围内</li>
<li>常量池常量是否有不被支持的常量类型（检查常量tag标志）</li>
<li>指向常量的索引值是否有指向不存在的常量或不符合类型的常量</li>
<li>CONSTANT_UTF8_info型常量是否有不符合UTF8编码的数据</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息<br>验证目的：保证输入的字节流能正确的解析并存储于方法区之内。<br>文件格式验证基于二进制字节流，通过后字节流才允许进入虚拟机内存的方法区进行存储，后面三个阶段的验证全部基于方法区的存储结构，不会直接读取、操作字节流了</li>
</ul>
</blockquote>
<p>2.元数据验证</p>
<blockquote>
<p>对字节码描述的信息进行<strong>语义分析</strong></p>
<ul>
<li>这个类是否有父类（除了java.lang.Object，都应该有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了父类或接口中要求实现的方法</li>
<li>类中的字段、方法是否与父类产生矛盾（例如覆盖了父类final字段，出现不合规格的方法重载）</li>
</ul>
</blockquote>
<p>3.字节码验证</p>
<blockquote>
<p>最复杂的阶段，通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列能配合工作</li>
<li>保证任意时刻跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>保证方法体中的类型转换总是有效的</li>
</ul>
</blockquote>
<p>4.符号引用验证</p>
<blockquote>
<p>符号引用验证发生在解析阶段（将符号引用转化为直接引用）。符号引用验证可以看作对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，目的是保证解析行为能正常进行</p>
<ul>
<li>符号引用中通过字符串描述的全限定名能否找到对应类</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的可访问性是否能被当前类访问</li>
</ul>
</blockquote>
<h4 id="2-3-准备"><a href="#2-3-准备" class="headerlink" title="2.3 准备"></a>2.3 <strong>准备</strong></h4><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240401084722919.png" alt style="zoom:80%;"> 

<p>准备阶段主要<strong>为类的静态变量分配内存并将其初始化为默认值</strong>，这些内存都将在<strong>方法区</strong>中分配（ JDK8 以后，类变量会随着 Class 对象放到堆中，这时类变量在方法区是一种逻辑上的概念）。</p>
<p>该阶段有两点需要注意：</p>
<p>（1）首先，这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p>
<p>（2）其次，这里所设置的初始值通常是数据类型默认的初始值，而不是被在 Java 代码中被显式地赋予的值。这里还需要注意如下几点：</p>
<ul>
<li>对<strong>基本数据类型</strong>来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被<strong>final</strong>修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于<strong>引用数据类型</strong>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li>
<li>如果在<strong>数组</strong>初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
<p>如果类字段的字段属性表中存在ConstantValue属性（同时被final和static修饰），那在准备阶段变量value就会被初始化为ConstantValue 属性所指定的值，假设类变量value被定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为123。</p>
<blockquote>
<p>初始值一般指零值，真正给类变量赋规定的值的putstatic指令，是在类构造器<clinit>()方法中，在类的初始化阶段才会进行。<br>特殊情况下，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量会被初始化为ConstantValue指定的值</clinit></p>
</blockquote>
<h4 id="2-4-解析"><a href="#2-4-解析" class="headerlink" title="2.4 解析"></a>2.4 <strong>解析</strong></h4><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240401093246621.png" style="zoom:80%;"> 

<p>解析阶段是虚拟机<strong>将常量池内的符号引用替换为直接引用</strong>的过程。<strong>符号引用</strong>就是一组符号来描述目标，可以是任何字面量；<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。下面将讲解前面4种引用的解析过程。</p>
<ul>
<li><strong>类或接口的解析</strong></li>
</ul>
<p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机需要以下3个步骤：</p>
<p>（1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。</p>
<p>（2）如果C是一个数组类型，并且数组的元素类型为对象，那将会按照第1点的规则加载数组元素类型。</p>
<p>（3）如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。</p>
<ul>
<li><strong>字段解析</strong></li>
</ul>
<p>要解析一个未被解析过的字段符号引用，首先将会对字段所属的类或接口的符号引用进行解析。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：</p>
<p>（1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>（2）否则，如果在C中实现了接口，就会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>（3）否则，如果C不是java.lang.Object的话，就会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>（4）否则，查找失败，抛出<strong>java.lang.NoSuchFieldError</strong>异常。</p>
<p>最后，如果查找过程成功返回了直接引用，就会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出<strong>java.lang.IllegalAccessError</strong>异常。</p>
<ul>
<li><strong>类方法解析</strong></li>
</ul>
<p>类方法解析也需要先解析出类方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索：</p>
<p>（1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现C是个接口，直接抛出异常。</p>
<p>（2）否则，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>（3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>（4）否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，查找结束，抛出异常。</p>
<p>（5）否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</p>
<p>最后，如果查找过程成功返回了直接引用，就会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出<code>java.lang.IllegalAccessError</code>异常。</p>
<ul>
<li><strong>接口方法解析</strong></li>
</ul>
<p>接口方法解析也需要先解析出接口方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p>
<p>（1）如果在接口方法表中发现C是个类而不是接口，直接抛出异常。</p>
<p>（2）否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>（3）否则，在接口C的父接口中递归查找，直到java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>（4）否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</p>
<p>由于接口中的所有方法默认都是<code>public</code>的，所以不存在访问权限的问题。</p>
<h4 id="2-5-初始化"><a href="#2-5-初始化" class="headerlink" title="2.5 初始化"></a><strong>2.5 初始化</strong></h4><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240401094732841.png" style="zoom:80%;"> 

<p>初始化是指<strong>为类的静态变量赋予正确的初始值</strong>，JVM负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式：</p>
<p>（1）声明类变量时指定初始值；</p>
<p>（2）使用静态代码块为类变量指定初始值。</p>
<p>JVM初始化步骤：</p>
<p>（1）假如这个类还没有被加载和连接，则程序先加载并连接该类；</p>
<p>（2）假如该类的直接父类还没有被初始化，则先初始化其直接父类；</p>
<p>（3）假如类中有初始化语句，则系统依次执行这些初始化语句。</p>
<p>类初始化时机：只有当对类主动使用的时候才会导致类的初始化，类的主动使用包括以下6种：</p>
<ul>
<li>创建类的实例，也就是new的方式；</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值；</li>
<li>调用类的静态方法；</li>
<li>反射（如Class.forName(“…”)）；</li>
<li>初始化某个类的子类，则其父类也会被初始化；</li>
<li>Java虚拟机启动时被标明为启动类的类，直接使用java.exe命令来运行某个主类。</li>
</ul>
<blockquote>
<p>初始化是类加载过程最后一个步骤，真正开始执行类中编写的 Java 代码，将主导权移交给 Java 程序。<br>执行类构造器 <code>&lt;clinit&gt;()</code> 方法，这是 javac 编译器的自动生成物，由编译器自动收集类中所有类变量的赋值动作和静态语句块(static) 中的语句合并产生。编译器收集的顺序由语句在源文件中出现的顺序决定，静态语句块只能访问到定义静态语句块之前的变量，定义在他之后的变量，静态语句块只能赋值，不能访问。<br><code>&lt;clinit&gt;()</code> 方法不用显式的调用父类构造器，虚拟机会保证父类 <code>&lt;clint&gt;()</code> 在子类执行前已经执行完毕。<br>执行接口的方法不需要先执行父接口 的方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。<br>同一个类加载器下，一个类型只会被初始化一次。</p>
</blockquote>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载阶段中“通过一个类的全限定名获取描述类的二进制字节流”这个动作放到虚拟机外部去实现，以便让应用程序自己决定如何让获取所需的类。实现这个动作的代码称为“类加载器”</p>
<p>&#x3D;&#x3D;如何确定类的唯一性？&#x3D;&#x3D;</p>
<ul>
<li><p>任意一个类，都必须由加载他的【类加载器】和这个【类本身】一起确立唯一性</p>
</li>
<li><p>每个类加载器，都有一个独立的类名称空间</p>
</li>
<li><p>比较两个类是否相等，只有这两个类由同一个类加载器加载的前提下才有意义，否则一定不相等</p>
</li>
</ul>
<p>&#x3D;&#x3D;三层类加载器：&#x3D;&#x3D;</p>
<ul>
<li><p>启动类加载器（Bootstrap ClassLoader）:</p>
<ul>
<li><p>由C++实现，是虚拟机的一部分。负责加载存放在&lt; JAVA_HOME&gt;\bin目录，或者被-Xbootclasspath参数指定路径中存放的，而且虚拟机能识别的类库，加载到虚拟机内存中。</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）：<br>加载&lt; JAVA_HOME&gt;\lib\ext目录，或者被java.ext.dirs系统变量指定路径中所有的类库。这是Java系统类库的扩展机制，开发者可以直接在程序中使用扩展类加载器加载Class文件<br>应用程序类加载器（Application ClassLoader）：<br>加载用户类路径（ClassPath）上所有类库</p>
</li>
</ul>
</li>
</ul>
<p><strong>双亲委派模型</strong><br>如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器区完成，每一层次的类加载器都是如此，因此所有的加载请求最终传送到顶层的启动类加载器，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类），子类加载器才会尝试自己加载</p>
<p><strong>破坏双亲委派模型</strong><br>双亲委派模型解决了各个类加载器协作时基础类型的一致性问题（越基础的类越由上层加载器加载）。<br>基础类型要调用回用户的代码：线程上下文加载器，通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，默认是应用程序类加载器。<br>JNDI服务使用线程上下文类加载器加载所需SPI服务代码，即父类加载器请求子类加载器完成类加载动作</p>
<h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h2><h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p><strong>动态连接</strong><br>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，为了支持方法调用过程中的动态连接</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用阶段的唯一任务就是<strong>确定被调用方法的版本</strong>，暂时未涉及方法内部的具体运行过程<br><strong>解析</strong><br>调用目标在程序代码写好、编译器进行编译的那一刻就已经确定下来了，这类方法的调用成为解析</p>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 王才雨
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
