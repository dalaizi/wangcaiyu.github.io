<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>深入理解Java虚拟机 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="深入理解Java虚拟机 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="IELTS WritingTask 1Introduction -&gt; Overview -&gt; Detail -&gt; Detail (No Conclusion and opinions!) Notes: 时态不要错！！  PS: 看 便便 的两个 pdf 小作文模板  上升： v rise - rose - risen - rising	n rise v increase - in">
<meta property="og:type" content="article">
<meta property="og:title" content="IELTS Writing">
<meta property="og:url" content="http://example.com/2024/10/10/IELTS-Writing/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="IELTS WritingTask 1Introduction -&gt; Overview -&gt; Detail -&gt; Detail (No Conclusion and opinions!) Notes: 时态不要错！！  PS: 看 便便 的两个 pdf 小作文模板  上升： v rise - rose - risen - rising	n rise v increase - in">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903143929000.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240912122709201.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903154014772.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903170338309.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241008162149573.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903221950372.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240908183744208.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240909115534553.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241006134635925.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/36195076c5bf4f8798d6a3a1a7e8b009.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004223753876.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241003185429807.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241003190448385.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004194259889.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222854805.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222634264.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222706508.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004223109519.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222732028.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222806949.png">
<meta property="article:published_time" content="2024-10-10T07:06:24.000Z">
<meta property="article:modified_time" content="2024-10-10T07:07:10.746Z">
<meta property="article:author" content="王才雨">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903143929000.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>王才雨</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/dalaizi"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:1935863093@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1935863093&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(19)</small>
            
        </div>
    </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="19">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All "
           href="/2024/11/18/Netty/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Netty">Netty</span>
            <span class="post-date" title="2024-11-18 09:00:27">2024/11/18</span>
        </a>
        
        
        <a  class="All "
           href="/2024/10/10/IELTS-Writing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IELTS Writing">IELTS Writing</span>
            <span class="post-date" title="2024-10-10 15:06:24">2024/10/10</span>
        </a>
        
        
        <a  class="All "
           href="/2024/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="操作系统">操作系统</span>
            <span class="post-date" title="2024-04-18 11:20:09">2024/04/18</span>
        </a>
        
        
        <a  class="All "
           href="/2024/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RPC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解RPC">深入理解RPC</span>
            <span class="post-date" title="2024-04-03 13:06:31">2024/04/03</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <span class="post-date" title="2024-03-29 21:02:25">2024/03/29</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/20/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UNIX网络编程">UNIX网络编程</span>
            <span class="post-date" title="2024-03-20 15:03:46">2024/03/20</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/17/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2024-03-17 00:40:34">2024/03/17</span>
        </a>
        
        
        <a  class="All "
           href="/2024/02/25/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="后端开发面试题">后端开发面试题</span>
            <span class="post-date" title="2024-02-25 15:47:51">2024/02/25</span>
        </a>
        
        
        <a  class="All "
           href="/2024/01/05/Linux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux">Linux</span>
            <span class="post-date" title="2024-01-05 13:29:00">2024/01/05</span>
        </a>
        
        
        <a  class="All "
           href="/2023/11/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="力扣刷题">力扣刷题</span>
            <span class="post-date" title="2023-11-22 17:10:44">2023/11/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="动态代理">动态代理</span>
            <span class="post-date" title="2023-10-08 22:49:01">2023/10/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/04/08/%E9%A1%B9%E7%9B%AERPC%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="项目RPC框架">项目RPC框架</span>
            <span class="post-date" title="2023-04-08 19:49:23">2023/04/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/02/redis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="redis">redis</span>
            <span class="post-date" title="2023-01-02 17:46:17">2023/01/02</span>
        </a>
        
        
        <a  class="All "
           href="/2022/12/24/MySQL/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL">MySQL</span>
            <span class="post-date" title="2022-12-24 11:40:50">2022/12/24</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java并发编程">Java并发编程</span>
            <span class="post-date" title="2022-11-11 16:20:42">2022/11/11</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/30/JVM%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM调优">JVM调优</span>
            <span class="post-date" title="2022-10-30 20:09:07">2022/10/30</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解Java虚拟机">深入理解Java虚拟机</span>
            <span class="post-date" title="2022-10-19 10:40:02">2022/10/19</span>
        </a>
        
        
        <a  class="All "
           href="/2022/06/04/Java%E7%9F%A5%E8%AF%86%E7%82%B9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java知识点">Java知识点</span>
            <span class="post-date" title="2022-06-04 10:58:21">2022/06/04</span>
        </a>
        
        
        <a  class="All "
           href="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络">计算机网络</span>
            <span class="post-date" title="2022-02-06 18:11:21">2022/02/06</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-深入理解Java虚拟机" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">深入理解Java虚拟机</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2025-01-03 16:10:06'>2022-10-19 10:40</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-text">深入理解 Java 虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">第二章 Java内存区域与内存溢出异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%EF%BC%88JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-text">1. 运行时数据区域（JVM 内存结构）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%EF%BC%89"><span class="toc-text">1.1 程序计数器（线程私有）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;1.2 虚拟机栈（线程私有）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-text">1.3 本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%A0%86%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;1.4 堆（线程共享）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;1.5 方法区（线程共享）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-text">1.6 直接内存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-text">2. Java 内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">3.1 对象的创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">3.2 对象的内存布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D"><span class="toc-text">3.3 对象的访问定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-text">第三章 垃圾收集器与内存分配策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E6%AD%BB%E4%BA%A1"><span class="toc-text">1.判断对象是否死亡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-text">1.1 引用计数法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">1.2 可达性分析算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">1.3 引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-text">1.4 回收方法区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-text">2. 垃圾收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%90%86%E8%AE%BA"><span class="toc-text">2.1 分代收集理论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-text">2.2 标记-清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-text">2.3 标记-复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">2.4 标记-整理算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-HotSpot%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-text">3. HotSpot算法实现细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B8%E5%9E%8B%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">4. 典型的垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial"><span class="toc-text">Serial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PerNew"><span class="toc-text">PerNew</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">Parallel Scavenge收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">Serial Old收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">Parallel Old收集器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS"><span class="toc-text">&#x3D;&#x3D;CMS&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-text">&#x3D;&#x3D;G1收集器&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-text">5. 垃圾收集器的权衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%EF%BC%88%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;6. 内存分配与回收策略（重要）&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E3%80%81%E4%BA%94%E7%AB%A0-JVM%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%8F%8A%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98"><span class="toc-text">第四、五章 JVM监控和故障处理及内存调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">第六章 类文件结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%85%B3%E6%80%A7%E5%9F%BA%E7%9F%B3"><span class="toc-text">无关性基石</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-text">Class文件结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%88%E8%BF%98%E6%9C%AA%E5%AE%8C%E5%85%A8%E7%90%86%E8%A7%A3%EF%BC%8C%E6%9C%89%E6%97%B6%E9%97%B4%E8%A1%A5%EF%BC%89"><span class="toc-text">第七章 虚拟机类加载机制（还未完全理解，有时间补）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-text">类加载过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-text">加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-text">解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BF%85%E9%A1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="toc-text">什么时候必须初始化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%86%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%E4%B8%8E-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E8%BF%87%E7%A8%8B"><span class="toc-text">区分：类加载过程 与 创建对象过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-text">3. 类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">双亲委派模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-text">破坏双亲委派模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="toc-text">虚拟机字节码执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="toc-text">运行时栈帧结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-text">方法调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-text">&#x3D;&#x3D;谈谈你对多态的理解&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9F"><span class="toc-text">1. 什么是多态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%EF%BC%9F"><span class="toc-text">2. 如何实现多态？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">3. 多态的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4. 实际应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%9A%E6%80%81%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">5. 多态的注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">1. 动态绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%88vtable%EF%BC%89"><span class="toc-text">2. 虚函数表（vtable）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">虚函数表的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">调用过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E8%A1%A8%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-text">虚表的动态性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AF%AD%E8%A8%80%E6%94%AF%E6%8C%81"><span class="toc-text">3. 语言支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A-vs-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-text">4. 静态绑定 vs 动态绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">5. 优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="深入理解-Java-虚拟机"><a href="#深入理解-Java-虚拟机" class="headerlink" title="深入理解 Java 虚拟机"></a>深入理解 Java 虚拟机</h1><h2 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 Java内存区域与内存溢出异常"></a>第二章 Java内存区域与内存溢出异常</h2><h3 id="1-运行时数据区域（JVM-内存结构）"><a href="#1-运行时数据区域（JVM-内存结构）" class="headerlink" title="1. 运行时数据区域（JVM 内存结构）"></a>1. 运行时数据区域（JVM 内存结构）</h3><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240220002259810.png" style="zoom:50%;">

<h4 id="1-1-程序计数器（线程私有）"><a href="#1-1-程序计数器（线程私有）" class="headerlink" title="1.1 程序计数器（线程私有）"></a>1.1 <strong>程序计数器</strong>（线程私有）</h4><p>是一块较小的内存空间，可以理解为<strong>当前线程所执行的字节码行号指示器</strong>，字节码解释器的工作就是通过改变这个计数器的值选取下一条要执行的字节码指令。</p>
<p>虚拟机的多线程通过线程轮流切换、分配处理器执行时间来实现，任意时刻一个内核只会执行一条线程中的指令。因此，为了线程切换后能恢复正确的执行位置，每个线程需要各自享有一个独立的程序计数器。</p>
<p>如果线程执行的是一个 Java 方法，计数器记录的是正在执行的虚拟机字节码指令的地址；如果是本地方法，PC计数器为空。</p>
<p>不会出现 OOM 错误</p>
<h4 id="1-2-虚拟机栈（线程私有）"><a href="#1-2-虚拟机栈（线程私有）" class="headerlink" title="&#x3D;&#x3D;1.2 虚拟机栈（线程私有）&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.2 <strong>虚拟机栈（线程私有）</strong>&#x3D;&#x3D;</h4><p> 每个线程单独享有一个虚拟机栈，栈中的元素是<strong>栈帧</strong>，栈帧中包含<strong>局部变量表、操作数栈、动态连接、方法出口</strong>等信息，<strong>一个方法从调用到结束对应着栈帧的入栈和出栈</strong>。</p>
<p><strong>局部变量表</strong>存储了基本数据类型、引用类型、returnAddress 类型，存储以 Slot 为单位。<strong>每个方法要用栈帧中局部变量表多大的空间编译时就确定了</strong>，运行时不会改变。但是注意，空间指的槽的数量，槽的大小由虚拟机自行决定。</p>
<p>虚拟机栈可能出现两种异常情况：</p>
<ul>
<li>如果<strong>线程申请的虚拟机栈的深度大于虚拟机允许的最大空间</strong>，会造成**<code>StackOverflowError</code>**；</li>
<li>如果虚拟机栈容量是可拓展的，那么在栈拓展过程中遇到本机内存空间不够的情况，会 <strong>OOM</strong> 的错误（HotSpot 默认栈不可拓展）</li>
</ul>
<h4 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 <strong>本地方法栈</strong></h4><p>它的作用和虚拟机栈类似，只是为本地方法服务，由 C&#x2F;C++ 编写。在本地方法栈中，主要存放了 native 方法的局部变量、动态链接和方法出口等信息。当一个 Java 程序调用一个 native 方法时，JVM 会切换到本地方法栈来执行这个方法。</p>
<p>当 Java 应用需要与操作系统底层或硬件交互时，通常会用到本地方法栈。比如调用操作系统的特定功能，如内存管理、文件操作、系统时间、系统调用等。</p>
<p>比如 JVM 自身的一些底层功能也需要通过本地方法来实现。像 Object 类中的 <code>hashCode()</code> 方法、<code>clone()</code> 方法等。</p>
<h4 id="1-4-堆（线程共享）"><a href="#1-4-堆（线程共享）" class="headerlink" title="&#x3D;&#x3D;1.4 堆（线程共享）&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.4 <strong>堆（线程共享）</strong>&#x3D;&#x3D;</h4><p>Java 堆是线程共享的，他是<strong>所有对象实例和数组创建的地方</strong>。</p>
<p>堆中的内存可以不是物理连续，但一定要是逻辑连续的，但是在遇到大对象的创建时（例如大数组对象）HotSpot 也会要求物理连续来节省内存访问与分配的开销。</p>
<p>java堆虽然是线程共享的，但是为了节省分配新对象的开销，我们可能会在堆中划分出<strong>多个线程私有的分配缓冲区（TLAB）</strong>，从而解决线程不安全的问题。</p>
<p>堆既可以被实现成固定大小的，也可以是可扩展的，主流的 Java 虚拟机可扩展来（通过参数 -Xmx 和 -Xms 设定）。如果在堆中没有内存完成实例分配，并且堆也不能再扩展时，抛出 OOM 异常。</p>
<p>从内存回收的角度来看，由于垃圾收集器大部分都是基于分代收集理论设计的，所以堆也会被划分为<code>新生代</code>、<code>老年代</code>、<code>Eden空间</code>、<code>From Survivor空间</code>、<code>To Survivor空间</code>等。</p>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241209164135725.png" style="zoom:50%;">

<p>随着 <a target="_blank" rel="noopener" href="https://javabetter.cn/jvm/jit.html">JIT 编译器</a>的发展和逃逸技术的逐渐成熟，“所有的对象都会分配到堆上”就不再那么绝对了。</p>
<p>从 JDK 7 开始，JVM 已经默认开启逃逸分析了，意味着如果某些方法中的对象引用没有被返回或者未被方法体外使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
<h4 id="1-5-方法区（线程共享）"><a href="#1-5-方法区（线程共享）" class="headerlink" title="&#x3D;&#x3D;1.5 方法区（线程共享）&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.5 <strong>方法区</strong>（线程共享）&#x3D;&#x3D;</h4><p>方法区用来存储已经被虚拟机已加载的 <strong>类型信息</strong>、<strong>静态变量(static)</strong> 以及 **常量(static final)**、即时编译后的 <strong>代码缓存</strong> 等信息。虽然《Java 虚拟机规范》中把方法区描述为堆的逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区分开来。</p>
<table>
<thead>
<tr>
<th></th>
<th>永久代</th>
<th>元空间</th>
</tr>
</thead>
<tbody><tr>
<td>JVM版本</td>
<td>8之前</td>
<td>8开始</td>
</tr>
<tr>
<td>存储内容</td>
<td>类元数据、常量池、静态变量等</td>
<td>同</td>
</tr>
<tr>
<td>内存限制</td>
<td>固定大小，使用<code>-XX:MaxPermSize</code>指定</td>
<td>动态扩展，使用本地内存</td>
</tr>
<tr>
<td>垃圾回收</td>
<td>在Full GC时回收</td>
<td>自动回收，使用不同的策略</td>
</tr>
<tr>
<td>内存来源</td>
<td>堆</td>
<td>本地内存</td>
</tr>
<tr>
<td>问题</td>
<td>容易导致<code>OutOfMemoryError: PermGen space</code></td>
<td>使用本地内存，只有系统内存不足时才可能导致问题</td>
</tr>
</tbody></table>
<p>在 JDK8 以前，我们用永久代来实现方法区，实际上也是把垃圾收集器的分代设计拓展到方法区。之后我们利用元空间实现方法区。元空间来自本地内存，所以这样设计不容易内存溢出。</p>
<p><strong>运行时常量池</strong></p>
<ul>
<li><p>运行时常量池（Runtime Constant Pool）是<strong>方法区</strong>的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有的<strong>常量池表</strong>，用来存储编译生成的各种<strong>字面量</strong>和<strong>符号引用</strong>。这些内容会在类加载之后存放在<strong>运行时常量池</strong>中。除此保存Class文件中描述的符号引用外，它还把由符号引用翻译出来的<strong>直接引用</strong>也存在里面。</p>
</li>
<li><p>相较于 Class 文件常量池表，运行时常量池有<strong>动态性</strong>，在程序运行过程中也可以向常量池表中添加新常量。</p>
</li>
</ul>
<h4 id="1-6-直接内存"><a href="#1-6-直接内存" class="headerlink" title="1.6 直接内存"></a>1.6 <strong>直接内存</strong></h4><p>直接内存不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p>本机直接内存的分配不会受到 Java堆 大小的限制，但是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置 -Xmx 等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现OutOfMemoryError异常。</p>
<h3 id="2-Java-内存模型"><a href="#2-Java-内存模型" class="headerlink" title="2. Java 内存模型"></a>2. Java 内存模型</h3><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38348646">https://zhuanlan.zhihu.com/p/38348646</a></p>
<p>由上述对 JVM 内存结构的描述中，我们知道了堆和方法区是线程共享的。而局部变量，方法定义参数和异常处理器参数就不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</p>
<p>Java 线程之间的通信由 Java 内存模型（JMM）控制，<strong>JMM 决定一个线程对共享变量的写入何时对另一个线程可见</strong>。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：</p>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/v2-b098a84eb7598d70913444a991d1759b_1440w.webp" alt="img"></p>
<p>从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤：</p>
<ol>
<li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。</li>
<li>然后，线程B到主内存中去读取线程A之前已更新过的共享变量。</li>
</ol>
<p>下面通过示意图来说明这两个步骤：</p>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/v2-2c452d147bf0d09b14b770d3990740cb_1440w.webp" alt="img"></p>
<p>如上图所示，本地内存A和B有主内存中共享变量x的副本。假设初始时，这三个内存中的x值都为0。线程A在执行时，把更新后的x值（假设值为1）临时存放在自己的本地内存A中。当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时主内存中的x值变为了1。随后，线程B到主内存中去读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1。</p>
<p>从整体来看，这两个步骤实质上是线程A在向线程B发送消息，而且这个通信过程必须要经过主内存。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。</p>
<p><strong>重排序</strong></p>
<p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。</p>
<p>这里说的重排序可以发生在好几个地方：编译器、运行时、JIT等，比如编译器会觉得把一个变量的写操作放在最后会更有效率，编译后，这个指令就在最后了（前提是只要不改变程序的语义，编译器、执行器就可以这样自由的随意优化），一旦编译器对某个变量的写操作进行优化（放到最后），那么在执行之前，另一个线程将不会看到这个执行结果。</p>
<p>当然了，写入动作可能被移到后面，那也有可能被挪到了前面，这样的“优化”有什么影响呢？这种情况下，其它线程可能会在程序实现“发生”之前，看到这个写入动作（这里怎么理解，指令已经执行了，但是在代码层面还没执行到）。通过内存屏障的功能，我们可以禁止一些不必要、或者会带来负面影响的重排序优化，在内存模型的范围内，实现更高的性能，同时保证程序的正确性。</p>
<p>下面我们来看一个重排序的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Reordering &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> y;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假设这段代码有2个线程并发执行，线程A执行writer方法，线程B执行reader方法，线程B看到y的值为2，因为把y设置成2发生在变量x的写入之后（代码层面），所以能断定线程B这时看到的x就是1吗？</p>
<p>当然不行！ 因为在writer方法中，可能发生了重排序，y的写入动作可能发在x写入之前，这种情况下，线程B就有可能看到x的值还是0。</p>
<p>在Java内存模型中，描述了在多线程代码中，哪些行为是正确的、合法的，以及多线程之间如何进行通信，代码中变量的读写行为如何反应到内存、CPU缓存的底层细节。</p>
<p>在Java中包含了几个关键字：volatile、final和synchronized，帮助程序员把代码中的并发需求描述给编译器。JMM中定义了它们的行为，确保正确同步的Java代码在所有的处理器架构上都能正确执行。</p>
<p><strong>总结</strong></p>
<ol>
<li><p>内存模型是考察coder对一门语言的理解能力，从而进一步延伸到对JVM优化，和平时学习的深度上，是Java面试中最重要的一部分。</p>
</li>
<li><p>并发产生的bug非常难以调试，通常在测试代码中难以复现，当系统负载上来之后，一旦发生，又很难去捕捉，为了确保程序能够在任意环境正确的执行，最好是提前花点时间好好思考，虽然很难，但还是比调试一个线上bug来得容易的多。</p>
</li>
</ol>
<h3 id="3-对象"><a href="#3-对象" class="headerlink" title="3. 对象"></a>3. 对象</h3><h4 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h4><ul>
<li>首先，虚拟机遇到一条字节码new指令时，会首先去检查<strong>这个指令的参数能否在常量池中定位到一个类的符号引用</strong>，并检查这个符号引用代表的类是否被加载解析初始化过了，要是没有就先执行类的加载过程</li>
<li>然后，在类加载检查通过后，虚拟机为新对象在堆中分配内存（所需大小在类加载完成过后便可确定）。有两种分配方式：<br><strong>指针碰撞</strong>：<br>内存规整，用过的和没用过的内存各自分开，中间用指针作为分界点指示器，分配内存就是把指针往空闲空间方向移动一段与对象大小相等的距离。<br><strong>空闲列表</strong>：<br>记录那些内存可用<br>举个栗子1.Serial，ParNew自带压缩整理，内存分配算法用的是碰撞指针，简单高效<br>2.CMS基于清除算法，空间杂乱。为了对象分配更快，设计了叫Linear Allocation Buffer 的分配缓冲区，利用空闲列表得到一大块分配缓冲区后，在里面仍然可以用指针碰撞来分配。</li>
<li>内存分配完成后，给除了对象头外的内存空间初始化为<strong>零值</strong>.如果 使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用</li>
<li>接下来，对对象头进行必要的设置，例如他的类元信息、对象的哈希码（实际上用到Object::hashCode()才会计算）、对象的GC分代年龄信息等</li>
<li>执行<code>\&lt;init&gt;()</code>方法，即构造函数（对于程序来说这才是真正的创建对象）</li>
</ul>
<h4 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h4><p><strong>（1）对象头</strong></p>
<p>1.储存对象自身的<strong>运行时数据</strong>，包括哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</p>
<p>2.类型指针，即对象指向它的类型元数据的指针。如果对象是数组，对象头还要记录数组长度</p>
<p><strong>（2）实例数据</strong></p>
<p>对象真正存储的有效信息，父类和子类的字段。相同宽度的字段总是分配到一起存放，在满足这个条件的前提下，父类变量会出现在子类前。如果-XX ：Compact Fields 参数为true，那子类之中较窄的变量也能插入父类变量的空隙中，以节省空间</p>
<p><strong>（3）对齐填充</strong></p>
<p>占位符，任何对象的大小必须是8字节的整数倍</p>
<h4 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h4><p><strong>句柄引用访问</strong><br>线程的虚拟机栈的栈帧中的本地变量表的reference类型数据，它存放的并不是在堆中的对象实例本身，而是指向了一个句柄池。句柄池存放着类类型指针和对象实例指针。这样通过二次访问的方式我们找到对象实例，但是访问效率肯定不如直接访问高。<br>垃圾回收进行对象实例位置移动是很常见的现象，而移动对象只需要改变句柄指针的内容，而不用改变reference的值，这是句柄访问的优点</p>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241209145643888.png" style="zoom: 45%;">

<p><strong>直接指针访问</strong><br>对象的布局分布必须考虑存放访问类型数据的相关信息，reference存的直接就是对象地址。速度快，节省了一次指针定位的时间开销</p>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241209145725235.png" style="zoom:45%;">

<h2 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h2><p>GC 要做三件事，<strong>哪些内存需要回收</strong>（对象是否死亡）、<strong>什么时候回收</strong>、<strong>怎么回收</strong>（回收算法）。</p>
<p>第2章介绍了 Java 内存运行时区域的各个部分，其中<strong>程序计数器、虚拟机栈、本地方法栈</strong>3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。因此这几个区域的内存分配和回收都具备确定性， 在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。</p>
<h3 id="1-判断对象是否死亡"><a href="#1-判断对象是否死亡" class="headerlink" title="1.判断对象是否死亡"></a>1.判断对象是否死亡</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 <strong>引用计数法</strong></h4><p>对象中添加引用计数器，每当有一个地方引用它，计数器加一，引用失效，计数器减一。计数器为零的对象可被回收。原理简单，判定效率高。</p>
<p>&#x3D;&#x3D;问题：无法解决对象之间循环引用的问题&#x3D;&#x3D;，比如两个垃圾相互引用，那他们永远都不会被回收</p>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240410232623493.png" alt="image-20240410232623493" style="zoom:50%;"> 

<h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 <strong>可达性分析算法</strong></h4><p>从一系列 <code>GC Roots</code> 根对象，按照引用关系向下搜索，搜索过程走过的路径为<strong>引用链</strong>，如果某个对象到 GC Roots 间没有任何引用链相连，证明对象是垃圾</p>
<p><code>GC Roots</code>对象可以是</p>
<ul>
<li>虚拟机栈（<strong>栈帧中的本地变量表</strong>）中引用的对象，例如各个线程被调用的方法堆栈中的参数、局部变量、临时变量等</li>
<li><strong>方法区中静态属性、常量</strong>引用的对象。例如字符串常量池中的引用</li>
<li>被 <strong>同步锁(synchronized)持有</strong> 的对象</li>
<li>虚拟机内部的引用，如基本数据类型对应的 Class 对象，异常对象（<code>NullPointException</code> <code>OutOffMemoryError</code>） 系统类加载器</li>
</ul>
<p>宣告对象死亡需要 两个标记过程：</p>
<ol>
<li><p>如果对象在可达性分析后发现没有和 GC Roots 相连的引用链，那会被第一次标记</p>
</li>
<li><p>然后再一次筛选，筛选的条件是是否有必要执行 <code>finalize() </code>方法</p>
<p>2.1 如果对象没有覆盖 <code>finalize()</code> 方法，或 <code>finalize()</code> 方法已经被调用过一次，那么方法不会被执行，对象死亡</p>
<p>2.2 如果对象有必要执行 <code>finalize()</code> 方法，则会被放置在 F-Queue 队列中，由虚拟机自动创建的、低调度优先级的 Finalizer 线程去执行 Finalize() 方法，看能否自救成功（比如把 this 赋值给某个成员变量）</p>
</li>
</ol>
<h4 id="1-3-引用类型"><a href="#1-3-引用类型" class="headerlink" title="1.3 引用类型"></a>1.3 引用类型</h4><ul>
<li>强引用<ul>
<li>即普遍存在的引用赋值，强引用的对象不会回收</li>
</ul>
</li>
<li>软引用<ul>
<li>描述有用但非必须的对象，内存不够时回收，SoftReference 类实现软引用</li>
</ul>
</li>
<li>弱引用<ul>
<li>描述非必须对象，发生GC时会被回收，WeakReference 类实现弱引用</li>
</ul>
</li>
<li>虚引用<ul>
<li>唯一作用对象被回收时得到一个系统通知，不能通过虚引用得到实例，PhantomReference 类实现虚引用</li>
</ul>
</li>
</ul>
<h4 id="1-4-回收方法区"><a href="#1-4-回收方法区" class="headerlink" title="1.4 回收方法区"></a>1.4 回收方法区</h4><p>方法区的垃圾收集主要回收两部分内容：<em>废弃的<strong>常量</strong></em> 和<em>不再使用的<strong>类型</strong></em>。回收废弃常量与回收 Java 堆中的对象非常类似。</p>
<p>判定一个<strong>常量</strong>是否“废弃”还是相对简单，而要判定一个<strong>类型</strong>是否属于 “不再被使用的类” 的条件就比较苛刻了。需要同时满足下面三个条件:</p>
<p>（1）<strong>该类所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例；</p>
<p>（2）<strong>加载该类的类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</p>
<p>（3）<strong>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</strong></p>
<h3 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h3><h4 id="2-1-分代收集理论"><a href="#2-1-分代收集理论" class="headerlink" title="2.1 分代收集理论"></a>2.1 <strong>分代收集理论</strong></h4><p>（1）弱分代假说：绝大多数对象朝生夕灭</p>
<p>（2）强分代假说：熬过多次垃圾收集的对象难以消灭</p>
<p>（3）跨代引用假说：跨代引用相对于同代引用占极少数，即存在相互引用关系的两个对象，倾向于同时生存、同时消亡</p>
<blockquote>
<p>所以，不用为了少量的跨代引用去扫描整个老年代，也不用浪费空间专门记录每个对象是否存在以及存在哪些跨代引用。</p>
<p>只需在新生代上建立一个全局数据结构 <strong>记忆集</strong> ，该结构把老年代划分成若干小块，标识老年代哪块有跨代引用。</p>
<p>MinorGC 时，只将包含跨代引用的内存的对象加入 GC Roots扫描，虽然引用关系改变时有维护开销，但比每次扫描整个老年代要划算</p>
</blockquote>
<h4 id="2-2-标记-清除算法"><a href="#2-2-标记-清除算法" class="headerlink" title="2.2 标记-清除算法"></a>2.2 <strong>标记-清除算法</strong></h4><p>（1）&#x3D;&#x3D;标记&#x3D;&#x3D;：标记出要回收的对象</p>
<p>（2）&#x3D;&#x3D;清除&#x3D;&#x3D;：回收掉标记的对象</p>
<p><strong>缺点：</strong></p>
<ul>
<li>&#x3D;&#x3D;执行效率不稳定&#x3D;&#x3D;，如果堆中包含大量对象并且大部分要回收，会进行大量的标记和清除动作，&#x3D;&#x3D;执行效率随对象数量增长而降低&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;内存空间碎片化&#x3D;&#x3D;，以后分配大对象可能无法找到连续的内存而触发另一次垃圾回收</li>
</ul>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307101808110.png"></p>
<h4 id="2-3-标记-复制算法"><a href="#2-3-标记-复制算法" class="headerlink" title="2.3 标记-复制算法"></a>2.3 <strong>标记-复制算法</strong></h4><p>为解决<strong>面对大量可回收对象执行效率低</strong>问题，提出“半区复制”，将可用内存按容量划分成两块，将存活对象复制到另外一块，然后已使用的内存空间清理掉</p>
<p><strong>优点：</strong></p>
<ul>
<li>对于<strong>多数对象都是可回收的情况</strong>，复制少数存活对象性能好</li>
<li>因为针对半区进行内存回收，不会出现<strong>空间碎片</strong></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>如果<strong>大多数对象存活，复制开销大</strong></li>
<li><strong>浪费一半空间</strong>，如果不想浪费50%空间，就要<strong>分配担保</strong></li>
</ul>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307102148014.png"></p>
<blockquote>
<p>复制算法实现新生代，分成Eden区和两块Survivor区，比例8：1：1</p>
<p>每次分配内存只使用Eden和一块Survivor，GC时将存活对象一次性复制到另一块Survivor（新生代可用空间为整个新生代容量的90%）</p>
<p><strong>分配担保</strong>：<strong>当Survivor空间不足以容纳一次 Minor GC 后存活的对象</strong>，需要通过分配担保机制进入老年代</p>
</blockquote>
<h4 id="2-4-标记-整理算法"><a href="#2-4-标记-整理算法" class="headerlink" title="2.4 标记-整理算法"></a>2.4 <strong>标记-整理算法</strong></h4><p>（1）&#x3D;&#x3D;标记&#x3D;&#x3D;：可回收对象</p>
<p>（2）&#x3D;&#x3D;整理&#x3D;&#x3D;：<strong>让所有存活对象向空间一端移动，然后直接清理掉边界以外的内存</strong></p>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307103904391.png"></p>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>移动存活对象</strong>并<strong>更新引用</strong>负担重，并且要全程<strong>暂停用户线程</strong>（STW）。让内存回收更复杂</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>让内存分配和访问更高效，因为<strong>没有碎片化空间</strong>。总体上虽然增加延迟，但是提高了吞吐量</li>
</ul>
<p><strong>应用场景：</strong></p>
<ul>
<li>标记-复制 算法完全不考虑移动、整理存活对象，空间碎片造成内存分配、内存访问更复杂（比如 通过“分区空闲分配链表”解决），影响系统吞吐量</li>
<li>整理存活对象——<strong>内存回收</strong>更复杂，系统吞吐量高；不整理——<strong>内存分配</strong>更复杂，GC停顿时间短</li>
<li>关注<strong>吞吐量</strong>的<strong>Parallel Scavenge</strong>使用整理算法；关注<strong>延迟</strong>的<strong>CMS</strong>使用复制算法</li>
</ul>
<h3 id="3-HotSpot算法实现细节"><a href="#3-HotSpot算法实现细节" class="headerlink" title="3. HotSpot算法实现细节"></a>3. HotSpot算法实现细节</h3><p><strong>根节点枚举</strong><br>固定可作为GC Roots的节点主要在全局性的引用（常量、静态属性）和执行上下文（本地变量表）中，找到这些根节点，并不需要逐个寻找。虚拟机用OopMap数据结构记录哪些地方存在对象引用，一旦类加载动作完成时，HotSpot会把对象内什么偏移量上是什么类型的数据计算出来，即时编译过程中也在特定位置会记录下栈里和寄存器里哪些位置是引用<br><strong>安全点</strong><br>在OopMap的协助下，HotShot快速准确完成GC Roots枚举。实际上HotShot没有为每条指令都生成OopMap，而只是在特定位置记录这些信息，称为安全点。垃圾收集强制要求必须执行到安全点后才能暂停<br><strong>记忆集</strong><br>记忆集是一种用于记录从非收集区指向收集区的指针集合的抽象数据结构。收集器只需要通过记忆集判断出某一块非收集区是否存在指向收集区的指针就可以了，并不需要了解跨代指针的全部细节<br><strong>卡表</strong>定义了记忆集的记录精度、与堆内存的映射关系<br><strong>写屏障</strong><br>通过写屏障维护卡表状态，看作对“引用类型字段赋值”这个动作的AOP切面，在引用对象赋值时会产生环形通知，供程序做额外动作。直到G1出现前，其他收集器只用了写后屏障。<br>除了写屏障的开销外，卡表在高并发场景下面临“伪共享”问题。当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，会彼此影响导致性能降低。解决方法是不使用无条件的写屏障<br><strong>并发的可达性分析</strong><br>遍历对象图，采用三色标记。如果和用户线程并发，可能有两种后果：<br>1.原本消亡的对象标记成存活，产生浮动垃圾<br>2.原本存活的对象标记成消亡，不能容忍。产生条件为</p>
<blockquote>
<p>赋值器插入了一条或多条黑色到白色对象的新引用<br>删除了全部灰色到该白色对象的直接或间接引用</p>
</blockquote>
<p>解决方法：<br>1.增量更新：黑色对象一旦插入指向白色对象的引用后，就把他变成灰色。如 CMS<br>2.原始快照（SATB）：记录下删除的引用，以灰色对象为根，重新扫描一次 如 G1 Shenandoah</p>
<h3 id="4-典型的垃圾收集器"><a href="#4-典型的垃圾收集器" class="headerlink" title="4. 典型的垃圾收集器"></a>4. 典型的垃圾收集器</h3><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307105438999.png" style="zoom:67%;"> 

<h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a><strong>Serial</strong></h4><p>单线程收集器，它只会使用一个处理器或一条收集线程去完成垃圾收集工作，并且要暂停其他所有工作线程STW，知道收集结束是HotShot在<strong>客户端</strong>模式下默认的新生代收集器。与其他收集器的单线程比，简单高效，额外内存消耗最少。对于处理器核心数较少的环境来说，Serial由于没有线程交互的开销，可以得到最高的单线程收集效率。</p>
<h4 id="PerNew"><a href="#PerNew" class="headerlink" title="PerNew"></a><strong>PerNew</strong></h4><p>多线程并行收集器，运行于<strong>服务器</strong>模式下的虚拟机，可以配合CMS工作<br>服务器模式下推荐的组合，曾经是PerNew+CMS，现在是G1。现在可以理解为，PerNew合并到CMS，成为CMS专门处理新生代的组成部分</p>
<blockquote>
<p>并行（Parallel）：描述多条垃圾回收线程之间的关系。同一时间有多条回收线程协同工作，默认用户线程处于等待状态<br>并发（Concurrent）：描述垃圾回收线程和用户线程之间的关系，同一时间两种线程都在运行。由于用户线程未冻结，所以程序仍然能相应服务器请求，但由于垃圾收集线程占用了一部分系统资源，此时应用程序处理的吞吐量受影响</p>
</blockquote>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a><strong>Parallel Scavenge收集器</strong></h4><p>类似PerNew是多线程并行收集器，关注点是达到一个可控制的<strong>吞吐量</strong>（吞吐量是处理器用于运行用户代码的时间和处理器总消耗时间的比值），也叫“吞吐量优先处理器”<br>停顿时间越短，越适合需要与用户交互或需要保证服务响应质量的程序<br>高吞吐量可以高效利用处理器资源，适合在后台运算而不需要而不需要太多交互分析的任务<br>控制吞吐量的参数</p>
<blockquote>
<p>最大垃圾收集停顿时间 -XX: MaxGCPauseMillis<br>直接设置吞吐量大小 -XX: GCTimeRatio<br>自适应调节开关 -XX: +UseAdaptiveSizePolicy，动态调整新生代大小、比例，晋升老年代对象老年代大小等细节参数，以提供最合适的停顿时间或最大的吞吐量</p>
</blockquote>
<p><strong>自适应调节策略</strong>也是Parallel Scavenge区别于ParNew的重要特征</p>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a><strong>Serial Old收集器</strong></h4><p>单线程收集器，老年代，标记整理算法<br>客户端模式：和Serial结合<br>服务器模式：作为CMS收集器并发失败的后备方案</p>
<h4 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a><strong>Parallel Old收集器</strong></h4><p>多线程并行收集，老年代，标记整理算法<br>注重吞吐量或处理器资源比较稀缺时，可以考虑 Parallel Scavenge+Parallel Old</p>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="&#x3D;&#x3D;CMS&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>CMS</strong>&#x3D;&#x3D;</h4><p>第一款真正意义上<strong>支持并发</strong>的垃圾收集器，以<strong>获取最短停顿时间</strong>为目标，垃圾收集线程尽量与用户线程并发执行，减少应用停顿时间（Stop-The-World, STW）</p>
<p>应用场景：互联网网站或者基于浏览器的B&#x2F;S系统的服务器上，关注<strong>响应速度</strong>和<strong>交互体验</strong></p>
<p>CMS <code>concurrent mark swap</code>基于 <strong>标记-清除</strong> 算法实现：<br><strong>（1）初始标记</strong> <code>STW 只标记 GC Roots 能直接关联到的对象</code><br><strong>（2）并发标记</strong><code>（增量更新）从GC Roots 直接关联的对象开始遍历整个对象图的过程</code><br><strong>（3）重新标记</strong> <code>STW 修正并发标记期间，因用户程序继续运作导致标记产生变动的对象的标记记录</code><br>（4）**并发清除 **<code>由于不需要移动存活对象，可以和用户线程并发</code></p>
<p><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20230307110124989.png"></p>
<p>&#x3D;&#x3D;<strong>优点：</strong>&#x3D;&#x3D;</p>
<ul>
<li>并发收集、低停顿</li>
</ul>
<p>&#x3D;&#x3D;<strong>缺点：</strong>&#x3D;&#x3D;</p>
<ul>
<li><p>&#x3D;&#x3D;对处理器资源十分敏感&#x3D;&#x3D;。&#x3D;&#x3D;并发&#x3D;&#x3D;阶段虽然不会导致用户线程停顿，但会因为占用了一部分线程而导致应用程序变慢，&#x3D;&#x3D;降低总吞吐量&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;无法处理浮动垃圾&#x3D;&#x3D;，可能产生并发失败而导致STW的Full GC</p>
<blockquote>
<p>CMS并发标记和并发清除阶段，由于用户线程还在运行，不断产生未被标记的新垃圾，只能下一次GC再清理掉。所以 CMS 不能像其他收集器一样等到老年代几乎被填满再收集，它必须预留空间满足程序分配新对象的需要，否则就会出现并发失败<code>Concurrent Mode Failure</code>，冻结用户线程，临时启用 <code>Serial Old</code> 进行老年代垃圾收集</p>
<p>所以，参数<code>-XX:CMSInitiatingOccupancyFraction</code>设置太高然而容易因产生大量并发失败二降低性能</p>
</blockquote>
</li>
<li><p>基于 &#x3D;&#x3D;标记-清除&#x3D;&#x3D; 算法实现，产生大量内存碎片。当没用空间分配新对象时，提前触发 <code>Full GC</code></p>
</li>
</ul>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="&#x3D;&#x3D;G1收集器&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>G1收集器</strong>&#x3D;&#x3D;</h4><p>取代<code>Parallel Scavenge+Parallel Old</code>组合，成为<strong>服务端</strong>模式下的默认垃圾收集器</p>
<p><strong>&#x3D;&#x3D;Mixed GC 模式&#x3D;&#x3D;<strong>：面向堆内存任何部分来组成回收集，衡量标准不再是它属于哪一代，而是</strong>哪块内存存放的垃圾最多，回收收益最大</strong></p>
<p>开创<strong>基于Region的堆内存布局</strong>，把Java堆划分成多个大小相等的独立区域（Region），每个 Region 可以根据需要扮演 Eden、Survior、老年代。G1 根据 Region 扮演的不同角色采用 不同的处理策略。</p>
<p>Region 的 <strong><code>Humongouns</code>区域，存储大对象</strong>。大小超过 Region 一半就是大对象</p>
<blockquote>
<p><code>-XX: G1HeapRegionSize</code> 设定 Region大小（1MB- 32MB，2^N）超大对象存放于多个Humogous Region，并被视为老年代</p>
</blockquote>
<p><strong>为什么G1能建立可预测的停顿时间模型？</strong></p>
<p><strong>将Region作为单次回收的最小单元</strong>，关注Region里面垃圾堆积的<strong>价值</strong>，即回收所获得的空间大小以及回收所需时间的经验值。后台维护优先级列表，根据用户用户允许的停顿时间，优先处理那些回收收益最大的Region</p>
<p>跨Region区引用问题：<br>每个Region维护自己的记忆集，记录别的Region指向自己的指针，并标记这些指针在哪些卡页范围内。本质是哈希表，key是别的Region的起始地址，value是集合存储卡表的索引号，。由于Region数量比传统分代收集器的分代数量多，所以有更高的内存占用</p>
<p>基于标记整理算法实现：<br>1.初始标记<br>2.并发标记：原始快照（SATB）。为保证新对象分配，每个Region设计了两个TAMS指针，新分配的对象地址在两个TAMS之上，被隐式标记，默认存活<br>3.最终标记<br>4.筛选回收</p>
<p>优点：指定最大停顿时间、分Region内存布局、按收益动态确定回收集、无内存碎片<br>缺点：内存占用、额外执行负荷</p>
<h3 id="5-垃圾收集器的权衡"><a href="#5-垃圾收集器的权衡" class="headerlink" title="5. 垃圾收集器的权衡"></a>5. 垃圾收集器的权衡</h3><p>三指标： 吞吐量、延迟、内存占用<br>1.应用程序的主要关注点是什么？</p>
<blockquote>
<p>数据分析、科学计算，目标是尽快算出结果——吞吐量<br>SLA应用，停顿时间影响服务质量，严重可能导致事务超时——延迟<br>客户端应用或嵌入式应用——内存占用</p>
</blockquote>
<p>2.运行应用的基础设施如何？</p>
<blockquote>
<p>硬件规格，涉及到的系统架构是x86-32&#x2F;64、SPARC还是ARM&#x2F;Aarch64；处理器数量、分配内存大小；操作系统</p>
</blockquote>
<p>3.JDK发行商、版本</p>
<h3 id="6-内存分配与回收策略（重要）"><a href="#6-内存分配与回收策略（重要）" class="headerlink" title="&#x3D;&#x3D;6. 内存分配与回收策略（重要）&#x3D;&#x3D;"></a>&#x3D;&#x3D;6. 内存分配与回收策略（重要）&#x3D;&#x3D;</h3><p><strong>对象优先在Eden分配</strong></p>
<p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起⼀次 Minor GC。</p>
<p><strong>大对象直接进入老年代</strong></p>
<p>大对象就是指需要大量连续内存空间的 Java 对象，HotSpot 虚拟机提供 <code>-XX: PretenureSizeThreshold</code> 参数，超过该参数的对象会直接在老年代分配，从而避免 Eden 和两个 Survior 区之间来回复制，产生大量内存复制操作</p>
<p><strong>长期存活对象进入老年代</strong></p>
<p>虚拟机给每个对象定义了一个对象年龄(Age)计数器，存储在对象头中(详见第2章)。对象通常在 Eden 区里诞生，如果经过第一次 Minor  GC 后仍然存活，并且能被 Survivor 容纳的话，该对象会被移动到 Survivor 空间中，并且将其对象年龄设为1岁。对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 设置。</p>
<p><strong>动态对象年龄判断：</strong></p>
<p>虚拟机并不永远要求对象的年龄必须达到 <code>-XX: MaxTenuringThreshold</code> 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 <code>-XX: MaxTenuringThreshold</code> 中要求的年龄。</p>
<p><strong>空间分配担保</strong></p>
<p>Minor GC前，检查老年代最大可用连续空间是否大于新生代所有对象总空间。成立则进行，不成立检查是否允许担保失败。允许，则检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小，大于则尝试进行一次 Minor GC，小于或者不允许担保失败，进行 Full GC。</p>
<h2 id="第四、五章-JVM监控和故障处理及内存调优"><a href="#第四、五章-JVM监控和故障处理及内存调优" class="headerlink" title="第四、五章 JVM监控和故障处理及内存调优"></a>第四、五章 JVM监控和故障处理及内存调优</h2><p><strong>性能监控和故障处理工具</strong><br>jsp：输出虚拟机中运行的进程状态信息<br>jstat：持续观察虚拟机内存中各个分区的使用率以及GC的统计数据<br>jmap：查看堆内存的使用情况<br>jstack：查看java进程内线程堆栈信息，结合日志可以迅速定位到问题线程<br>JMC：分析本地应用以及连接远程ip使用，提供实时分析线程、内存、CPU、GC等信息的可视化界面</p>
<h2 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 类文件结构"></a>第六章 类文件结构</h2><h3 id="无关性基石"><a href="#无关性基石" class="headerlink" title="无关性基石"></a>无关性基石</h3><ul>
<li><p>语言无关性</p>
<ul>
<li>实现语言无关性的基础是【虚拟机】和【字节码存储格式】</li>
<li>虚拟机不与任何程序语言绑定，它只和“Class文件”这种特定的二进制文件格式所关联</li>
<li>其他任何语言的实现者都可以将 Java 虚拟机作为语言的运行基础，以 Class 文件作为产品的交付媒介</li>
</ul>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116132246640.png" alt style="zoom:50%;">
</li>
<li><p>平台无关性</p>
<ul>
<li>各种不同平台的【Java虚拟机】，以及所有平台都统一支持的【程序存储格式——字节码】，是构成平台无关性的基石</li>
<li>开发商开发出的各种平台上的虚拟机，屏蔽掉了各个平台操作系统和机器指令集的不同性，不同平台的虚拟机识别相同的 Class 文件，实现 Java 等语言的“<strong>一次编译，到处运行</strong>”</li>
</ul>
</li>
</ul>
<h3 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h3><p>Java 技术保持良好的向后兼容性，Class 文件结构的稳定功不可没</p>
<p>任何一个Class文件都对应着唯一的一个类或接口的定义信息，但是类或接口不一定都要定义在文件里（比如可以动态生成，直接送入类加载器中）<br>Class文件是以8个字节为基础单位的二进制流，各个数据项严格按顺序紧凑排列在文件当中，中间没有任何分隔符。当遇到占用8字节以上空间的数据项时，会按照高位在前方式分割成若干8个字节</p>
<p>Class 文件只有两种数据类型：</p>
<ul>
<li>无符号数：是基本数据类型，以 u1，u2，u4，u8 表示对应字节的无符号数，描述数字、索引引用、数量值、按照UTF-8编码构成的字符串值</li>
<li>表：多个无符号数或其他表作为数据项构成的复合数据结构，”_info“ 结尾。整个 Class 文件本质也可看做一张表</li>
</ul>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116142558649.png" alt style="zoom:50%;">

<p><strong>魔数</strong></p>
<p>​	占 4 字节，确认文件是否为一个能被虚拟机接受的文件（不用拓展名识别身份，更安全），值为 0xCAFEBABE</p>
<p><strong>版本号</strong></p>
<pre><code>1. 前两个字节是次版本号，不常用，主要用于测试版本
1. 后两个字节是主版本号，高版本 JDK 能向下兼容以前版本的 Class 文件，但不能运行以后版本的 Class 文件。《Java虚拟机规范》规定，即使文件格式未发生变化，虚拟机也拒绝运行超过其版本号的 Class 文件
</code></pre>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116143341963.png" alt style="zoom:50%;">

<blockquote>
<p>比如，一个版本号为 0x0032 （十进制 50）的 Class 文件，只能被 JDK 6 或以上版本的虚拟机执行 </p>
</blockquote>
<p><strong>常量池</strong></p>
<p>在Java程序编译后，生成的<code>.class</code>文件中包含了一个常量池。这是一个数据结构，用于<strong>存储类在编译时已知的各种常量和符号引用，如字符串文字、数值常量、类名、字段名、方法名等</strong>。<code>.class</code>文件中的常量池是在编译时创建的，它是<strong>静态</strong>的，不会在运行时发生变化。</p>
<ul>
<li><strong>内容</strong>：包括字符串常量、数值常量、类和方法的符号引用、字段引用等。</li>
<li><strong>作用</strong>：在程序运行时，JVM会加载<code>.class</code>文件，将这些常量池中的内容读取到内存中，供类加载和方法调用使用。</li>
</ul>
<ol>
<li><p>Class 文件中第一个出现的表类型数据项目，存放字面量和符号引用</p>
</li>
<li><p>常量池入口有 u2 类型数据，表示常量池容量计数值（constant_pool_count）</p>
<blockquote>
<p>注意：计数从 1 开始</p>
<p>比如，常量池容量为 0x0016（十进制 22），表示常量池有 21 项常量 （1-21），如果某些指向常量池的索引值为 0，表示不引用任何一个常量池项目</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>字面量</p>
<blockquote>
<p> 类似常量，如文本字符串、被声明为final的常量值等</p>
</blockquote>
</li>
<li><p>符号引用：</p>
<blockquote>
<p>被模块导出或者开放的包<br>类和接口的全限定名<br>字段的名称和描述符<br>方法的名称和描述符<br>方法句柄和方法类型<br>动态调用点和动态常量</p>
</blockquote>
</li>
</ul>
<p>​		当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中<br><strong>访问标志</strong><br>​	1. 常量池结束后，紧接着两字节表示访问标志（access_flag），识别一些类或接口的访问信息，包括：Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明final等<br>​	1. access_flag 共 16 个标志位可用，只定义了 9 个，没用到的一律为 0</p>
<h2 id="第七章-虚拟机类加载机制（还未完全理解，有时间补）"><a href="#第七章-虚拟机类加载机制（还未完全理解，有时间补）" class="headerlink" title="第七章 虚拟机类加载机制（还未完全理解，有时间补）"></a>第七章 虚拟机类加载机制（还未完全理解，有时间补）</h2><p>参考：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d432a94be182">https://www.jianshu.com/p/d432a94be182</a></p>
<p>Java 虚拟机把描述类的数据从 <strong>Class 文件</strong> 加载到 <strong>内存</strong>，并对数据进行校验、解析、初始化等过程，最终形成可被虚拟机直接使用的 Java 类型，称为虚拟机类的加载机制。</p>
<blockquote>
<p>一定把 <strong>类加载</strong> 和 <strong>创建对象</strong> 区分开！</p>
</blockquote>
<p><strong>加载、验证、准备、初始化、卸载</strong> 这五个阶段顺序确定，<strong>解析阶段不一定，可以在初始化以后再进行</strong>，这是为了支持 Java 语言的运行时绑定（也称为<strong>动态绑定</strong>或晚期绑定）。注意，这里的几个阶段是按顺序开始，而不是按顺序进行或完成的，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用、激活另外一个阶段。</p>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20221116163240786.png" alt style="zoom:40%;"> 

<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>（只看这几个图，先知道大概就行。具体原理有需要再深入）</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a><strong>加载</strong></h4><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240401081118080.png" style="zoom: 80%;"> 

<p>加载阶段主要<strong>查找并加载类的二进制数据</strong>。在该阶段，虚拟机需要完成以下3件事情：</p>
<ul>
<li><p>通过一个类的【全限定名】获取类的二进制字节流</p>
<blockquote>
<p>没有要求怎样获取、从哪里获取，具有很强的灵活性</p>
<p>比如：从 ZIP 压缩包获取——JAR、WAR；网络中获取——Web Applet；动态代理；由其他文件生成——JSP 等</p>
</blockquote>
</li>
<li><p>将这个字节流所代表的静态存储结构转化为【方法区】的运行时数据结构</p>
</li>
<li><p>内存中生成一个代表这个类的的【java.lang.Class对象】，作为方法区这个类的各种数据的访问入口</p>
</li>
</ul>
<p>相对于类加载的其他阶段，一个<strong>非数组类</strong>的<strong>加载</strong>阶段是开发人员可控性最强的阶段，因为该阶段既可以使用系统提供的<strong>引导类加载器</strong>来完成，也可以由<strong>用户自定义的类加载器</strong>去完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。</p>
<p>对于<strong>数组类</strong>，其本身不通过类加载器创建，它是由 Java 虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终靠类加载器去创建。一个数组类的创建过程遵循以下规则：</p>
<ul>
<li>如果数组的组件类型是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组类将在加载该组件类型的类加载器的类名称空间上被标识。</li>
<li>如果数组的组件类型不是引用类型（如int[]数组），Java虚拟机将会把数组类标记为与引导类加载器关联。</li>
<li>数组类的可见性与它的组件类型的可见性一致，如果组件类型不是引用类型，那数组类的可见性默认为public。</li>
</ul>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，然后在内存中实例化一个<code>java.lang.Class</code>类的对象，这个对象将作为程序访问方法区中的这些数据的外部接口。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h4><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240401082204443.png" style="zoom:80%;"> 

<p>验证阶段的目的是为了<strong>确保Class文件的字节流中包含的信息符合当前虚拟机的要求</strong>，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<p>（1）<strong>文件格式验证</strong>：验证字节流是否符合Class文件格式的规范，而且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：</p>
<ul>
<li>是否以<strong>0xCAFEBABE</strong>开头。</li>
<li>主、次版本号是否在当前虚拟机的处理范围之内。</li>
<li>常量池中的常量是否有不被支持的常量类型。</li>
<li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。</li>
<li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。</li>
</ul>
<p>第一阶段的验证点远不止这些，该验证阶段的主要目的是<strong>保证输入的字节流能正确地解析并存储于方法区内，格式上符合描述一个Java类型信息的要求</strong>。该阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证后，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段都是基于方法区的存储结构进行的，不会再直接操作字节流。 </p>
<p>（2）<strong>元数据验证</strong>：对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求，这个阶段可能包括的验证点：</p>
<ul>
<li>这个类是否有除了java.lang.Object之外的父类。</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）。</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法。</li>
<li>类中的字段、方法是否与父类产生矛盾。</li>
</ul>
<p>（3）<strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。在第二阶段对元数据信息中的数据类型做完校验后，这个阶段将对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件，例如：</p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上。</li>
<li>保证方法体中的类型转换是有效的。</li>
</ul>
<p>（4）<strong>符号引用验证</strong>：最后一个阶段的校验发生在解析阶段，其对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，通常需要校验以下内容：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。</li>
<li>符号引用中的类、字段、方法的访问性是否可被当前类访问。</li>
</ul>
<p>符号引用验证的目的是<strong>确保解析动作能正常执行</strong>，如果无法通过符号引用验证，那么将会抛出异常。该阶段是一个非常重要的、但不是一定必要的阶段。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a><strong>准备</strong></h4><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240401084722919.png" alt style="zoom:80%;"> 

<p>准备阶段主要<strong>为类的静态变量分配内存并将其初始化为默认值</strong>，这些内存都将在<strong>方法区</strong>中分配（ JDK8 以后，类变量会随着 Class 对象放到堆中，这时类变量在方法区是一种逻辑上的概念）。</p>
<p>该阶段有两点需要注意：</p>
<p>（1）首先，这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p>
<p>（2）其次，这里所设置的初始值通常是数据类型默认的初始值，而不是被在 Java 代码中被显式地赋予的值。这里还需要注意如下几点：</p>
<ul>
<li>对<strong>基本数据类型</strong>来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被<strong>final</strong>修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于<strong>引用数据类型</strong>来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。</li>
<li>如果在<strong>数组</strong>初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
<p>如果类字段的字段属性表中存在ConstantValue属性（同时被final和static修饰），那在准备阶段变量value就会被初始化为ConstantValue 属性所指定的值，假设类变量value被定义为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为123。</p>
<blockquote>
<p>初始值一般指零值，真正给类变量赋规定的值的putstatic指令，是在类构造器<clinit>()方法中，在类的初始化阶段才会进行。<br>特殊情况下，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量会被初始化为ConstantValue指定的值</clinit></p>
</blockquote>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h4><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240401093246621.png" style="zoom:80%;"> 

<p>解析阶段是虚拟机<strong>将常量池内的符号引用替换为直接引用</strong>的过程。<strong>符号引用</strong>就是一组符号来描述目标，可以是任何字面量；<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。下面将讲解前面4种引用的解析过程。</p>
<ul>
<li><strong>类或接口的解析</strong></li>
</ul>
<p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机需要以下3个步骤：</p>
<p>（1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。</p>
<p>（2）如果C是一个数组类型，并且数组的元素类型为对象，那将会按照第1点的规则加载数组元素类型。</p>
<p>（3）如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。</p>
<ul>
<li><strong>字段解析</strong></li>
</ul>
<p>要解析一个未被解析过的字段符号引用，首先将会对字段所属的类或接口的符号引用进行解析。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：</p>
<p>（1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>（2）否则，如果在C中实现了接口，就会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>（3）否则，如果C不是java.lang.Object的话，就会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>（4）否则，查找失败，抛出<strong>java.lang.NoSuchFieldError</strong>异常。</p>
<p>最后，如果查找过程成功返回了直接引用，就会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出<strong>java.lang.IllegalAccessError</strong>异常。</p>
<ul>
<li><strong>类方法解析</strong></li>
</ul>
<p>类方法解析也需要先解析出类方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索：</p>
<p>（1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现C是个接口，直接抛出异常。</p>
<p>（2）否则，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>（3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>（4）否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，查找结束，抛出异常。</p>
<p>（5）否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</p>
<p>最后，如果查找过程成功返回了直接引用，就会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出<code>java.lang.IllegalAccessError</code>异常。</p>
<ul>
<li><strong>接口方法解析</strong></li>
</ul>
<p>接口方法解析也需要先解析出接口方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：</p>
<p>（1）如果在接口方法表中发现C是个类而不是接口，直接抛出异常。</p>
<p>（2）否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>（3）否则，在接口C的父接口中递归查找，直到java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</p>
<p>（4）否则，宣告方法查找失败，抛出<code>java.lang.NoSuchMethodError</code>异常。</p>
<p>由于接口中的所有方法默认都是<code>public</code>的，所以不存在访问权限的问题。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a><strong>初始化</strong></h4><img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20240401094732841.png" style="zoom:80%;"> 

<p>初始化是指<strong>为类的静态变量赋予正确的初始值</strong>，JVM负责对类进行初始化，主要对类变量进行初始化。在 Java 中对类变量进行初始值设定有两种方式：</p>
<p>（1）声明类变量时指定初始值；</p>
<p>（2）使用静态代码块为类变量指定初始值。</p>
<p>JVM初始化步骤：</p>
<p>（1）假如这个类还没有被加载和连接，则程序先加载并连接该类；</p>
<p>（2）假如该类的直接父类还没有被初始化，则先初始化其直接父类；</p>
<p>（3）假如类中有初始化语句，则系统依次执行这些初始化语句。</p>
<p>类初始化时机：只有当对类主动使用的时候才会导致类的初始化，类的主动使用包括以下6种：</p>
<ul>
<li>创建类的实例，也就是new的方式；</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值；</li>
<li>调用类的静态方法；</li>
<li>反射（如Class.forName(“…”)）；</li>
<li>初始化某个类的子类，则其父类也会被初始化；</li>
<li>Java虚拟机启动时被标明为启动类的类，直接使用java.exe命令来运行某个主类。</li>
</ul>
<blockquote>
<p>初始化是类加载过程最后一个步骤，真正开始执行类中编写的 Java 代码，将主导权移交给 Java 程序。<br>执行类构造器 <code>&lt;clinit&gt;()</code> 方法，这是 javac 编译器的自动生成物，由编译器自动收集类中所有类变量的赋值动作和静态语句块(static) 中的语句合并产生。编译器收集的顺序由语句在源文件中出现的顺序决定，静态语句块只能访问到定义静态语句块之前的变量，定义在他之后的变量，静态语句块只能赋值，不能访问。<br><code>&lt;clinit&gt;()</code> 方法不用显式的调用父类构造器，虚拟机会保证父类 <code>&lt;clint&gt;()</code> 在子类执行前已经执行完毕。<br>执行接口的方法不需要先执行父接口 的方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。<br>同一个类加载器下，一个类型只会被初始化一次。</p>
</blockquote>
<h3 id="什么时候必须初始化？"><a href="#什么时候必须初始化？" class="headerlink" title="什么时候必须初始化？"></a>什么时候必须初始化？</h3><p><strong>主动引用</strong></p>
<p>《Java虚拟机规范》没有强制约束类什么时候加载，但是规定了【有且仅有】六种情况要立刻进行类的 初始化：</p>
<ul>
<li>遇到<code>new</code> 、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code>这四条字节码指令<ul>
<li><code>new</code>实例化对象</li>
<li>设置或读取一个类型的静态字段（被<code>final</code>修饰、已在编译期把结果放进常量池的静态字段除外）</li>
<li>调用一个类型的静态方法时</li>
</ul>
</li>
<li>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用时</li>
<li>初始化类时，发现父类还没初始化，要先初始化父类</li>
<li>先初始化主类</li>
<li>如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果为<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>、 <code>REF_newInvokeSpecial</code>四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</li>
<li>一个接口定义了默认方法<code>default</code>，如果这个接口的实现类发生初始化，接口要在它之前初始化</li>
</ul>
<p>注意：对于静态字段，<strong>只有直接定义这个字段的类才会被初始化</strong>，因此通过子类引用父类定义的静态字段，只会触发父类初始化而不会触发子类<br>接口不能用static语句块，但编译器也会接口生成<clinit>()类构造器，用于初始化接口定义的成员变量。接口初始化不要求父接口全部完成初始化，只有在真正使用到父接口时（如引用接口定义的的常量）才会初始化</clinit></p>
<p><strong>被动应用</strong></p>
<ul>
<li><p>通过子类调用父类的静态字段，不会导致子类初始化</p>
</li>
<li><p>通过数组来引用类，不会导致此类初始化</p>
</li>
<li><p>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，不会触发定义常量的类的初始化</p>
</li>
</ul>
<blockquote>
<p><strong>补充</strong></p>
<ul>
<li>访问【编译期常量】<ul>
<li>常量的值可以在编译期间确定，访问该常量时不会引起常量所在类的初始化</li>
</ul>
</li>
<li>访问【运行期常量】<ul>
<li>常量的值不可以在编译期间确定，访问该常量时会引起常量所在类的初始化</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>接口初始化不要求父接口初始化，真正用到父接口（引用接口中定义的常量）才会初始化（除了含<code>default</code>方法的接口）</li>
</ul>
<h3 id="区分：类加载过程-与-创建对象过程"><a href="#区分：类加载过程-与-创建对象过程" class="headerlink" title="区分：类加载过程 与 创建对象过程"></a>区分：类加载过程 与 创建对象过程</h3><p>在Java中创建对象的过程包括以下几个步骤：</p>
<p>（包括两大步骤：A <strong>类加载的过程</strong> B <strong>对象创建的过程</strong>）</p>
<ol>
<li><strong>类加载检查</strong>：虚拟机遇到一条 new 指令时，首先将去检查这个指令中指定的类是否已经加载到 JVM 中了，也就是检查参数是否能在<strong>常量池</strong>中定位到一个类的<strong>符号引用</strong>，并且检查这个符号引用代表的类是否已被<strong>加载过、解析和初始化</strong>过。如果没有，那必须先执行相应的<strong>类加载过程</strong>。</li>
<li><strong>分配内存</strong>：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的<strong>内存大小</strong>在<strong>类加载</strong>完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</li>
<li><strong>初始化零值</strong>：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li>
<li><strong>进行必要设置，比如对象头</strong>：初始化零值完成之后，虚拟机要对对象进行<strong>必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在<strong>对象头</strong>中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li>
<li><strong>执行 init 方法</strong>：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始——构造方法，即class文件中的方法还没有执行，所有的字段都还为零，<strong>对象需要的其他资源和状态信息</strong>还没有按照程序员预定的意图构造好。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。</li>
</ol>
<h3 id="3-类加载器"><a href="#3-类加载器" class="headerlink" title="3. 类加载器"></a>3. 类加载器</h3><p>类加载阶段中“通过一个类的全限定名获取描述类的二进制字节流”这个动作放到虚拟机外部去实现，以便让应用程序自己决定如何让获取所需的类。实现这个动作的代码称为“类加载器”</p>
<p>&#x3D;&#x3D;如何确定类的唯一性？&#x3D;&#x3D;</p>
<ul>
<li><p>任意一个类，都必须由加载他的【类加载器】和这个【类本身】一起确立唯一性</p>
</li>
<li><p>每个类加载器，都有一个独立的类名称空间</p>
</li>
<li><p>比较两个类是否相等，只有这两个类由同一个类加载器加载的前提下才有意义，否则一定不相等</p>
</li>
</ul>
<p>&#x3D;&#x3D;三层类加载器：&#x3D;&#x3D;</p>
<img src="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241209165315250.png" style="zoom:40%;">

<ul>
<li><p><strong>启动类加载器（Bootstrap ClassLoader）:</strong></p>
<p>定义：由C++实现，是虚拟机的一部分。负责<strong>加载 JVM自身所需的核心类库，如<code>java.lang</code>包中的类。</strong></p>
<p>加载路径：引导类加载器从JVM的<code>boot classpath</code>加载类库，通常是<code>$JAVA_HOME/lib</code>目录下的<code>rt.jar</code>（或在JDK 9及以后版本中的<code>java.base</code>模块）。</p>
</li>
<li><p><strong>拓展类加载器（Extension CLassLoader）</strong></p>
<p>用于加载扩展类库（如<code>java.lang</code>以外的核心类，如<code>javax</code>包中的类）。用于加载<code>$JAVA_HOME/lib/ext</code>目录或<code>java.ext.dirs</code>系统属性所指定的路径下的类。</p>
</li>
<li><p><strong>应用类加载器</strong>：加载应用程序的类和依赖库，通常是<code>CLASSPATH</code>下的类。</p>
</li>
<li><p><strong>自定义类加载器</strong>：由开发者实现，用于满足特定需求的类加载逻辑。</p>
</li>
</ul>
<p>问题：怎么实现自定义类加载器？为什么要实现自定义类加载器？有什么应用场景？</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a><strong>双亲委派模型</strong></h4><p>&#x3D;&#x3D;什么是双亲委派模型？&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;为什么要有双亲委派模型？&#x3D;&#x3D;</p>
<p>如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器区完成，每一层次的类加载器都是如此，因此所有的加载请求最终传送到顶层的启动类加载器，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类），子类加载器才会尝试自己加载</p>
<h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a><strong>破坏双亲委派模型</strong></h4><p>&#x3D;&#x3D;有什么应用场景需要破坏双亲委派模型？&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;如何破坏双亲委派模型？&#x3D;&#x3D;</p>
<p>双亲委派模型解决了各个类加载器协作时基础类型的一致性问题（越基础的类越由上层加载器加载）。<br>基础类型要调用回用户的代码：线程上下文加载器，通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，默认是应用程序类加载器。<br>JNDI服务使用线程上下文类加载器加载所需SPI服务代码，即父类加载器请求子类加载器完成类加载动作</p>
<h2 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h2><h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p><strong>动态连接</strong><br>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，为了支持方法调用过程中的动态连接</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用阶段的唯一任务就是<strong>确定被调用方法的版本</strong>，暂时未涉及方法内部的具体运行过程<br><strong>解析</strong><br>调用目标在程序代码写好、编译器进行编译的那一刻就已经确定下来了，这类方法的调用成为解析</p>
<h2 id="谈谈你对多态的理解"><a href="#谈谈你对多态的理解" class="headerlink" title="&#x3D;&#x3D;谈谈你对多态的理解&#x3D;&#x3D;"></a>&#x3D;&#x3D;谈谈你对多态的理解&#x3D;&#x3D;</h2><h3 id="1-什么是多态？"><a href="#1-什么是多态？" class="headerlink" title="1. 什么是多态？"></a><strong>1. 什么是多态？</strong></h3><p>多态是面向对象编程（OOP）的核心特性之一，指<strong>同一个方法调用</strong>，根据<strong>对象的具体类型</strong>（运行时多态）或<strong>传入参数的不同</strong>（编译时多态），<strong>表现出不同的行为</strong>。多态分为以下两种主要形式：</p>
<ul>
<li><strong>编译时多态（静态多态）</strong>：通过方法重载（Overloading）实现。方法的行为在编译时决定。</li>
<li><strong>运行时多态（动态多态）</strong>：通过方法重写（Overriding）实现。方法的行为在运行时决定。</li>
</ul>
<hr>
<h3 id="2-如何实现多态？"><a href="#2-如何实现多态？" class="headerlink" title="2. 如何实现多态？"></a><strong>2. 如何实现多态？</strong></h3><ul>
<li><p><strong>方法重载（Overloading）</strong><br>在同一个类中，方法名相同，但参数类型或数量不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">add</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：调用哪个方法由参数类型或数量决定，编译时确定。</p>
</li>
<li><p><strong>方法重写（Overriding）</strong><br>子类对父类方法进行重写。通过父类引用调用子类方法，体现运行时多态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sound</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(); <span class="comment">// 父类引用指向子类对象</span></span><br><span class="line">        animal.sound(); <span class="comment">// 输出：Dog barks</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="3-多态的作用"><a href="#3-多态的作用" class="headerlink" title="3. 多态的作用"></a><strong>3. 多态的作用</strong></h3><ol>
<li><strong>提高代码的扩展性</strong>：通过父类接口编程，子类可以根据需求重写方法，而无需修改现有代码。</li>
<li><strong>简化代码的维护</strong>：减少重复代码，使代码更易读、更灵活。</li>
<li><strong>支持接口和抽象类的应用</strong>：多态是实现接口和抽象类核心功能的基础。</li>
</ol>
<hr>
<h3 id="4-实际应用场景"><a href="#4-实际应用场景" class="headerlink" title="4. 实际应用场景"></a><strong>4. 实际应用场景</strong></h3><ul>
<li><p><strong>设计模式</strong>：</p>
<ul>
<li>工厂模式：使用多态返回不同子类的对象。</li>
<li>策略模式：通过多态选择不同的算法实现。</li>
</ul>
</li>
<li><p><strong>集合框架</strong>：Java 集合类（如 <code>List</code>）的设计大量使用多态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里 <code>List</code> 是接口，<code>ArrayList</code> 是实现类，程序只需依赖接口，无需关心底层实现。</p>
</li>
<li><p><strong>依赖注入</strong>：通过依赖注入和多态，Spring 框架让代码更具扩展性和灵活性。接口注入依赖于多态的特性，能够在<strong>相同接口调用的基础上，根据实现类的不同</strong>表现出不同行为，从而实现松耦合和动态替换。</p>
</li>
<li><p><strong>CGLib动态代理</strong>：代理类继承父类，重写目标方法。</p>
</li>
</ul>
<hr>
<h3 id="5-多态的注意事项"><a href="#5-多态的注意事项" class="headerlink" title="5. 多态的注意事项"></a><strong>5. 多态的注意事项</strong></h3><ol>
<li><p><strong>前提条件</strong>：需要有继承关系或实现接口。</p>
</li>
<li><p>父类引用只能访问父类中的方法</p>
<p>：如果父类没有声明的方法，即使子类有实现，父类引用也无法调用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">animal.fetch(); <span class="comment">// 编译报错，因为 Animal 类中没有 fetch 方法</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>多态是通过<strong>方法重载</strong>和<strong>方法重写</strong>实现的，运行时多态是 Java 的核心特性。它能提高代码的扩展性和维护性，在设计模式、框架中被广泛应用。要注意多态的前提条件和潜在风险（如向下转型）。</p>
<p>是的，多态的底层实现主要依赖<strong>动态绑定</strong>和<strong>虚函数表（vtable）</strong>，这是面向对象编程语言（如 Java、C++）实现运行时多态的核心机制。下面分步骤详细解析：</p>
<hr>
<h3 id="1-动态绑定"><a href="#1-动态绑定" class="headerlink" title="1. 动态绑定"></a><strong>1. 动态绑定</strong></h3><p>动态绑定指的是在<strong>运行时</strong>决定调用哪个方法，而不是在编译时确定。</p>
<ul>
<li>对于多态方法调用，编译器只知道方法的签名（接口或父类定义的方法），但具体调用哪一个方法的实现，要等到运行时根据实际对象的类型决定。</li>
<li>动态绑定是实现多态的关键，它使得同一个方法调用在不同的对象上表现出不同的行为。</li>
</ul>
<hr>
<h3 id="2-虚函数表（vtable）"><a href="#2-虚函数表（vtable）" class="headerlink" title="2. 虚函数表（vtable）"></a><strong>2. 虚函数表（vtable）</strong></h3><p>虚函数表是编译器为支持动态绑定而引入的一种底层实现机制。</p>
<h4 id="虚函数表的结构"><a href="#虚函数表的结构" class="headerlink" title="虚函数表的结构"></a><strong>虚函数表的结构</strong></h4><ul>
<li>每个类都会有一个虚函数表（vtable），它是一个指针表，记录了该类中所有虚方法（即可能被子类重写的方法）的地址。</li>
<li>每个对象包含一个指向虚函数表的指针（通常称为<strong>虚表指针</strong>，vptr），用来找到正确的方法实现。</li>
</ul>
<h4 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a><strong>调用过程</strong></h4><p>假设 <code>Animal</code> 是一个父类，<code>Dog</code> 是一个子类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java复制代码Animal animal = new Dog(); // 父类引用指向子类对象</span><br><span class="line">animal.makeSound(); // 调用子类重写的方法</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>编译阶段</strong>：<ul>
<li>编译器检查 <code>animal</code> 是 <code>Animal</code> 类型，<code>makeSound()</code> 是 <code>Animal</code> 的方法，因此调用合法。</li>
<li>编译器生成代码时，会通过虚表指针查找实际的 <code>makeSound()</code> 方法。</li>
</ul>
</li>
<li><strong>运行阶段</strong>：<ul>
<li>对象 <code>animal</code> 的虚表指针指向 <code>Dog</code> 类的虚表。</li>
<li>在虚表中找到 <code>makeSound()</code> 方法的地址，并调用对应的 <code>Dog</code> 类实现。</li>
</ul>
</li>
</ol>
<h4 id="虚表的动态性"><a href="#虚表的动态性" class="headerlink" title="虚表的动态性"></a><strong>虚表的动态性</strong></h4><p>如果我们有更多的子类，如 <code>Cat</code>，同样的过程会根据 <code>animal</code> 实际的类型调用 <code>Cat</code> 的 <code>makeSound()</code> 方法。这就是动态绑定的实现。</p>
<hr>
<h3 id="3-语言支持"><a href="#3-语言支持" class="headerlink" title="3. 语言支持"></a><strong>3. 语言支持</strong></h3><ul>
<li><strong>Java</strong>：<br>Java 的多态完全依赖动态绑定，所有非 <code>static</code>、非 <code>final</code> 的方法都默认是虚方法。Java 隐藏了虚函数表的细节，但底层原理类似。</li>
<li>**C++**：<br>C++ 提供更细粒度的控制，只有显式声明为 <code>virtual</code> 的方法才会使用虚函数表实现动态绑定；非虚方法在编译时静态绑定。</li>
</ul>
<hr>
<h3 id="4-静态绑定-vs-动态绑定"><a href="#4-静态绑定-vs-动态绑定" class="headerlink" title="4. 静态绑定 vs 动态绑定"></a><strong>4. 静态绑定 vs 动态绑定</strong></h3><table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>静态绑定（Static Binding）</strong></th>
<th><strong>动态绑定（Dynamic Binding）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>绑定时间</strong></td>
<td>编译时</td>
<td>运行时</td>
</tr>
<tr>
<td><strong>适用情况</strong></td>
<td>重载方法（Overloading）和静态方法</td>
<td>重写方法（Overriding）</td>
</tr>
<tr>
<td><strong>效率</strong></td>
<td>更高（无需查找虚表）</td>
<td>稍低（需通过虚表查找实现地址）</td>
</tr>
<tr>
<td><strong>实现机制</strong></td>
<td>无需虚函数表</td>
<td>依赖虚函数表</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5. 优缺点"></a><strong>5. 优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h4><ul>
<li>提供灵活性：允许父类引用调用子类方法。</li>
<li>支持扩展：通过新增子类重写方法实现新的行为。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h4><ul>
<li>动态绑定增加了一定的运行时开销（如虚表查找）。</li>
<li>如果方法不需要重写，可以通过标记为 <code>final</code>（Java）或不使用 <code>virtual</code>（C++）来避免虚表开销。</li>
</ul>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>你提到的观点是完全正确的！<br><strong>多态的底层实现原理就是动态绑定和虚函数表</strong>，动态绑定用于在运行时决定调用哪种方法，而虚函数表则是实现这一机制的技术细节。动态绑定的引入，是为了在运行时支持<strong>多态的灵活性</strong>，而虚函数表是编译器的优化手段，用于高效定位方法的实现地址。</p>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 王才雨
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
