<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>计算机网络 | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="计算机网络 | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="IELTS WritingTask 1Introduction -&gt; Overview -&gt; Detail -&gt; Detail (No Conclusion and opinions!) Notes: 时态不要错！！  PS: 看 便便 的两个 pdf 小作文模板  上升： v rise - rose - risen - rising	n rise v increase - in">
<meta property="og:type" content="article">
<meta property="og:title" content="IELTS Writing">
<meta property="og:url" content="http://example.com/2024/10/10/IELTS-Writing/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="IELTS WritingTask 1Introduction -&gt; Overview -&gt; Detail -&gt; Detail (No Conclusion and opinions!) Notes: 时态不要错！！  PS: 看 便便 的两个 pdf 小作文模板  上升： v rise - rose - risen - rising	n rise v increase - in">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903143929000.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240912122709201.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903154014772.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903170338309.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241008162149573.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903221950372.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240908183744208.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240909115534553.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241006134635925.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/36195076c5bf4f8798d6a3a1a7e8b009.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004223753876.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241003185429807.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241003190448385.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004194259889.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222854805.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222634264.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222706508.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004223109519.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222732028.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222806949.png">
<meta property="article:published_time" content="2024-10-10T07:06:24.000Z">
<meta property="article:modified_time" content="2024-10-10T07:07:10.746Z">
<meta property="article:author" content="王才雨">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903143929000.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>王才雨</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/dalaizi"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:1935863093@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1935863093&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(19)</small>
            
        </div>
    </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="19">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All "
           href="/2024/11/18/Netty/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Netty">Netty</span>
            <span class="post-date" title="2024-11-18 09:00:27">2024/11/18</span>
        </a>
        
        
        <a  class="All "
           href="/2024/10/10/IELTS-Writing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IELTS Writing">IELTS Writing</span>
            <span class="post-date" title="2024-10-10 15:06:24">2024/10/10</span>
        </a>
        
        
        <a  class="All "
           href="/2024/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="操作系统">操作系统</span>
            <span class="post-date" title="2024-04-18 11:20:09">2024/04/18</span>
        </a>
        
        
        <a  class="All "
           href="/2024/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RPC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解RPC">深入理解RPC</span>
            <span class="post-date" title="2024-04-03 13:06:31">2024/04/03</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <span class="post-date" title="2024-03-29 21:02:25">2024/03/29</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/20/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UNIX网络编程">UNIX网络编程</span>
            <span class="post-date" title="2024-03-20 15:03:46">2024/03/20</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/17/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2024-03-17 00:40:34">2024/03/17</span>
        </a>
        
        
        <a  class="All "
           href="/2024/02/25/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="后端开发面试题">后端开发面试题</span>
            <span class="post-date" title="2024-02-25 15:47:51">2024/02/25</span>
        </a>
        
        
        <a  class="All "
           href="/2024/01/05/Linux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux">Linux</span>
            <span class="post-date" title="2024-01-05 13:29:00">2024/01/05</span>
        </a>
        
        
        <a  class="All "
           href="/2023/11/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="力扣刷题">力扣刷题</span>
            <span class="post-date" title="2023-11-22 17:10:44">2023/11/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="动态代理">动态代理</span>
            <span class="post-date" title="2023-10-08 22:49:01">2023/10/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/04/08/%E9%A1%B9%E7%9B%AERPC%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="项目RPC框架">项目RPC框架</span>
            <span class="post-date" title="2023-04-08 19:49:23">2023/04/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/02/redis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="redis">redis</span>
            <span class="post-date" title="2023-01-02 17:46:17">2023/01/02</span>
        </a>
        
        
        <a  class="All "
           href="/2022/12/24/MySQL/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL">MySQL</span>
            <span class="post-date" title="2022-12-24 11:40:50">2022/12/24</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java并发编程">Java并发编程</span>
            <span class="post-date" title="2022-11-11 16:20:42">2022/11/11</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/30/JVM%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM调优">JVM调优</span>
            <span class="post-date" title="2022-10-30 20:09:07">2022/10/30</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解Java虚拟机">深入理解Java虚拟机</span>
            <span class="post-date" title="2022-10-19 10:40:02">2022/10/19</span>
        </a>
        
        
        <a  class="All "
           href="/2022/06/04/Java%E7%9F%A5%E8%AF%86%E7%82%B9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java知识点">Java知识点</span>
            <span class="post-date" title="2022-06-04 10:58:21">2022/06/04</span>
        </a>
        
        
        <a  class="All "
           href="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络">计算机网络</span>
            <span class="post-date" title="2022-02-06 18:11:21">2022/02/06</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-计算机网络" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">计算机网络</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2025-01-05 21:42:09'>2022-02-06 18:11</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%85%A5%E9%97%A8"><span class="toc-text">互联网协议入门</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE%E3%80%81ARP%E5%8D%8F%E8%AE%AE%E3%80%81RARP%E5%8D%8F%E8%AE%AE"><span class="toc-text">IP协议、ARP协议、RARP协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP%E5%88%86%E6%AE%B5-%E5%92%8C-IP%E5%88%86%E7%89%87"><span class="toc-text">TCP分段 和 IP分片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E4%BC%9A%E5%88%86%E6%AE%B5%EF%BC%9FUDP%E4%BC%9A%E5%88%86%E6%AE%B5%E5%90%97%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D;问：为什么TCP会分段？UDP会分段吗？&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%EF%BC%9A%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3-TCP-%E6%98%AF%E5%9F%BA%E4%BA%8E%E6%B5%81%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%8C%E8%80%8C-UDP-%E6%98%AF%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D;问：如何理解 TCP 是基于流的协议，而 UDP 是基于数据报的协议？&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%8A%8A-TCP-%E8%AE%BE%E8%AE%A1%E6%88%90%E5%9F%BA%E4%BA%8E%E6%B5%81%E7%9A%84%E5%8D%8F%E8%AE%AE%EF%BC%8C%E5%83%8F-UDP-%E4%B8%80%E6%A0%B7%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E6%8A%A5%E4%B8%8D%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D;问：为什么要把 TCP 设计成基于流的协议，像 UDP 一样基于数据报不行吗？&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%94%AF%E6%8C%81%E5%8F%AF%E9%9D%A0%E7%9A%84%E5%AD%97%E8%8A%82%E6%B5%81%E4%BC%A0%E8%BE%93"><span class="toc-text">1. 支持可靠的字节流传输</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">2. 流量控制和拥塞控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87%E5%92%8C%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">3. 传输效率和内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E6%8B%BC%E6%8E%A5%E5%92%8C%E6%8B%86%E5%88%86"><span class="toc-text">4. 数据流的拼接和拆分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%80%82%E5%BA%94%E5%A4%9A%E7%A7%8D%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5. 适应多种应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UDP-%E5%8D%8F%E8%AE%AE"><span class="toc-text">UDP 协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE"><span class="toc-text">TCP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">&#x3D;&#x3D;三次握手&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">&#x3D;&#x3D;四次挥手&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-text">拥塞控制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D;TCP 和 UDP 的区别？&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-text">2. 主要区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B"><span class="toc-text">3. 应用场景举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93%E7%AE%80%E6%B4%81%E5%9B%9E%E7%AD%94"><span class="toc-text">4. 总结简洁回答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%A1%BA%E5%BA%8F%EF%BC%8C%E4%B8%A2%E5%A4%B1%E3%80%81%E4%B9%B1%E5%BA%8F%E5%90%8E%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D;TCP 如何保证顺序，丢失、乱序后怎么处理？&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-TCP-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E9%A1%BA%E5%BA%8F"><span class="toc-text">1. TCP 如何保证数据顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-TCP-%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E3%80%81%E4%B9%B1%E5%BA%8F%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">2. TCP 数据丢失、乱序后的处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">2.1 数据丢失的处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E4%B9%B1%E5%BA%8F%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">2.2 数据乱序的处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B%E5%9C%BA%E6%99%AF"><span class="toc-text">3. 示例场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93%E5%9B%9E%E7%AD%94"><span class="toc-text">4. 总结回答</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">HTTP 状态码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-HTTPS-%E6%AF%94%E8%BE%83"><span class="toc-text">&#x3D;&#x3D;HTTP HTTPS 比较&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8F%91%E7%94%9F%E4%BA%86%E5%95%A5%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D;输入一个 URL 到页面发生了啥？&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%B7%A5%E5%92%8C%E5%8F%8C%E5%B7%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">单工和双工的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie-%E5%92%8C-Session-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">Cookie 和 Session 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E7%AB%AF%E5%8F%A3%E5%8F%B7%E3%80%81%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AB%AF%E5%8F%A3%E5%8F%B7%E7%9A%84%E8%A7%A3%E9%87%8A%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-text">固定端口号、常用端口号、自定义端口号的解释与区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%BA%E5%AE%9A%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">1. 固定端口号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">2. 常用端口号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-1"><span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-1"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">3. 自定义端口号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-2"><span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A-2"><span class="toc-text">特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AB%AF%E5%8F%A3%E5%8F%B7%EF%BC%9A"><span class="toc-text">如何选择自定义端口号：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7%E8%8C%83%E5%9B%B4%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-text">端口号范围的划分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%89%E8%80%85%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">4. 三者的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5. 实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%9B%BA%E5%AE%9A%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">（1）固定端口号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">（2）常用端口号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">（3）自定义端口号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%AB%E7%A0%81%E7%99%BB%E9%99%86%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text">扫码登陆的原理</span></a></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><p><strong>面试必看</strong>：<strong><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/">https://xiaolincoding.com/network/</a></strong></p>
<h2 id="互联网协议入门"><a href="#互联网协议入门" class="headerlink" title="互联网协议入门"></a><strong>互联网协议入门</strong></h2><p>转载：<a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html">https://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html</a></p>
<p>基础：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/1_base/tcp_ip_model.html">TCP&#x2F;IP 网络模型有哪几层</a></p>
<p><strong>一、概述</strong></p>
<p><strong>1.1 五层模型</strong></p>
<p>互联网的实现，分成好几层。每一层都靠下一层支持。用户接触到的，只是最上面的一层，根本没有感觉到下面的层。</p>
 <img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123203256042.png" alt="image-20221123203256042" style="zoom:50%;">

<p><strong>1.2 层与协议</strong></p>
<p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。</p>
<p>大家都遵守的规则，就叫做”协议”（protocol）。</p>
<p>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心。</p>
<p><strong>二、实体层</strong></p>
<p>电脑要组网，首先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123203839341.png" alt="image-20221123203839341" style="zoom:50%;">

<p><strong>这就叫做”实体层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</strong></p>
<p><strong>三、链接层</strong></p>
<p><strong>3.1 定义</strong></p>
<p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？</p>
<p><strong>这就是”链接层”的功能，它在”实体层”的上方，&#x3D;&#x3D;确定了0和1的分组方式&#x3D;&#x3D;。</strong></p>
<p><strong>3.2 以太网协议</strong></p>
<p>早期每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p>
<p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123203633812.png" alt="image-20221123203633812" style="zoom:50%;">

<p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。</p>
<p>数据链路层中的网络对数据帧的长度都有一个限制，不同网络的	最大传输单元MTU值不同，常用的以太网为1500个字节</p>
<p>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>
<p>MTU主要是为了限制一次传输的最大IP数据报的值，如果IP层有一个数据报要传，而且数据长度比数据链路层的MTU大，则就需要将IP数据报进行分片，使每一片都小于MTU。</p>
<blockquote>
<p>路径MTU：<br> 当在同一网络上的两台主机互相进行通信时，该网络的MTU是非常重要的，但如果两台主机之间的通信要经过多个网络，而每个网络的链路层可能有不同的MTU，这时，要重点考虑的是两台通信主机路径中各网络的最小MTU，称它为路径MTU。<br> 两台主机之间的路径MTU把有一定是个常数，它取决于当时所选择的路由，而且选路不一定是对称的，即从A到B经过的路由和从B到A经过的路由不同，因此路径MTU在两个方向上不一定是一致的。</p>
</blockquote>
<p><strong>3.3 MAC地址</strong></p>
<p>发送者和接受者是如何标识呢？</p>
<p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p>
<p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123203926135.png" alt="image-20221123203926135" style="zoom:50%;">

<p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>
<p><strong>3.4 广播</strong></p>
<ul>
<li>一块网卡怎么会知道另一块网卡的MAC地址？</li>
</ul>
<p>回答是 有一种<strong>ARP协议</strong>，可以解决这个问题。以太网数据包必须知道接收方的MAC地址，然后才能发送。</p>
<ul>
<li>有了MAC地址，系统怎样才能把数据包准确送到接收方？</li>
</ul>
<p>回答是 以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123204210595.png" alt="image-20221123204210595" style="zoom:50%;">

<p>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p>
<p><strong>四、网络层</strong></p>
<p><strong>4.1 网络层的由来</strong></p>
<p>以太网协议，依靠MAC地址发送数据，这样做有一个重大的缺点：以太网采用<strong>广播方式</strong>发送数据包，所有成员人手一”包”，不仅效率低，而且局限在发送者所在的子网络。如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理的，否则互联网上每一台计算机都会收到所有包，那会引起灾难。</p>
<p>互联网是无数子网络共同组成的一个巨型网络<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123204419739.png" alt="image-20221123204419739" style="zoom:33%;"></p>
<p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。但是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>
<p><strong>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够&#x3D;&#x3D;区分不同的计算机是否属于同一个子网络&#x3D;&#x3D;。这套地址就叫做”网络地址”，简称”网址”。</strong></p>
<p>“网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p>
<p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。先处理网络地址，然后再处理MAC地址。</p>
<p><strong>4.2 IP协议</strong></p>
<p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p>
<p>IPv4 规定，网络地址由32个二进制位组成。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123204754901.png" alt="image-20221123204754901" style="zoom:50%;">

<p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的。</p>
<p>**”子网掩码”**是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。</p>
<p>知道”子网掩码”，我们能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>
<p>总结一下，IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p>
<p><strong>4.3 IP数据报</strong></p>
<p>根据IP协议发送的数据，就叫做IP数据报，其中包括IP地址信息。</p>
<p>以太网数据包只包含MAC地址，并没有IP地址的栏位。把IP数据包直接放进以太网数据包的”数据”部分，不用修改以太网的规格。这就是互联网分层结构的好处：上层的变动完全不涉及下层的结构。</p>
<p>IP数据包也分为”标头”和”数据”两个部分。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123205557377.png" alt="image-20221123205557377" style="zoom:50%;">

<p>“标头”部分主要包括版本、长度、IP地址等信息，”数据”部分则是IP数据包的具体内容。它放进以太网数据包后，以太网数据包就变成了下面这样。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123205832086.png" alt="image-20221123205832086" style="zoom:50%;">

<p>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。理论上，一个IP数据包的”数据”部分，最长为65,515字节。然而，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>
<p><strong>4.4 &#x3D;&#x3D;ARP协议&#x3D;&#x3D;</strong></p>
<p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常，对方的IP地址是已知的，但是我们不知道它的MAC地址。</p>
<p>ARP协议能够从IP地址得到MAC地址。</p>
<ul>
<li><p>第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p>
</li>
<li><p>第二种情况，如果两台主机在同一个子网络，可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p>
</li>
</ul>
<p>局域网中的ARP攻击是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量，使网络阻塞。</p>
<p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p>
<p><strong>五、传输层</strong></p>
<p><strong>5.1 传输层的由来</strong></p>
<p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p>
<p>我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>
<p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>
<p><strong>“传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。</strong>因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>
<p><strong>5.2 UDP协议</strong></p>
<p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。</p>
<p>UDP数据包，也是由”标头”和”数据”两部分组成。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123210732280.png" alt="image-20221123210732280" style="zoom:50%;">

<p>“标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，IP数据包又是放在以太网数据包之中的，所以整个以太网数据包现在变成了下面这样：</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123210809684.png" alt="image-20221123210809684" style="zoom:50%;">

<p>UDP数据包非常简单，”标头”部分一共只有8个字节，总长度不超过65,535字节，正好放进一个IP数据包。</p>
<p><strong>5.3 TCP协议</strong></p>
<p>UDP协议的优点是比较简单，容易实现，缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p>
<p>TCP协议就是有确认机制的UDP协议，能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p>
<p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>
<p><strong>六、应用层</strong></p>
<p>应用程序收到”传输层”的数据，要进行解读。必须事先规定好格式，否则根本无法解读。</p>
<p><strong>“应用层”的作用，就是&#x3D;&#x3D;规定应用程序的数据格式&#x3D;&#x3D;。</strong></p>
<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。</p>
<p>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123211219393.png" alt="image-20221123211219393" style="zoom:50%;">

<p><strong>七、小结</strong></p>
<p>网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信</p>
<p>发送这个包，需要知道两个地址：</p>
<blockquote>
<p>　　  * 对方的MAC地址</p>
<p>　　  * 对方的IP地址</p>
</blockquote>
<p>有了这两个地址，数据包才能准确送到接收者手中。但是，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123211517903.png" alt="image-20221123211517903" style="zoom:50%;">

<blockquote>
<p>上图，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是，于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p>
</blockquote>
<p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，分成两种情况：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>数据包地址</th>
</tr>
</thead>
<tbody><tr>
<td>同一个子网络</td>
<td>对方的MAC地址，对方的IP地址</td>
</tr>
<tr>
<td>非同一个子网络</td>
<td>网关的MAC地址，对方的IP地址</td>
</tr>
</tbody></table>
<p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。</p>
<p><strong>八、用户的上网设置</strong></p>
<p><strong>8.1 静态IP地址</strong></p>
<blockquote>
<p>　　  * 本机的IP地址<br>　　  * 子网掩码<br>　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  * 网关的IP地址<br>　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  * DNS的IP地址</p>
</blockquote>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123212205194.png" alt="image-20221123212205194" style="zoom:50%;">

<p>这四个参数缺一不可，由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。</p>
<p><strong>8.2 动态IP地址</strong></p>
<p>所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做 DHCP 协议。</p>
<p>协议规定，每个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p>
<p>如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p>
<p>DHCP协议做了一些巧妙的规定。</p>
<p><strong>8.3 DHCP协议</strong></p>
<p>它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123212643365.png" alt="image-20221123212643365" style="zoom:50%;">

<blockquote>
<p>（1）”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p>
</blockquote>
<blockquote>
<p>（2）”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p>
</blockquote>
<blockquote>
<p>（3）”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p>
</blockquote>
<p>这个数据包构造完成后，以太网广播发送，同一个子网的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p>
<p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。响应包的以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。</p>
<p>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p>
<p><strong>九、实例：访问网页</strong></p>
<p><strong>9.1 本机参数</strong></p>
<blockquote>
<p>　　  * 本机的IP地址：192.168.1.100<br>　　  * 子网掩码：255.255.255.0<br>　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  * 网关的IP地址：192.168.1.1<br>　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  　　  * DNS的IP地址：8.8.8.8</p>
</blockquote>
<p>打开浏览器，访问Google，在地址栏输入了网址：<a target="_blank" rel="noopener" href="http://www.google.com./">www.google.com。</a></p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123213057542.png" alt="image-20221123213057542" style="zoom:50%;">

<p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p>
<p><strong>9.2 DNS协议</strong></p>
<p>发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址<a target="_blank" rel="noopener" href="http://www.google.com,不知道它的ip地址./">www.google.com，不知道它的IP地址。</a></p>
<p>DNS协议将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123213227293.png" alt="image-20221123213227293" style="zoom:50%;">

<p>然后，DNS服务器做出响应，告诉我们Google的IP地址是172.194.72.105。于是，我们知道了对方的IP地址。</p>
<p><strong>9.3 子网掩码</strong></p>
<p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p>
<p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算，结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p>
<p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p>
<p><strong>9.4 应用层协议</strong></p>
<p>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123213414717.png" alt="image-20221123213414717" style="zoom:50%;">

<p>HTTP部分的内容，类似于下面这样：</p>
<blockquote>
<p>　　　　GET &#x2F; HTTP&#x2F;1.1<br>　　　　Host: <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a><br>　　　　Connection: keep-alive<br>　　　　User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1) ……<br>　　　　Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,<em>&#x2F;</em>;q&#x3D;0.8<br>　　　　Accept-Encoding: gzip,deflate,sdch<br>　　　　Accept-Language: zh-CN,zh;q&#x3D;0.8<br>　　　　Accept-Charset: GBK,utf-8;q&#x3D;0.7,*;q&#x3D;0.3<br>　　　　Cookie: … …</p>
</blockquote>
<p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p>
<p><strong>9.5 TCP协议</strong></p>
<p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p>
<p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p>
<p><strong>9.6 IP协议</strong></p>
<p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p>
<p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p>
<p><strong>9.7 以太网协议</strong></p>
<p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p>
<p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123213829894.png" alt="image-20221123213829894" style="zoom:50%;">

<p><strong>9.8 服务器端响应</strong></p>
<p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p>
<p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p>
<p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>
<h2 id="IP协议、ARP协议、RARP协议"><a href="#IP协议、ARP协议、RARP协议" class="headerlink" title="IP协议、ARP协议、RARP协议"></a>IP协议、ARP协议、RARP协议</h2><p>IP是TCP&#x2F;IP协议族中最核心的协议，所有的TCP、UDP、ICMP、IGMP数据都以IP数据报的格式传输。IP仅提供尽力而为的传输服务，如果发生某种错误，IP会丢失该数据，然后发送ICMP消息给信源端。另外，IP数据报可以不按发送顺序接受。</p>
<p>IP数据报的格式如下：</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221123221008921.png" alt="image-20221123221008921" style="zoom:60%;">



<p>前20字节和紧接其后的选项部分是IP数据报的首部，前20个字节是固定的，选项可有可无。首部的每一行是一个32位字的单位，最高位在左边，为0bit，最低位在右边，为31bit。4字节的32bit值按照以下次序传输：首先0-7bit，其次8-15比特，然后16-23bit，最后是24-31bit，这种传输次序称为big endian字节序。TCP&#x2F;IP首部中的所有二进制整数在网络中传输时都要求以这种次序，因此又称作网络字节序，其他形式存储的二进制数据，如little endian格式，必须在传输数据之前把首部转化成网络字节序。</p>
<p>首部最长为60字节，也即是说选项部分的最大值为40字节，不够4的倍数，要用0填充，使数据部分的起始地址为4的倍数。</p>
<p>​    </p>
<p>IP路由选择    </p>
<p>主机通过路由器和目的主机连接。主机通过IP数据报连接目的主机时，按照如下步骤搜索（同一网络中的搜索要经过ARP协议将目的主机的IP地址解析为MAC地址）：</p>
<p>搜索路由表，优先搜索匹配主机，如果能找到和IP地址完全一致的目标主机，则将该包发向目标主机<br>搜索路由表，如果匹配主机失败，则匹配同子网的路由器，这需要子网掩码的协助。如果找到路由器，则将该包发向路由器。<br>搜索路由表，如果匹配同子网路由器失败，则匹配同网号路由器，如果找到路由器，则将该包发向路由器。<br>搜索路由表，如果以上都失败了，就搜索默认路由，如果默认路由存在，则发包<br>如果都失败了，就丢掉这个包。</p>
<p>ARP协议和RARP协议<br>ARP协议只用在局域网中，它用来将IP地址解析为MAC地址。局域网中的每个主机都有一个ARP缓存，它保存了最近发起的IP地址到MAC地址的映射记录，当该主机要向局域网中的某一主机发送数据时，它会先从自己的缓存中查找，看是否存在目标IP地址，如果找到，就通过映射找到它的MAC地址，从而发送过去，如果没有找到该目的IP地址，它就向该局域网内发送一个广播，广播中包含自己的IP地址、MAC地址和目的主机的IP地址，局域网内的所有主机都会收到该广播，但只有目的IP地址的主机会做出回应，并把自己的MAC地址发送给源主机，源主机收到后，在自己的ARP缓存中增加上该映射，并根据发来的MAC地址将数据发送给目的主机。<br>ARP高速缓存中的表项一般都要设置超时值，如果一段时间内没有与某主机通信，就将该主机对应的IP与MAC之间的映射关系去掉，下次在需要通信时，依然发送广播。<br>如果ARP请求是从一个网络的主机到另一个网络的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程成为ARP代理。<br>RARP协议则刚好相反，它将MAC地址解析成为对应的IP地址，通常在DHCP中有集成，现在已很少单独使用。</p>
<p> ICMP协议</p>
<p>ICMP经常被认为是IP层的一个组成部分，它是网络层的一个协议，它传递差错报文以及其他需要注意的信息，ICMP报文通常被IP层或更高层（TCP、UDP等）使用，它是在IP数据报内传输的。</p>
<p>ICMP报文大致分为两类：查询报文和差错报文。</p>
<p>差错报文：</p>
<ul>
<li>当传送IP数据报发生错误时（比如主机不可达、网络不可达等），ICMP协议将会发送一个ICMP差错报文给源主机，好让主机做出相应的处理，也因此IP层以上的一些协议有可能做到可靠传输。差错报文分成网络不可达、协议不可达、端口不可达等。这里说下端口不可达的意思：UDP的规则之一是，如果收到一份UDP数据报而目的端口与某个正在使用的进程不相符，那么UDP返回一个ICMP不可达报文，将报文中的类型和代码的组合设定为端口不可达。Traceroute程序就是利用端口不可达来产生ICMP差错报文的。</li>
</ul>
<p>在大多数情况下，传送IP数据报发生错误，会产生一个ICMP错误报文，但下面各种情况都不会导致产生ICMP差错报文：</p>
<ul>
<li><p>ICMP差错报文不会产生差错报文（ICMP查询报文可能会产生ICMP差错报文）</p>
</li>
<li><p>目的地址是广播地址和多播地址的IP数据报</p>
</li>
<li><p>作为链路层广播的数据报</p>
</li>
<li><p>不是IP分片的第一片</p>
</li>
<li><p>源地址不是单个主机的数据报   </p>
<blockquote>
<p>这些规则是为了防止过去允许ICMP差错报文对广播分组影响所带来的广播风暴</p>
</blockquote>
</li>
</ul>
<p>ICMP 查询报文的作用：</p>
<ul>
<li><p>子网掩码查询</p>
</li>
<li><p>时间戳查询</p>
</li>
<li><p>ping查询</p>
<blockquote>
<p>ping是ICMP的一个很著名的应用。ping程序时对两个TCP&#x2F;IP系统连通性进行测试的基本工具，它只利用ICMP回显请求和回显应答报文，而不用经过传输层，ping服务器一般在内核中试下ICMP的功能。当某一个网站访问不了时，我们就可以ping一下这个网站，看下连通情况。</p>
</blockquote>
<p>  Traceroute程序</p>
<p>  Traceroute是ICMP协议的另一个重要应用，主要用来侦测源主机到目的主机之间所经过的路由的情况。Traceroute使用ICMP报文和IP首部中的TTL字段，其原理很简单，开始时发送一个TTL字段为1的UDP数据报，而后每次收到ICMP超时报文后，再发送一个TTL字段加1的UDP数据报，以确定路径中的每个路由器，而每个路由器在丢弃UDP数据报时都会返回一个ICMP超时报文，最终到达目的主机后，由于ICMP选择了一个不可能的值作为UDP端口（大于30000）。这样目的主机就会发送一个端口不可达的ICMP差错报文。</p>
</li>
</ul>
<h2 id="TCP分段-和-IP分片"><a href="#TCP分段-和-IP分片" class="headerlink" title="TCP分段 和 IP分片"></a>TCP分段 和 IP分片</h2><p>TCP报文段如果很长的话，会在发送时发生【分段】（MSS），在接受时进行重组</p>
<p>同样，IP数据报在长度超过一定值时也会发生【分片】(MTU)，在接收端再将分片重组。</p>
<pre><code>MTU（最大传输单元）

MTU是链路层中的网络对数据帧的一个限制，以以太网为例，MTU为1500个字节。一个IP数据报在以太网中传输，如果它的长度大于该MTU值，就要进行分片传输，使得每片数据报的长度小于MTU。分片传输的IP数据报不一定按序到达，但IP首部中的信息能让这些数据报片按序组装。IP数据报的分片与重组是在网络层进完成的。


MSS（最大分段大小）

MSS是TCP里的一个概念（首部的选项字段中）。MSS是TCP数据包每次能够传输的最大数据分段，TCP报文段的长度大于MSS时，要进行分段传输。TCP协议在建立连接的时候通常要协商双方的MSS值，每一方都有用于通告它期望接收的MSS选项（MSS选项只出现在SYN报文段中，即TCP三次握手的前两次）。MSS的值一般为MTU值减去两个首部大小（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以如果用链路层以太网，MSS的值往往为1460。而Internet上标准的MTU（最小的MTU，链路层网络为x2.5时）为576，那么如果不设置，则MSS的默认值就为536个字节。很多时候，MSS的值最好取512的倍数。TCP报文段的分段与重组是在运输层完成的。
</code></pre>
<p>TCP分段的原因是MSS，IP分片的原因是MTU，分段后的每一段TCP报文段再加上IP首部后的长度不可能超过MTU，因此也就不需要在网络层进行IP分片了。因此TCP报文段很少会发生IP分片的情况。</p>
<p>UDP数据报不会自己进行分段，因此当长度超过了MTU时，会在网络层进行IP分片。</p>
<p>同样，ICMP（在网络层中）同样会出现IP分片情况。</p>
<p>&#x3D;&#x3D;总结：UDP不会分段，就由IP来分片。TCP会分段，当然就不用IP来分片&#x3D;&#x3D;</p>
<p>另外，IP数据报分片后，只有第一片带有UDP首部或ICMP首部，其余的分片只有IP头部，到了端点后根据IP头部中的信息再网络层进行重组。而TCP报文段的每个分段中都有TCP首部，到了端点后根据TCP首部的信息在传输层进行重组。IP数据报分片后，只有到达目的地后才进行重组，而不是在下一站就要进行重组。</p>
<p>对IP分片的数据报，即使只丢失一片数据也要<strong>重新传整个数据报</strong>（既然有重传，说明运输层使用的是具有重传功能的协议，如TCP协议）。这是因为IP层本身没有超时重传机制——由更高层（比如TCP）来负责超时和重传。当来自TCP报文段的某一段（在IP数据报的某一片中）丢失后，TCP在超时后会重发<strong>整个TCP报文段</strong>，该报文段对应于一份IP数据报（可能有多个IP分片），没有办法只重传数据报中的一个数据分片。</p>
<h3 id="问：为什么TCP会分段？UDP会分段吗？"><a href="#问：为什么TCP会分段？UDP会分段吗？" class="headerlink" title="&#x3D;&#x3D;问：为什么TCP会分段？UDP会分段吗？&#x3D;&#x3D;"></a>&#x3D;&#x3D;问：为什么TCP会分段？UDP会分段吗？&#x3D;&#x3D;</h3><p>因为有发送的长度限制，所以TCP要分段，太大的消息肯定发不了呀，发送缓冲区有限制。</p>
<p>UDP不会分段，只会遵循应用层传来的数据边界。那它如果太大了呢？就让再底层的网络层进行IP分片，来解决这个问题。</p>
<h3 id="问：如何理解-TCP-是基于流的协议，而-UDP-是基于数据报的协议？"><a href="#问：如何理解-TCP-是基于流的协议，而-UDP-是基于数据报的协议？" class="headerlink" title="&#x3D;&#x3D;问：如何理解 TCP 是基于流的协议，而 UDP 是基于数据报的协议？&#x3D;&#x3D;"></a>&#x3D;&#x3D;问：如何理解 TCP 是基于流的协议，而 UDP 是基于数据报的协议？&#x3D;&#x3D;</h3><p>两者之间的区别主要体现在<strong>它们如何处理应用层传输下来的数据。</strong></p>
<p><strong>1. TCP是面向流的协议：</strong></p>
<p>当我们说TCP是面向流的协议时，意味着TCP将传输的数据视为一个<strong>连续的数据流</strong>，而不是独立的消息或数据包。具体来说：它将应用层传递给它的数据看作是一个连续的字节流。它并不会在应用层传来的数据之间添加边界，因此接收方无法直接知道一个完整的应用层消息的边界在哪里。</p>
<p>在TCP传输过程中，<strong>应用层的数据会被TCP分割成若干个TCP段</strong>进行传输，每个TCP段都附有TCP头部，并且在传输过程中可能会发生合并或拆分。接收方需要根据TCP的序列号来重新组合这些段，但它并不直接知道原始数据的边界。</p>
<p><strong>粘包与拆包问题</strong>：由于TCP是流式传输，多个应用层的数据可能会被合并成一个TCP段，或者一个应用层的数据可能会被拆成多个TCP段。为了解决这个问题，通常需要在应用层自己实现<strong>边界识别机制</strong>（例如：固定长度、特殊分隔符、消息长度字段等）。</p>
<p><strong>2. UDP是面向数据报的协议：</strong></p>
<p><strong>每个UDP数据包都是独立的单元</strong>。应用层传递给UDP的数据在传输过程中不会被切分或合并。每个UDP数据报会被附加上UDP头部，并作为一个完整的单元发送。</p>
<p>因此，如果应用层传递多个小数据（比如多个消息），每个消息会分别封装成独立的UDP数据包，不会合并成一个大的数据包，<strong>UDP本身不会改变这些数据的边界</strong>。</p>
<p><strong>无需考虑粘包问题</strong>：因为UDP的数据包就是按应用层的数据传递的边界进行传输的，接收方收到的是独立的消息。</p>
<table>
<thead>
<tr>
<th><strong>特点</strong></th>
<th><strong>TCP（面向流）</strong></th>
<th><strong>UDP（面向数据包）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>传输单位</strong></td>
<td>字节流（数据没有边界）</td>
<td>数据包（每个数据包都有边界）</td>
</tr>
<tr>
<td><strong>连接类型</strong></td>
<td>面向连接（需要建立连接）</td>
<td>无连接（不需要建立连接）</td>
</tr>
<tr>
<td><strong>顺序保证</strong></td>
<td>保证数据按顺序到达</td>
<td>不保证顺序</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>提供可靠传输，数据丢失或错误会被重传</td>
<td>不可靠，数据丢失不会重传</td>
</tr>
<tr>
<td><strong>流量控制</strong></td>
<td>有流量控制和拥塞控制</td>
<td>无流量控制和拥塞控制</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>需要可靠传输、顺序保证的应用（如网页浏览）</td>
<td>对实时性要求高但对丢包容忍的应用（如视频流、在线游戏）</td>
</tr>
</tbody></table>
<h3 id="问：为什么要把-TCP-设计成基于流的协议，像-UDP-一样基于数据报不行吗？"><a href="#问：为什么要把-TCP-设计成基于流的协议，像-UDP-一样基于数据报不行吗？" class="headerlink" title="&#x3D;&#x3D;问：为什么要把 TCP 设计成基于流的协议，像 UDP 一样基于数据报不行吗？&#x3D;&#x3D;"></a>&#x3D;&#x3D;问：为什么要把 TCP 设计成基于流的协议，像 UDP 一样基于数据报不行吗？&#x3D;&#x3D;</h3><p>是为了支持<strong>可靠的、面向连接的</strong>传输。</p>
<h4 id="1-支持可靠的字节流传输"><a href="#1-支持可靠的字节流传输" class="headerlink" title="1. 支持可靠的字节流传输"></a>1. <strong>支持可靠的字节流传输</strong></h4><p>TCP的设计目标之一是保证可靠的字节流传输。它将数据视为一个连续的字节流，而不是分为独立的数据包。这个设计使得TCP能够：</p>
<ul>
<li><strong>保证数据的顺序</strong>：TCP确保接收到的数据严格按发送顺序排列，接收方收到的字节流是完整的、按顺序的。这对很多需要顺序保证的应用（如文件传输、网页浏览）非常重要。</li>
<li><strong>容错和重传机制</strong>：如果某个字节丢失或损坏，TCP会根据序列号识别丢失的位置，并请求重新传输丢失的数据。由于数据被视为流而非数据包，TCP能够通过流的方式高效地处理丢包、重传等问题。</li>
</ul>
<h4 id="2-流量控制和拥塞控制"><a href="#2-流量控制和拥塞控制" class="headerlink" title="2. 流量控制和拥塞控制"></a>2. <strong>流量控制和拥塞控制</strong></h4><p>TCP的面向流设计使它能够提供<strong>流量控制</strong>和<strong>拥塞控制</strong>：</p>
<ul>
<li><strong>流量控制</strong>：TCP使用<strong>滑动窗口</strong>机制来控制发送端的发送速率，确保接收方能够处理接收到的数据。这种控制机制是基于字节流的，能高效处理动态的发送速率，避免接收方被数据淹没。</li>
<li><strong>拥塞控制</strong>：TCP还使用<strong>拥塞控制算法</strong>（如慢启动、拥塞避免、快速重传等）来动态调整发送速率，避免因网络拥塞而丢失过多数据。这种机制依赖于将数据作为字节流传输，TCP通过分析网络的状态来智能地调整数据流。</li>
</ul>
<p>如果TCP采用基于数据包的模型，流量控制和拥塞控制会变得更加复杂，因为数据包本身是独立的，网络上的每个数据包的状态无法直接影响其他数据包的传输。</p>
<h4 id="3-传输效率和内存管理"><a href="#3-传输效率和内存管理" class="headerlink" title="3. 传输效率和内存管理"></a>3. <strong>传输效率和内存管理</strong></h4><ul>
<li><strong>面向流的数据传输</strong>：面向流的设计使得TCP能够有效地管理内存和缓存。数据被视为一个连续的字节流，这意味着在传输过程中，不需要为每个数据包单独分配内存空间，TCP可以灵活地管理发送和接收缓冲区。</li>
<li><strong>传输的灵活性</strong>：流式设计使得TCP能够更灵活地处理不同大小的传输块。应用层发送的数据不需要事先被划分成固定大小的数据包，这样就能避免因包大小不匹配而引起的效率损失。</li>
</ul>
<p>如果TCP是基于数据包的协议，每个数据包都需要独立处理和管理，这可能导致更多的内存管理问题和更大的开销。</p>
<h4 id="4-数据流的拼接和拆分"><a href="#4-数据流的拼接和拆分" class="headerlink" title="4. 数据流的拼接和拆分"></a>4. <strong>数据流的拼接和拆分</strong></h4><ul>
<li><strong>TCP的数据分段和重组</strong>：TCP把数据视为一个流，发送方将应用层数据划分为适合网络传输的段，接收方再将这些段重组为原始的应用数据流。这种方式为数据的拼接和拆分提供了灵活性，应用层不需要关心具体的分段和重组，TCP协议栈会处理这些问题。</li>
<li><strong>数据包设计的局限性</strong>：如果TCP是基于数据包的协议，应用程序可能需要处理多个小的数据包的拼接和拆分，从而增加开发复杂度和潜在的错误率。</li>
</ul>
<h4 id="5-适应多种应用场景"><a href="#5-适应多种应用场景" class="headerlink" title="5. 适应多种应用场景"></a>5. <strong>适应多种应用场景</strong></h4><ul>
<li><strong>通用性</strong>：面向流的设计非常适合于不同类型的应用，尤其是那些需要大量数据传输且要求数据顺序一致的应用。例如，文件传输、网页浏览、电子邮件等，所有这些应用都依赖于TCP的可靠字节流特性。</li>
<li><strong>数据包模型的适用性</strong>：如果采用数据包模型，TCP的应用场景会受到限制，特别是在需要连续、顺序数据流的应用中，数据包的独立性和不确定性会带来额外复杂性。</li>
</ul>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>TCP的面向流的设计是为了实现<strong>可靠、有序、流控制的传输</strong>，并简化应用层对数据传输的处理。通过将数据视为连续的字节流，TCP能够高效地进行数据分段、重传、流量控制和拥塞控制，适应各种应用的需求。而如果TCP设计成基于数据包的协议，尽管可以为每个数据包添加序列号来保证顺序，但这会带来更多的复杂性，并且难以实现流量控制、拥塞控制等核心功能。因此，面向流的设计对于TCP来说是更合适的选择，能够提供更强大的功能和更高效的传输。</p>
<h2 id="UDP-协议"><a href="#UDP-协议" class="headerlink" title="UDP 协议"></a>UDP 协议</h2><p> UDP 是一个 &#x3D;&#x3D;面向数据报&#x3D;&#x3D;的&#x3D;&#x3D;运输层&#x3D;&#x3D;协议：进程的每个输出操作都会产生一个UDP数据报，并组装成一份待发送的IP数据报，这与面向字节流的协议不同（TCP），应用程序产生的全体数据与真正发送的单个IP数据报可能没有什么联系（主要是在传输层就进行分段了，因此不会受IP分片的影响）。</p>
<pre><code>UDP的首部一共8个字节，很简单，可以参考书上，这里也不再详说。

UDP的校验和

至于UDP的校验和，这里注意下区别就好了，UDP对首部和数据部分都进行校验，而IP首部的校验和仅对IP的首部进行校验，顺带提下TCP，TCP的校验和也是对首部和数据部分都进行校验，另外，UDP的校验和是可选的，而TCP的是必选的。

不可靠协议

UDP是不可靠的协议，没有超时和重传功能，当UDP数据封装到IP数据报传输时，如果丢失，会发送一个ICMP差错报文给源主机，另外，如果UDP数据报的发送端没打开UDP校验和，而接收端计算校验和有差错，那么UDP数据报将会被丢掉，也不会发送ICMP差错报文。

路径MTU发现

可以修改Traceroute程序来确定路径MTU。要做的是发送分组，并设置将IP首部设置为不分片，发送的第一个分组的长度正好于出口MTU相等，每次收到ICMP不可分片的差错报文时，就减小分组长度，使新的ICMP不可分片差错报文中返回更小的MTU，每次用更小的MTU值来传送，这样能找到更小的MTU值。

利用路径MTU发现机制，应用程序可以充分利用更大的MTU来发送报文。


UDP最大长度

理论上IP数据报的最大长度为65535字节，因此理论上的UDP数据报的最大长度为65507（65535-20-8）字节，但是，大多数实现所提供的长度比这个最大值小。一般有两个因素的限制：

1、应用程序可能胡受到其程序接口的限制，一些API的实现中可能有限定UDP数据报的最大长度。另外，现在大部分系统都默认提供了可读写大于8192字节的UDP数据报。

2、受限于TCP/IP内核的实现，可能存在一些实现特性，使IP数据报长度小于65535字节。

数据报截断

正是由于UDP最大数据报的限制（受限于上面的两个因素，一般都会小于65507），大于这个限制的数据报会被截断，从而发生数据丢失，且不会有任何数据丢失的通知，这也是UDP协议不可靠传输的另一个体现。而TCP则没有任何信息边界，TCP首部中没有对TCP最长报文段的限制，因此TCP以应用程序读操作时所要求的长度来传送数据（理论上一次可以发送很大的数据，但考虑到网络的传输性能，最好不要一次传输太大的数据），当然在超过MSS值时会产生分段，因此不会发生数据截断。

ICMP源站抑制差错

当一个系统中的某主机或路由器处理数据的速度赶不上接受数据的速度时，因为接收主机的IP缓存会被占满，可能会产生这个差错，从而发送一个ICMP源站抑制差错报文，这里要注意是“可能”。
</code></pre>
<h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>TCP协议，即传输控制协议，与UDP协议同处于传输层，提供面向连接、可靠的数据传输服务</p>
<ul>
<li><p>TCP通过以下方式提供可靠性：</p>
<ul>
<li>TCP分片：应用程序被分割成TCP认为最合适发送的数据块。这与UDP完全不同，应用程序产生的UDP数据报长度将保持不变，而是在网络层进行IP分片</li>
<li>确认机制：当TCP发出一个报文段后，它会启动一个定时器，等待目的端发确认收到这个报文段，如果没能及时收到该确认信息，则将重发这个报文段</li>
<li>确认机制：当TCP接收端收到发送端发来的TCP报文段时，它将发送一个确认，这个确认不是立即发送的，通常会推迟几分之一秒</li>
<li>错误检验：TCP将保持它首部和数据的校验和。这是一个端到端的校验和，如果收到的报文段的校验和有差错，TCP将丢弃该报文段，同时不发送确认收到的消息，从而使发送端超时重发</li>
<li>流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接受端只允许另一端发送接收端缓冲区所能接纳的数据，这将防止较快主机致使较慢主机的缓冲区溢出</li>
<li>失序重排：由于TCP报文段作为IP数据报来传输，IP数据报的到达可能会失序，因此TCP报文段的到达也可能失序，如果必要，TCP将对收到的数据进行重排序，将收到的数据以正确的顺序交给应用层</li>
<li>重复丢弃：由于IP数据报有可能发生重复，TCP的接收端必须丢弃重复的数据</li>
</ul>
<blockquote>
<p>总结：TCP协议保持可靠性的方式就是<strong>超时重传</strong>，虽然TCP也可以通过向源主机发送各种各样的ICMP报文（IP 层）或者来处理这些，但这也是不可靠的，如果ICMP报文在发送回来的过程中丢失了，很明显这种方式就不可靠了。<strong>最可靠的方式就是只要得不到确认，就重新发送数据，直到得到确认为止</strong></p>
</blockquote>
</li>
</ul>
<p><strong>TCP 报文结构</strong></p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124005410044.png" alt="image-20221124005410044" style="zoom:60%;">

<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124005551776.png" alt="image-20221124005551776" style="zoom:67%;">

<p>TCP报文段首部的前20个字节是固定的，后面有4N字节是根据需要而增加的选项。因此TCP报文段的最小长度为20个字节</p>
<ul>
<li>源端口和目的端口：加上IP首部的源IP地址和目的IP地址，确定唯一的一个TCP连接。另外通过目的端口来决定TCP将数据报交付于那个应用程序，从而实现TCP的分用功能。</li>
<li>序号：占4个字节，序号的范围为[0,4284967296]。由于TCP是面向字节流的，在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，首部中的序号字段则是指本报文段所发送的数据的第一个字节的序号。另外，序号是循环使用的，当序号增加到最大值时，下一个序号就又回到了0。</li>
<li>确认号：当ACK标志位为1时有效，表示期望收到的下一个报文段的第一个数据字节的序号。确认号为N，则表明到序号N-1为止的所有数据字节都已经被正确地接收到了</li>
<li>数据偏移：TCP报文段的头部长度，它指出TCP报文段的数据部分的起始位置与TCP报文段的起始位置的距离。头部长度占4个字节，但它的单位是32位字，即以4字节为计算单位，因此头部长度的最大值为15*4&#x3D;60个字节，这就意味着选项的长度不超过40个字节。</li>
<li>保留位：必须为0</li>
<li>六个控制位说明报文段的性质：<ul>
<li>URG：与首部中的紧急指针字段配合使用。URG为1时，表明紧急指针字段有效，发送应用进程告诉发送方的TCP有紧急数据要传送，于是发送方TCP就把紧急数据插入到本报文段数据的最前面，而其后面仍是普通数据</li>
<li>ACK：仅当ACK&#x3D;1时确认号字段才有效，当ACK&#x3D;0时，确认号无效。TCP规定，在连接建立后所有的传送报文段都必须把ACK置1。</li>
<li>PSH：如果发送的报文段中PSH为1，则接收方接受到该报文段后，直接将其交付给应用进程，而不再等待整个缓存都填满后再向上交付。</li>
<li>RST：复位标志，RST&#x3D;1时，表明TCP连接中出现严重差错，必须释放连接，然后重新建立运输连接。</li>
<li>SYN：同步序号，用来发起一个连接。当SYN&#x3D;1而ACK&#x3D;0时，表明这是一个连接请求报文段，若对方同意建立连接，则应在响应的报文段中使SYN&#x3D;1和ACK&#x3D;1</li>
<li>FIN：用来释放一个连接。当FIN&#x3D;1时，表明此报文段的发送方的数据已发送完毕，并要求释放连接。</li>
</ul>
</li>
<li>窗口：接收方让发送方下次发送报文段时设置的发送窗口的大小。</li>
<li>校验和：校验的字段范围包括首部和数据这两部分。</li>
<li>紧急指针：紧急指针当URG&#x3D;1时才有效，它指出本报文段中的紧急数据的字节数。值得注意的是，即使窗口为0时，也可发送紧急数据。</li>
</ul>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="&#x3D;&#x3D;三次握手&#x3D;&#x3D;"></a>&#x3D;&#x3D;三次握手&#x3D;&#x3D;</h3><p>非常好的视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1c4411d7jb?p=64&vd_source=72199420565ce921d3802604346f70b1">三次握手视频</a></p>
<p><img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250104105448216.png" alt="image-20250104105448216"> </p>
<p><strong>（1）</strong>一开始，Server 主动监听某个端口，等待 Client 连接。</p>
<p><strong>（2）</strong>Client 发送 <em><strong>SYN 报文</strong></em>，表示向 Server 发起连接。之后，Client 处于 <em><strong>同步已发送</strong></em> 状态。</p>
<p><strong>（3）</strong>Server 收到 Client 的 SYN 报文后，发送 <em><strong>SYN-ACK 报文</strong></em>，表示已收到 Client 的连接请求。之后，Server 处于 <em><strong>同步已接收</strong></em> 状态。</p>
<p><strong>（4）</strong>Client 收到 Server 的SYN-ACK 报文后，发送 <em><strong>ACK 报文</strong></em>，这次报文可以以携带应用数据。之后，Client 处于 <em><strong>连接已建立</strong></em> 状态。</p>
<p><strong>（5）</strong> Server 收到 Client 的应答报文后，进入 <em><strong>连接已建立</strong></em> 状态。</p>
<p>注：seq和ack的序号自己找规律，不展开讲了。（SYN 报文不能携带数据，但是要占用一个序号）</p>
<blockquote>
<p> 1、客户端的TCP进程首先创建传输控制模块TCB，然后向服务端发出连接请求报文段，该报文段首部中的SYN&#x3D;1，ACK&#x3D;0，同时选择一个初始序号seq&#x3D;i。TCP规定，<strong>SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号</strong>。这时，TCP客户进程进入SYN—SENT（同步已发送）状态，这是TCP连接的第一次握手。</p>
<p> 2、服务端收到客户端发来的请求报文后，如果同意建立连接，则向客户端发送确认。确认报文中的SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;i+1，同时为自己选择一个初始序号seq&#x3D;j。同样该报文段也是SYN&#x3D;1的报文段，不能携带数据，但同样要消耗掉一个序号。这时，TCP服务端进入SYN—RCVD（同步收到）状态，这是TCP连接的第二次握手。</p>
<p> 3、TCP客户端进程收到服务端进程的确认后，还要向服务端给出确认。确认报文段的ACK&#x3D;1，确认号ack&#x3D;j+1，而自己的序号为seq&#x3D;i+1。TCP的标准规定，<strong>ACK报文段可以携带数据，但如果不携带数据则不消耗序号</strong>，因此，如果不携带数据，则下一个报文段的序号仍为seq&#x3D;i+1。这时，TCP连接已经建立，客户端进入ESTABLISHED（已建立连接）状态。这是TCP连接的第三次握手，可以看出第三次握手客户端已经可以发送携带数据的报文段了。</p>
<p> 当服务端收到确认后，也进入ESTABLISHED（已建立连接）状态。</p>
</blockquote>
<p>&#x3D;&#x3D;使用三次握手而不是两次的原因：Client 和 Server 确认双方都有发送和接收的能力（也可以这么答：防止已失效的连接请求报文突然又传入TCP服务器，导致服务器错误地进入连接已建立状态）&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;使用两次握手的后果（如图）：Server 不知道 Client 有没有接收的能力&#x3D;&#x3D;</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20241214222014074.png" style="zoom:33%;">

<blockquote>
<p>防止已经失效的连接请求报文段传到 TCP 服务器导致其错误打开，浪费资源</p>
<p>第一次握手：第一次握手是客户端发送同步报文到服务端，这个时候客户端是知道自己具备发送数据的能力的，但是不知道服务端是否有接收和发送数据的能力；</p>
<p>第二次握手：当服务端接收到同步报文后，回复确认同步报文，此时服务端是知道客户端具有发送报文的能力，并且知道自己具有接收和发送数据的能力，但是并不知道客户端是否有接收数据的能力；</p>
<p>第三次握手：当客户端收到服务端的确认报文后，知道服务端具备接收和发送数据的能力，但是此时服务端并不知道自己具有接收的能力，所以还需要发送一个确认报文，告知服务端自己是具有接收能力的。</p>
<p>当整个三次握手结束过后，客户端和服务端都知道自己和对方具备发送和接收数据的能力，随后整个连接建立就完成了，可以进行后续数据的传输了。</p>
<p>看到这里，如果大家理解了就会知道很明显，两次握手是不行的，因为服务端并不知道客户端是具备接收数据的能力，所以就不能成为面向连接的可靠的传输协议。</p>
</blockquote>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="&#x3D;&#x3D;四次挥手&#x3D;&#x3D;"></a>&#x3D;&#x3D;四次挥手&#x3D;&#x3D;</h3><img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124010847905.png" alt="image-20221124010847905" style="zoom:80%;"> 

<p><strong>（1）</strong> Client 主动调用关闭连接的函数，发送 <em><strong>FIN 报文</strong></em>，表示要断开连接。之后，Client 处于 <em><strong>终止等待1</strong></em> 状态。</p>
<p><strong>（2）</strong>Server 收到 FIN 报文，回复 <em><strong>ACK 确认报文</strong></em> ，此时服务器会进入 <em><strong>关闭等待</strong></em> 状态。</p>
<p><strong>（3）</strong>Server 把没发完的数据继续发完</p>
<p><strong>（4）</strong>Server 发送 <em><strong>FIN 报文</strong></em>，进入 <em><strong>最后确认</strong></em> 状态</p>
<p><strong>（5）</strong>Client 收到 FIN 报文，回复 <em><strong>ACK 确认报文</strong></em>，进入时间等待状态，最后关闭。</p>
<p>Client：我发完了</p>
<p>Server：收到，我还没发完</p>
<p>Server：我也发完了</p>
<p>Client：收到，拜拜</p>
<blockquote>
<p> 1、客户端的TCP进程先向服务端发出连接释放报文段，并停止发送数据，主动关闭TCP连接。释放连接报文段中FIN&#x3D;1，序号为seq&#x3D;u，该序号等于前面已经传送过去的数据的最后一个字节的序号加1。这时，客户端进入FIN—WAIT-1（终止等待1）状态，等待服务器的确认。TCP规定，FIN报文段即使不携带数据，也要消耗掉一个序号。这是TCP连接释放的第一次挥手。</p>
<p> 2、服务器收到连接释放报文段后即发出确认释放连接的报文段，该报文段中，ACK&#x3D;1，确认号为ack&#x3D;u+1，其自己的序号为v，该序号等于服务器前面已经传送过的数据的最后一个字节的序号加1。然后服务器进入CLOSE—WAIT（关闭等待）状态，此时TCP服务器进程应该通知上层的应用进程，因而客户端到服务器这个方向的连接就释放了，这时TCP处于半关闭状态，即客户端已经没有数据要发了，但服务器若发送数据，客服端仍要接受，也就是说从服务器到客户端这个方向的连接并没有关闭，这个状态可能会持续一些时间。这是TCP连接释放的第二次挥手。</p>
<p> 3、客户端收到服务器的确认后，就进入了FIN—WAIT（终止等待2）状态，等待服务器发出连接释放报文段，如果服务器已经没有要向A发送的数据了，其应用进程就通知TCP释放连接。这时服务器发出的链接释放报文段中，FIN&#x3D;1，确认号还必须重复上次已发送过的确认号，即ack&#x3D;u+1，序号seq&#x3D;w，因为在半关闭状态B可能又发送了一些数据，因此该序号为半关闭状态发送的数据的最后一个字节的序号加1。这时服务器进入LAST—ACK（最后确认）状态，等待A的确认，这是TCP连接的第三次挥手。</p>
<p> 4、客户端收到服务器的连接释放请求后，必须对此发出确认。确认报文段中，ACK&#x3D;1，确认号ack&#x3D;w+1，而自己的序号seq&#x3D;u+1，而后进入TIME—WAIT（时间等待）状态。这时候，TCP连接还没有释放掉，必须经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态，时间MSL叫做最长报文寿命，RFC建议设为2分钟，因此从A进入TIME—WAIT状态后，要经过4分钟才能进入到CLOSED状态，而服务器只要收到了客户端的确认后，就进入了CLOSED状态。二者都进入CLOSED状态后，连接就完全释放了，这是TCP连接的第四次挥手。</p>
</blockquote>
<hr>
<p>&#x3D;&#x3D;<strong>为什么是四次挥手?</strong>&#x3D;&#x3D;</p>
<p>（讲一下每次挥手的作用、不是三次、两次挥手的原因）</p>
<p>*<u>第一次挥手：</u>*客户端发起关闭连接的请求给服务端；</p>
<p><u><em>第二次挥手：</em></u>服务端收到关闭请求的时候可能这个时候数据还没发送完，所以服务端会先回复一个确认报文，表示自己知道客户端想要关闭连接了，但是因为数据还没传输完，所以还需要等待；</p>
<p><u><em>第三次挥手：</em></u>当数据传输完了，服务端会主动发送一个 FIN 报文，告诉客户端，表示数据已经发送完了，服务端这边准备关闭连接了。</p>
<p><u><em>第四次挥手：</em></u>当客户端收到服务端的 FIN 报文过后，会回复一个 ACK 报文，告诉服务端自己知道了，再等待一会就关闭连接。</p>
<p><strong>为什么握手要三次，挥手却要四次呢？</strong></p>
<p>那是因为握手的时候并没有数据传输，所以服务端的 SYN 和 ACK 报文可以一起发送，但是挥手的时候有数据在传输，所以 ACK 和 FIN 报文不能同时发送，需要分两步，所以会比握手多一步。（但是如果没有数据要传输，第二次挥手 ACK 和 第三次挥手 FIN 也可以合并）</p>
<p><strong>挥手2次呢？</strong></p>
<p>更不行。服务器接收到 FIN 之后就会直接关闭，那他还有数据没发完怎么办？他回复的ACK要是丢了，他自己关闭了，客户端再次请求也没用了。</p>
<hr>
<p> &#x3D;&#x3D;<strong>为什么 主动关闭方 在 TIME—WAIT 状态必须等待 2MSL 时间呢?</strong>&#x3D;&#x3D;</p>
<p><strong>（1）确保最后一个 ACK 报文能被对端接收</strong><br>在四次挥手过程中，主动关闭方在发送完最后一个 ACK 报文后进入 TIME-WAIT 状态。如果该 ACK 报文丢失，被动关闭方会重传其最后的 FIN 报文。	如果主动关闭方不等待 2MSL 就关闭连接，则无法接收到对端的重传 FIN 报文，也无法再次发送 ACK 确认。这样，被动关闭方会因为无法收到确认而无法正常进入 CLOSED 状态。等待 2MSL 可以确保所有重传的 FIN 报文被处理，从而让双方都能顺利关闭连接。</p>
<p><strong>（2）防止旧连接的报文干扰新连接</strong><br>在 TCP 中，MSL（Maximum Segment Lifetime）表示报文在网络中的最大存活时间。等待 2MSL 可以确保本次连接的所有报文都从网络中消失，包括那些可能延迟的报文段。这样可以避免旧连接中的报文误入新连接，确保新连接的通信不会受到干扰。</p>
<hr>
<p><strong>&#x3D;&#x3D;每次挥手丢失分别会发生什么？&#x3D;&#x3D;</strong></p>
<p>看这个博客：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80">https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80</a></p>
<p>（讲的很详细，有时间看看）</p>
<hr>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><ul>
<li>对于数据传输中，我们希望传输的越快越好，但是若<strong>传输过快会导致接收方不够时间接收数据</strong>，造成数据丢失。</li>
<li><strong>流量控制</strong>就是为了让发送方速率不要太快，要让接收方来的及接收。</li>
<li>利用<strong>滑动窗口机制</strong>可以很方便的在TCP连接数实现对发送方的流量控制</li>
</ul>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124072318406.png" alt="image-20221124072318406" style="zoom:67%;">

<p>我们考虑一种特殊情况，如果B在向A发送了零窗口报文段后不久，B的接收缓存又有了一些存储空间，于是B向A发送了一个rwnd&#x3D;400的报文段，然而这个报文段在传送过程中丢失了，A就一直等待B发送非零窗口的报文通知，而B一直等待A发送数据，如果没有任何措施的话，这话死锁的局面会一直延续下去。</p>
<pre><code>为了解决这个问题，TCP为每一个连接设有一个持续计时器(也叫坚持定时器)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），对方在收到探测报文段后，在对该报文段的确认洪给出现在的窗口值，如果窗口值仍未零，则收到这个报文段的一方就重新设置持续计时器，如果窗口不为零，那么死锁的僵局就被打破了。
</code></pre>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124072516596.png" alt="image-20221124072516596" style="zoom:67%;">

<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124072535968.png" alt="image-20221124072535968" style="zoom:67%;">

<h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><ul>
<li><strong>拥塞</strong>指的是<strong>某段时间内</strong>，若对网络中的<strong>某一资源的需求超过了该资源所能提供的可用部分</strong>，网络性能就要变坏。</li>
<li>在计算机网络种的资源包括链路容量（带宽）、交换节点种的缓存和处理机等。</li>
<li>若出现<strong>拥塞而不进行控制</strong>，整个网络的<strong>吞吐量将随输入负荷的增大而下降</strong>。</li>
<li><u>（通俗理解：车太多，道路资源 有限，就堵车了）</u></li>
</ul>
<p><strong>拥塞控制</strong>，就是在网络中发生拥塞时，减少向网络中发送数据的速度；同时在网络空闲时，提高发送数据的速度，最大限度地利用网络资源。</p>
<p>为了限制数据的发送速率，TCP 会维护一个 <strong>拥塞窗口</strong> <strong>cwnd</strong> 。在 TCP发送端，所有被发送但是还没收到确认的数据段必须落在这个窗口中，所有，当网络拥塞时，TCP程序将减小 cwnd，而网络通畅时，增大cwnd，以此来控制数据发送的速率。</p>
<p>TCP 通过数据发送的一些现象来<strong>推测网络是否拥塞</strong>，比如:</p>
<ul>
<li>若发送一条数据段后，成功接收到了接收方的确认报文，则可以认为网络没有拥塞</li>
<li><strong>若发送出一条数据段后，在规定时间内没有收到确认报文(丢失或时延太大)，则可以认为网络出现了拥塞</strong></li>
<li><strong>若连续收到接收方对同一条报文的三次冗余确认（也就是四次确认），则可以推测那条报文丢失，即发生了拥塞</strong></li>
</ul>
<p><strong>拥塞算法：</strong></p>
<ul>
<li><strong>慢开始算法</strong><ul>
<li>拥塞窗口 开始设置成 1，每隔一个传输轮次，收到上一个报文段的确认报文段后，拥塞窗口翻倍</li>
<li>当 拥塞窗口 到达 慢开始门限值（ssthresh）初始值，停止指数级增长，开始线性增长</li>
</ul>
</li>
<li><strong>拥塞避免算法</strong><ul>
<li>进入 慢开始门限值 后，开始拥塞避免算法，每个传输轮次，拥塞窗口 加 1</li>
<li>当 拥塞窗口 达到一定值，检测到了网络拥塞，此时瞬间将 拥塞窗口 降为 1 ；继续执行慢开始算法，新的 慢开始门限值 变为网络拥塞时 拥塞窗口 的 1&#x2F;2 大小</li>
</ul>
</li>
<li>快重传算法</li>
<li>快恢复算法</li>
</ul>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124011335995.png" alt="image-20221124011335995" style="zoom:67%;">

<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124011352578.png" alt="image-20221124011352578" style="zoom:67%;">

<p>&#x3D;&#x3D;<strong>面试官：现在比如说你的WiFi信号弱，此时拥塞控制会发生什么？</strong>&#x3D;&#x3D;</p>
<p><img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250104124256425.png" alt="image-20250104124256425"></p>
<p>当被问到“WiFi 信号弱时拥塞控制会发生什么”和“为什么 QUIC 更好”时，可以这样回答：</p>
<ol>
<li><strong>WiFi 信号弱时，TCP 拥塞控制的问题：</strong><ul>
<li>TCP 拥塞控制把链路质量问题（如丢包、延迟增加）误判为网络拥塞。</li>
<li>触发慢启动、降低发送速率，导致网络利用率下降。</li>
<li>最终表现为传输效率低、延迟大。</li>
</ul>
</li>
<li><strong>QUIC 的优势：</strong><ul>
<li>QUIC 使用更先进的拥塞控制算法（如 BBR），基于带宽和 RTT 调整速率，避免过度降速。</li>
<li>QUIC 的丢包恢复机制更灵活，不会因为链路质量问题频繁降低发送速率。</li>
<li>支持多路复用、快速连接建立（0-RTT），即使在信号弱的情况下，也能保持较好的性能。</li>
<li>QUIC 不依赖 TCP 固有的机制，更适合高丢包、高延迟环境。</li>
</ul>
</li>
</ol>
<p>&#x3D;&#x3D;<strong>面试官：如果你的舍友在下载东西，速度很快，但你的网络很卡，这和你舍友有关系吗</strong>&#x3D;&#x3D;</p>
<p><img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250104124311134.png" alt="image-20250104124311134"></p>
<h2 id="TCP-和-UDP-的区别？"><a href="#TCP-和-UDP-的区别？" class="headerlink" title="&#x3D;&#x3D;TCP 和 UDP 的区别？&#x3D;&#x3D;"></a>&#x3D;&#x3D;TCP 和 UDP 的区别？&#x3D;&#x3D;</h2><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. <strong>基本概念</strong></h3><ul>
<li><strong>TCP</strong>（Transmission Control Protocol）：面向连接的、可靠的传输协议，提供数据传输的完整性和顺序性。</li>
<li><strong>UDP</strong>（User Datagram Protocol）：无连接的、不可靠的数据传输协议，适合对速度要求高的场景。</li>
</ul>
<hr>
<h3 id="2-主要区别"><a href="#2-主要区别" class="headerlink" title="2. 主要区别"></a>2. <strong>主要区别</strong></h3><table>
<thead>
<tr>
<th><strong>比较维度</strong></th>
<th><strong>TCP</strong></th>
<th><strong>UDP</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>是否面向连接</strong></td>
<td>面向连接，需要建立连接（三次握手）</td>
<td>无连接，不需要建立连接</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>可靠传输，提供确认、重传、流量控制</td>
<td>不可靠传输，不保证数据是否送达</td>
</tr>
<tr>
<td><strong>传输方式</strong></td>
<td>面向字节流，数据按序传输</td>
<td>面向数据报，数据独立传输</td>
</tr>
<tr>
<td><strong>速度</strong></td>
<td>速度较慢，开销大</td>
<td>速度较快，开销小</td>
</tr>
<tr>
<td><strong>拥塞控制</strong></td>
<td>有拥塞控制和流量控制</td>
<td>无拥塞控制，发送速率不受限制</td>
</tr>
<tr>
<td><strong>头部开销</strong></td>
<td>头部较大（20~60 字节）</td>
<td>头部较小（8 字节）</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>适合需要可靠传输的应用，如HTTP、FTP等</td>
<td>适合实时传输或对可靠性要求较低的应用，如视频流、DNS、VoIP 等</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-应用场景举例"><a href="#3-应用场景举例" class="headerlink" title="3. 应用场景举例"></a>3. <strong>应用场景举例</strong></h3><ul>
<li><strong>TCP</strong>：<ul>
<li>HTTP&#x2F;HTTPS：网页传输，确保数据完整性。</li>
<li>FTP：文件传输，需要可靠的连接。</li>
<li>SMTP：电子邮件传输。</li>
</ul>
</li>
<li><strong>UDP</strong>：<ul>
<li>视频直播：允许丢包，优先保证速度。</li>
<li>DNS 查询：请求响应简单快速，无需建立连接。</li>
<li>网络语音通话（VoIP）：实时传输，对速度要求高。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-总结简洁回答"><a href="#4-总结简洁回答" class="headerlink" title="4. 总结简洁回答"></a>4. <strong>总结简洁回答</strong></h3><ul>
<li><strong>TCP</strong>：面向连接、可靠、慢，适合传输准确性要求高的场景。</li>
<li><strong>UDP</strong>：无连接、不可靠、快，适合实时和高性能传输的场景。</li>
</ul>
<p>这样作答既全面又清晰，面试官可以根据你的回答进一步提问，如“三次握手”、“拥塞控制”或实际应用例子。</p>
<h2 id="TCP-如何保证顺序，丢失、乱序后怎么处理？"><a href="#TCP-如何保证顺序，丢失、乱序后怎么处理？" class="headerlink" title="&#x3D;&#x3D;TCP 如何保证顺序，丢失、乱序后怎么处理？&#x3D;&#x3D;"></a>&#x3D;&#x3D;TCP 如何保证顺序，丢失、乱序后怎么处理？&#x3D;&#x3D;</h2><p>在面试中回答<strong>TCP 如何保证数据顺序</strong>，以及<strong>丢失和乱序后的处理</strong>，可以从<strong>序号机制</strong>、<strong>确认机制</strong> 和 <strong>重传机制</strong> 等方面展开，以下是详细回答：</p>
<hr>
<h3 id="1-TCP-如何保证数据顺序"><a href="#1-TCP-如何保证数据顺序" class="headerlink" title="1. TCP 如何保证数据顺序"></a>1. <strong>TCP 如何保证数据顺序</strong></h3><ul>
<li><strong>序号机制</strong>：<br>TCP 数据段的每个字节都会被分配一个<strong>序号（Sequence Number）</strong>，接收方根据数据段的序号来判断数据的顺序。<ul>
<li>发送方会按顺序将数据拆分成多个段，每个段带有序号。</li>
<li>接收方通过序号进行重新排序，确保数据按正确顺序交付给应用层。</li>
</ul>
</li>
<li><strong>确认应答机制（ACK）</strong>：<ul>
<li>接收方接收到数据后，会回复一个<strong>确认号（ACK Number）</strong>，表示下一个期望接收的字节序号。</li>
<li>如果数据乱序到达，接收方缓存乱序数据，等待缺失的数据到达再重组。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-TCP-数据丢失、乱序后的处理"><a href="#2-TCP-数据丢失、乱序后的处理" class="headerlink" title="2. TCP 数据丢失、乱序后的处理"></a>2. <strong>TCP 数据丢失、乱序后的处理</strong></h3><h4 id="2-1-数据丢失的处理"><a href="#2-1-数据丢失的处理" class="headerlink" title="2.1 数据丢失的处理"></a>2.1 <strong>数据丢失的处理</strong></h4><ul>
<li><strong>超时重传机制</strong>：<br>发送方发送数据后，会启动一个<strong>定时器</strong>。如果在规定时间内未收到确认应答（ACK），发送方会认为数据丢失，进行重传。<ul>
<li><strong>超时时间</strong>会根据往返时间（RTT，Round Trip Time）动态调整。</li>
</ul>
</li>
<li><strong>快速重传机制</strong>：<br>如果接收方发现<strong>某个数据段丢失</strong>（例如收到了多个重复的 ACK），发送方会立刻重传丢失的数据段，而<strong>无需等待超时</strong>。<ul>
<li>通常触发条件是收到<strong>三个重复的 ACK</strong>（即 3 次相同的确认号）。</li>
</ul>
</li>
</ul>
<h4 id="2-2-数据乱序的处理"><a href="#2-2-数据乱序的处理" class="headerlink" title="2.2 数据乱序的处理"></a>2.2 <strong>数据乱序的处理</strong></h4><ul>
<li><strong>接收方缓存乱序数据</strong>：<br>当接收方发现数据段乱序时（如序号不连续），接收方会将已经到达的数据暂时存入<strong>缓存</strong>，等待缺失的数据到达后再进行排序。<ul>
<li>接收方只会对正确接收到的数据发送 ACK，<strong>未接收的数据不会被确认</strong>。</li>
</ul>
</li>
<li><strong>重组数据</strong>：<br>一旦缺失的数据段到达，接收方会将缓存中的数据与新数据一起重组，按序号排列后再交付给应用层。</li>
</ul>
<hr>
<h3 id="3-示例场景"><a href="#3-示例场景" class="headerlink" title="3. 示例场景"></a>3. <strong>示例场景</strong></h3><p>假设发送方发送了 5 个数据段，序号依次是 1、2、3、4、5：</p>
<ol>
<li><strong>丢失</strong>：<ul>
<li>数据段 2 丢失，接收方只收到 1、3、4、5。</li>
<li>接收方会发送确认号（ACK）&#x3D; 2（表示期望收到序号 2）。</li>
<li>发送方收到多次 ACK&#x3D;2，触发<strong>快速重传机制</strong>，重传丢失的数据段 2。</li>
</ul>
</li>
<li><strong>乱序</strong>：<ul>
<li>数据段 2 到达晚了，接收方先收到 1、3、4、5。</li>
<li>接收方缓存 3、4、5，发送 ACK&#x3D;2。</li>
<li>等数据段 2 到达后，接收方将 2 和缓存中的 3、4、5 重新排序，再交付给应用层。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="4-总结回答"><a href="#4-总结回答" class="headerlink" title="4. 总结回答"></a>4. <strong>总结回答</strong></h3><ul>
<li><strong>顺序保证</strong>：通过序号机制和接收方的确认号，确保数据按序交付。</li>
<li><strong>丢失处理</strong>：发送方通过<strong>超时重传</strong>和<strong>快速重传机制</strong>重传丢失的数据。</li>
<li><strong>乱序处理</strong>：接收方会缓存乱序数据，等待缺失的数据到达后重新排序再交付。</li>
</ul>
<p>通过这些机制，TCP 能够实现数据的可靠、按序传输，确保最终数据完整无误地送达应用层。</p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><strong>HTTP（HyperText Transfer Protocol）</strong> 是一种用于客户端和服务器之间传输超文本数据的协议，基于请求-响应模型，支持浏览器与网页之间的通信。</p>
<h3 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h3><p>我的观点：不用记，看到搜一下就行</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20241219155940723.png" style="zoom:70%;">



<pre><code>1．HTTP规定在HTTP客户与HTTP服务器之间的每次交互，都由一个ASCII码串构成的请求和一个“类MIME（MIME—like）”的相应组成。HTTP报文通常都是用TCP连接

2．从层次的角度看，HTTP是面向事务的应用层协议。所谓事务，就是指一系列的信息交换，而这一系列的信息交换是一个不可分割的整体，即要么所有信息交换都完成，要么一次交换都不进行。

3．HTTP协议本身是无连接的，虽然HTTP使用了TCP连接，但通信的双方在交换HTTP报文前不需要建立HTTP连接。

4．HTTP协议时无状态的，也就是说，同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次被访问时的相同。

5．万维网客户把HTTP请求报文作为TCP连接三次握手的第三个报文的数据发送给万维网服务器，服务器收到HTTP请求报文后，就把所请求的文档作为响应报文返回给客户。

6．HTTP/1.0的主要缺点，是每请求一个文档就要有两倍RTT的开销。HTTP/1.1使用持续连接。所谓持续连接，就是万维网服务器在发送响应后仍然在一段时间内保持这条连接，使同一个客户（浏览器）和该服务器可以继续在这条连接上传送后续的HTTP请求报文和响应报文，这并不局限于传送同一个页面上链接的文档，而是只要这些文档都在同一个服务器上就行。

7．HTTP/1.1协议的持续连接有两种方式，即非流水线方式和流水线方式。非流水线方式的特点是，客户在收到前一个响应后才能发出下一个请求；流水线方式的特点是，客户在收到HTTP的响应报文之前就能接着发送新的请求报文。

8．HTTP请求报文和响应报文都由三个部分组成：开始行、首部行、实体主题。开始行用于区别报文时响应报文还是请求报文，在请求报文中，开始行叫做请求行，而在响应报文中，开始行叫做状态行。

9．请求报文请求行只有三个内容：方法、请求资源的URL、HTTP的版本。响应报文的状态行也包括三项内容：HTTP的版本、状态码、解释状态码的简单短语。

10．状态码都是三位数字的，分为5大类共33种，例如：

1xx表示通知信息的，如请求收到了或正在进行处理

2xx表示成功，如接受或知道了；

3xx表示重定向，如果完成请求，还必须采取进一步的行动；

4xx表示客户端错误，如请求中有错误的语法或不能完成；

5xx表示服务端错误，如服务器失效无法完成请求。

11．在浏览器地址栏键入URL，按下回车之后发生的几个事件：

1）浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址；

2）解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接；

3）浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器；

4）服务器给出相应，把对应的html文本发送给浏览器；

5）释放TCP连接；

6）浏览器将该文本显示出来。
</code></pre>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124073217122.png" alt="image-20221124073217122" style="zoom:50%;">

<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124073232065.png" alt="image-20221124073232065" style="zoom:50%;">

<p><strong>HTTP 是一种不保存状态，即无状态（stateless）协议</strong>。HTTP 协议自 身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个 级别，协议对于发送过的请求或响应都不做持久化处理。</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124073333218.png" alt="image-20221124073333218" style="zoom:50%;">

<p>HTTP+ 加密 + 认证 + 完整性保护 &#x3D;HTTPS</p>
<p>HTTPS 是身披 SSL 外壳的 HTTP</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124073548253.png" alt="image-20221124073548253" style="zoom:60%;">

<p>加密方法：</p>
<ul>
<li>共享密钥加密</li>
</ul>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124073737002.png" alt="image-20221124073737002" style="zoom:50%;">

<ul>
<li>使用两把锁的公开密钥加密</li>
</ul>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124073757579.png" alt="image-20221124073757579" style="zoom:50%;">

<p>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密 机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开 密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处 理速度要慢。 </p>
<p>在交换密钥环节使用公开密钥加密方式，之后的建立通信交 换报文阶段则使用共享密钥加密方式。</p>
<p>证明公开密钥正确性的证书：</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124073905927.png" alt="image-20221124073905927" style="zoom:67%;">

<p><strong>HTTPS 通信</strong></p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124074013952.png" alt="image-20221124074013952" style="zoom:67%;">

<blockquote>
<p>步骤 1： 客户端通过发送 Client Hello 报文开始 SSL通信。报文中包 含客户端支持的 SSL的指定版本、加密组件（Cipher Suite）列表（所 使用的加密算法及密钥长度等）。 </p>
<p>步骤 2： 服务器可进行 SSL通信时，会以 Server Hello 报文作为应 154 答。和客户端一样，在报文中包含 SSL版本以及加密组件。服务器的 加密组件内容是从接收到的客户端加密组件内筛选出来的。 </p>
<p>步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证 书。 </p>
<p>步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶 段的 SSL握手协商部分结束。 </p>
<p>步骤 5： SSL第一次握手结束之后，客户端以 Client Key Exchange 报 文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。 </p>
<p>步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提 示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。 </p>
<p>步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的 整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确 解密该报文作为判定标准。 </p>
<p>步骤 8： 服务器同样发送 Change Cipher Spec 报文。</p>
<p>步骤 9： 服务器同样发送 Finished 报文。 </p>
<p>步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL连接 就算建立完成。当然，通信会受到 SSL的保护。从此处开始进行应用 层协议的通信，即发送 HTTP 请求。 </p>
<p>步骤 11： 应用层协议通信，即发送 HTTP 响应。 </p>
<p>步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报 文。这步之后再发送 TCP FIN 报文来关闭与 TCP 的通信。</p>
</blockquote>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20221124074143910.png" style="zoom:67%;">

<h2 id="HTTP-HTTPS-比较"><a href="#HTTP-HTTPS-比较" class="headerlink" title="&#x3D;&#x3D;HTTP HTTPS 比较&#x3D;&#x3D;"></a>&#x3D;&#x3D;<strong>HTTP HTTPS 比较</strong>&#x3D;&#x3D;</h2><ul>
<li>HTTPS 需要到 ca 申请证书，支付费用</li>
<li>HTTP 是超文本传输协议，明文传输；HTTPS 是具有安全性的 SSL 加密传输协议</li>
<li>使用完全不同的连接方式，端口也不同，HTTP 是 80，HTTPS 是 443</li>
<li>HTTP 连接简单、无状态；HTTPS 是由 SSL+HTTP 构建的可进行加密传输、身份验证的网络协议，更安全</li>
</ul>
<p>&#x3D;&#x3D;<strong>HTTPS 缺点</strong>&#x3D;&#x3D;</p>
<ul>
<li>HTTPS协议握手阶段比较费时，会使页面的加载时间延长近50%，增加10%到20%的耗电</li>
<li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响</li>
<li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用</li>
<li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗</li>
<li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行</li>
</ul>
<h2 id="输入一个-URL-到页面发生了啥？"><a href="#输入一个-URL-到页面发生了啥？" class="headerlink" title="&#x3D;&#x3D;输入一个 URL 到页面发生了啥？&#x3D;&#x3D;"></a>&#x3D;&#x3D;输入一个 URL 到页面发生了啥？&#x3D;&#x3D;</h2><p>参考：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/1_base/what_happen_url.html#%E5%AD%A4%E5%8D%95%E5%B0%8F%E5%BC%9F-http%EF%BC%88*%E6%9C%89%E7%82%B9%E5%A4%AA%E8%AF%A6%E7%BB%86%EF%BC%8C%E8%BF%98%E6%B2%A1%E8%AE%B0%E4%BD%8F%EF%BC%89">https://xiaolincoding.com/network/1_base/what_happen_url.html#%E5%AD%A4%E5%8D%95%E5%B0%8F%E5%BC%9F-http（*有点太详细，还没记住）</a>*</p>
<img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20240414114943345.png" style="zoom:80%;"> 

<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uL4y1B7aE/?spm_id_from=333.788&vd_source=72199420565ce921d3802604346f70b1"><strong>DNS 解析</strong></a>：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把<strong>域名转换成相应 IP 地址</strong>。<ul>
<li>本地缓存检查：浏览器缓存、操作系统缓存</li>
<li>本地 DNS 服务器：如果本地没有缓存，操作系统会向本地的 DNS 服务器（通常由 ISP 提供）发起查询。</li>
<li>递归查询：本地 DNS 服务器没有记录，它会按层级向更高级的 DNS 服务器查询。</li>
<li>返回结果：<strong>权威 DNS 服务器 → 顶级域名服务器 → 本地 DNS 服务器 → 客户端</strong>。</li>
<li>存在问题，比如 DNS 劫持：攻击者篡改 DNS 记录，将用户引导到伪造网站。</li>
</ul>
</li>
<li><strong>TCP 连接</strong>：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接。</li>
<li>建立TCP协议时，需要发送数据，发送数据在网络层使用IP协议， 通过IP协议将IP地址封装为IP数据报；然后此时会用到ARP协议，主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址，找到目的MAC地址；</li>
<li>IP数据包在路由器之间，路由选择使用OPSF协议， 采用Dijkstra算法来计算最短路径树，抵达服务端。</li>
<li><strong>发送 HTTP 请求</strong>：建立 TCP 连接之后，浏览器向 Web 服务器发起一个 HTTP 请求（如果是HTTPS协议，发送HTTP 请求之前还需要完成TLS四次握手）；</li>
<li><strong>处理请求并返回</strong>：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</li>
<li><strong>浏览器渲染</strong>：浏览器根据响应开始<strong>显示页面</strong>，首先解析 <strong>HTML 文件</strong>构建 DOM 树，然后解析 <strong>CSS 文件</strong>构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</li>
<li>TCP四次挥手断开连接</li>
</ul>
<h2 id="单工和双工的区别"><a href="#单工和双工的区别" class="headerlink" title="单工和双工的区别"></a>单工和双工的区别</h2><p>单工（Simplex）和双工（Duplex）是两种通信方式，它们的主要区别在于信息传输的方向性：</p>
<ol>
<li><strong>单工（Simplex）</strong>：通信过程中信息只能单向传输，数据从发送端传输到接收端，但接收端不能向发送端发送任何反馈或数据。例如，广播、电视信号传输就是单工通信。</li>
<li><strong>双工（Duplex）</strong>：通信过程中的信息可以双向传输。双工通信有两种类型：<ul>
<li><strong>半双工（Half-Duplex）</strong>：信息可以在两个方向上传输，但不能同时进行。也就是说，通信双方可以交替发送和接收数据，但不能同时发送。例如，步话机就是半双工通信设备。</li>
<li><strong>全双工（Full-Duplex）</strong>：信息可以在两个方向同时传输。双方可以同时发送和接收数据。例如，电话通信就是全双工通信。</li>
</ul>
</li>
</ol>
<h2 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h2><p><strong>Cookie</strong> 是<strong>存储在客户端浏览器中的小型文本数据</strong>，用于在客户端和服务器之间传递用户状态信息，比如记住<u>用户登录信息</u>、<u>偏好设置</u>。</p>
<p><strong>为什么要传递用户状态信息</strong>：<strong>HTTP 协议是无状态的</strong>，每次请求都独立，服务器无法知道请求是否来自同一用户。通过 Cookie，服务器可以<u>识别用户、存储状态</u>，从而实现个性化服务（如自动登录、购物车）。</p>
<hr>
<p><strong>Session</strong> 是一种<strong>服务器端的会话管理机制</strong>，用于在用户与服务器的多个请求之间保持状态。</p>
<p>当用户登录时，服务器创建一个 Session，并生成一个唯一的 <strong>Session ID</strong>，将它返回给客户端（通常通过 Cookie 或 URL）。之后，每次请求客户端都会携带这个 <strong>Session ID</strong>，服务器根据它识别用户并提供对应的会话数据（如登录状态、购物车内容等）。</p>
<p>简单来说，<strong>Session</strong> 就是服务器用来“记住”用户的工具。</p>
<hr>
<p><strong>Cookie 和 Session 的核心区别在于存储位置：</strong></p>
<ul>
<li><strong>Cookie</strong> 存在客户端浏览器中，每次请求都会携带到服务器，适合存储少量、不敏感的数据（如用户偏好）。</li>
<li><strong>Session</strong> 存在服务器端，客户端只保存一个标识（<code>Session ID</code>），适合存储敏感信息（如登录状态）。</li>
</ul>
<p>本质作用都是用来维护客户状态，区别在于存储位置和存储信息的敏感程度不一样。按理来说可以都存在 Server 的Session 上，但是 Server 会感到鸭力，所以有一部分不太重要的数据存在 Client 的 Cookie 上。</p>
<hr>
<p><strong>使用 ChatGPT 时突然告诉我会话过期，需要重新登录。从网络的角度解释一下为什么</strong></p>
<p><strong>Session 超时</strong></p>
<ul>
<li><strong>原因</strong>：服务器为了节省资源，会为每个用户的 Session 设置超时时间（如 30 分钟）。如果超出这个时间段没有活动，Session 会自动失效。</li>
<li><strong>表现</strong>：你需要重新登录，服务器会重新分配一个新的 Session。</li>
<li><strong>网络层面</strong>：Session 失效后，客户端发送的 <code>Session ID</code> 不再被服务器识别。</li>
</ul>
<h3 id="固定端口号、常用端口号、自定义端口号的解释与区别"><a href="#固定端口号、常用端口号、自定义端口号的解释与区别" class="headerlink" title="固定端口号、常用端口号、自定义端口号的解释与区别"></a><strong>固定端口号、常用端口号、自定义端口号的解释与区别</strong></h3><p>在网络通信中，端口号（Port Number）用于区分同一台主机上的不同服务或应用程序。端口号范围是 <strong>0~65535</strong>，以下是关于 <strong>固定端口号</strong>、<strong>常用端口号</strong> 和 <strong>自定义端口号</strong> 的详细解释：</p>
<hr>
<h3 id="1-固定端口号"><a href="#1-固定端口号" class="headerlink" title="1. 固定端口号"></a><strong>1. 固定端口号</strong></h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h4><ul>
<li>固定端口号是指由 <strong>IANA（Internet Assigned Numbers Authority）</strong> 官方分配，用于标准网络服务的端口号。这些端口号是 <strong>服务的默认端口</strong>，在全球范围内被广泛使用。</li>
<li><strong>范围</strong>：<code>0~1023</code>，也称为 <strong>系统端口（Well-Known Ports）</strong>。</li>
</ul>
<h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a><strong>特点</strong>：</h4><ul>
<li>必须具有管理员权限才能在系统中绑定这些端口。</li>
<li>已被标准协议定义和保留，用于特定服务。</li>
</ul>
<h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例</strong>：</h4><table>
<thead>
<tr>
<th>协议 &#x2F; 服务</th>
<th>默认端口号</th>
</tr>
</thead>
<tbody><tr>
<td>HTTP</td>
<td>80</td>
</tr>
<tr>
<td>HTTPS</td>
<td>443</td>
</tr>
<tr>
<td>FTP（文件传输协议）</td>
<td>21</td>
</tr>
<tr>
<td>SSH（安全外壳协议）</td>
<td>22</td>
</tr>
<tr>
<td>Telnet（远程登录协议）</td>
<td>23</td>
</tr>
<tr>
<td>SMTP（邮件传输协议）</td>
<td>25</td>
</tr>
<tr>
<td>DNS（域名服务）</td>
<td>53</td>
</tr>
<tr>
<td>DHCP（动态主机配置协议）</td>
<td>67&#x2F;68</td>
</tr>
</tbody></table>
<hr>
<h3 id="2-常用端口号"><a href="#2-常用端口号" class="headerlink" title="2. 常用端口号"></a><strong>2. 常用端口号</strong></h3><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a><strong>定义</strong>：</h4><ul>
<li>常用端口号是指被广泛应用的端口号，包括固定端口号和一些 <strong>动态分配或非标准服务的端口号</strong>。</li>
<li>包括一些高于 1023 的常见服务端口。</li>
</ul>
<h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a><strong>特点</strong>：</h4><ul>
<li>通常是服务和工具的默认端口号。</li>
<li>不一定是 IANA 保留的，但被开发者和网络工具默认使用。</li>
</ul>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例</strong>：</h4><table>
<thead>
<tr>
<th>应用 &#x2F; 服务</th>
<th>常用端口号</th>
</tr>
</thead>
<tbody><tr>
<td>MySQL</td>
<td>3306</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>5432</td>
</tr>
<tr>
<td>Redis</td>
<td>6379</td>
</tr>
<tr>
<td>MongoDB</td>
<td>27017</td>
</tr>
<tr>
<td>Kafka</td>
<td>9092</td>
</tr>
<tr>
<td>Elasticsearch</td>
<td>9200</td>
</tr>
<tr>
<td>RabbitMQ</td>
<td>5672</td>
</tr>
<tr>
<td>Nginx（默认）</td>
<td>8080</td>
</tr>
<tr>
<td>Memcached</td>
<td>11211</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-自定义端口号"><a href="#3-自定义端口号" class="headerlink" title="3. 自定义端口号"></a><strong>3. 自定义端口号</strong></h3><h4 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a><strong>定义</strong>：</h4><ul>
<li>自定义端口号是指由用户或开发者根据需求自行选择的端口号，用于运行自己的服务。</li>
<li>一般选择 <strong>1024~65535</strong> 范围内未被占用的端口号。</li>
</ul>
<h4 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a><strong>特点</strong>：</h4><ul>
<li>适合开发环境、调试环境或非标准服务。</li>
<li>应避免与常用端口号冲突，尤其是知名的服务端口号。</li>
</ul>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a><strong>示例</strong>：</h4><ul>
<li>自定义 Web 服务端口：<code>8081</code>、<code>9000</code>。</li>
<li>内部通信或微服务端口：<code>5000</code>、<code>6000</code>。</li>
<li>临时测试服务：随机分配端口。</li>
</ul>
<h4 id="如何选择自定义端口号："><a href="#如何选择自定义端口号：" class="headerlink" title="如何选择自定义端口号："></a><strong>如何选择自定义端口号</strong>：</h4><ol>
<li><p><strong>避开常用端口</strong>：确保不会占用标准服务端口。</p>
</li>
<li><p><strong>使用动态端口</strong>：选择 <code>49152~65535</code> 范围（IANA 动态端口号）。</p>
</li>
<li><p>确保端口未被占用</p>
<p>：可以通过以下命令检查：</p>
<ul>
<li><p>Linux&#x2F;macOS</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">netstat -tuln | grep &lt;port_number&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Windows</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制代码</span><br><span class="line">netstat -a -n -o | find &quot;&lt;port_number&gt;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<hr>
<h3 id="端口号范围的划分"><a href="#端口号范围的划分" class="headerlink" title="端口号范围的划分"></a><strong>端口号范围的划分</strong></h3><p>根据 <strong>IANA</strong> 的规范，端口号分为以下三类：</p>
<table>
<thead>
<tr>
<th><strong>范围</strong></th>
<th><strong>名称</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>0~1023</code></td>
<td><strong>系统端口（Well-Known Ports）</strong></td>
<td>固定端口号，常用于标准网络服务和协议。</td>
</tr>
<tr>
<td><code>1024~49151</code></td>
<td><strong>注册端口（Registered Ports）</strong></td>
<td>通常分配给非标准服务或特定应用程序。</td>
</tr>
<tr>
<td><code>49152~65535</code></td>
<td><strong>动态端口 &#x2F; 私有端口（Dynamic &#x2F; Private Ports）</strong></td>
<td>自定义端口号，主要用于临时连接或服务通信。</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-三者的比较"><a href="#4-三者的比较" class="headerlink" title="4. 三者的比较"></a><strong>4. 三者的比较</strong></h3><table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>范围</strong></th>
<th><strong>特点</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>固定端口号</strong></td>
<td>0~1023</td>
<td>由 IANA 官方保留，用于标准服务协议。</td>
<td>HTTP（80），HTTPS（443）</td>
</tr>
<tr>
<td><strong>常用端口号</strong></td>
<td>包括部分 1024~65535</td>
<td>被广泛使用的非标准端口号或工具默认端口。</td>
<td>MySQL（3306），Redis（6379）</td>
</tr>
<tr>
<td><strong>自定义端口号</strong></td>
<td>1024~65535</td>
<td>用户根据需求选择的端口，适合非标准服务或内部通信。</td>
<td>8081（开发服务器），9000（测试）</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-实际应用场景"><a href="#5-实际应用场景" class="headerlink" title="5. 实际应用场景"></a><strong>5. 实际应用场景</strong></h3><h4 id="（1）固定端口号"><a href="#（1）固定端口号" class="headerlink" title="（1）固定端口号"></a><strong>（1）固定端口号</strong></h4><ul>
<li><p>适用场景</p>
<p>：标准服务对外提供服务时。</p>
<ul>
<li>如：Web 服务器监听 <code>80</code> 或 <code>443</code>。</li>
</ul>
</li>
<li><p><strong>为什么固定</strong>：让客户端能通过统一的端口号找到对应服务。</p>
</li>
</ul>
<h4 id="（2）常用端口号"><a href="#（2）常用端口号" class="headerlink" title="（2）常用端口号"></a><strong>（2）常用端口号</strong></h4><ul>
<li><p>适用场景</p>
<p>：默认端口号更易于设置和调试。</p>
<ul>
<li>如：数据库（MySQL）使用默认端口 <code>3306</code>，无需配置。</li>
</ul>
</li>
<li><p><strong>灵活性</strong>：可以更改为其他端口以避免冲突。</p>
</li>
</ul>
<h4 id="（3）自定义端口号"><a href="#（3）自定义端口号" class="headerlink" title="（3）自定义端口号"></a><strong>（3）自定义端口号</strong></h4><ul>
<li><p>适用场景</p>
<p>：开发环境、微服务或私有服务。</p>
<ul>
<li>如：本地开发时，多个服务需要运行在同一台机器上（避免端口冲突）。</li>
<li>微服务的内部通信：通过 <code>5000~9000</code> 范围的自定义端口号通信。</li>
</ul>
</li>
<li><p><strong>优势</strong>：灵活，避免占用标准端口，减少潜在冲突。</p>
</li>
</ul>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol>
<li><strong>固定端口号</strong>：标准服务的默认端口（0~1023），如 HTTP（80）、SSH（22）。</li>
<li><strong>常用端口号</strong>：流行应用的默认端口（包括固定和非固定），如 MySQL（3306）、Redis（6379）。</li>
<li><strong>自定义端口号</strong>：开发者根据需要选择的端口，通常在 1024~65535 范围内，避开固定和常用端口。</li>
</ol>
<p>在实际开发和部署中，选择端口号时应根据 <strong>服务类型、是否冲突、安全性要求</strong> 来合理分配端口。</p>
<h2 id="扫码登陆的原理"><a href="#扫码登陆的原理" class="headerlink" title="扫码登陆的原理"></a>扫码登陆的原理</h2><p><strong>1. 生成二维码</strong><br>PC 端请求服务器生成一个 <strong>UUID</strong>，服务器返回一个带有 UUID 的二维码，PC 端展示给用户。</p>
<p><strong>2. 移动端扫描二维码</strong><br>用户用已登录的 APP 扫描二维码，APP 解析出 UUID，并向服务器查询该 UUID 的状态。</p>
<p><strong>3. 用户授权</strong><br>APP 端弹出确认框，用户授权后，APP 发送请求给服务器，通知服务器该 UUID 已授权，并携带用户身份信息。</p>
<p><strong>4. 服务器通知 PC 端</strong><br>服务器更新 UUID 状态，并通知 PC 端：</p>
<ul>
<li>方式 1：PC 端轮询服务器，获取授权状态。</li>
<li>方式 2：服务器通过 WebSocket 推送授权成功的消息。</li>
</ul>
<p><strong>5. PC 端完成登录</strong><br>PC 端收到授权信息后，使用服务器返回的 Token 建立登录状态，跳转到已登录页面。</p>
<p><img src="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20250105213533181.png" alt="image-20250105213533181"></p>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 王才雨
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
