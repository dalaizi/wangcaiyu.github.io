<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>MySQL | Hexo</title>
  <meta name="keywords" content="">
  <meta name="description" content="MySQL | Hexo">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="IELTS WritingTask 1Introduction -&gt; Overview -&gt; Detail -&gt; Detail (No Conclusion and opinions!) Notes: 时态不要错！！  PS: 看 便便 的两个 pdf 小作文模板  上升： v rise - rose - risen - rising	n rise v increase - in">
<meta property="og:type" content="article">
<meta property="og:title" content="IELTS Writing">
<meta property="og:url" content="http://example.com/2024/10/10/IELTS-Writing/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="IELTS WritingTask 1Introduction -&gt; Overview -&gt; Detail -&gt; Detail (No Conclusion and opinions!) Notes: 时态不要错！！  PS: 看 便便 的两个 pdf 小作文模板  上升： v rise - rose - risen - rising	n rise v increase - in">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903143929000.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240912122709201.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903154014772.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903170338309.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241008162149573.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903221950372.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240908183744208.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240909115534553.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241006134635925.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/36195076c5bf4f8798d6a3a1a7e8b009.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004223753876.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241003185429807.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241003190448385.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004194259889.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222854805.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222634264.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222706508.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004223109519.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222732028.png">
<meta property="og:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20241004222806949.png">
<meta property="article:published_time" content="2024-10-10T07:06:24.000Z">
<meta property="article:modified_time" content="2024-10-10T07:07:10.746Z">
<meta property="article:author" content="王才雨">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2024/10/10/IELTS-Writing/image-20240903143929000.png">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>王才雨</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/dalaizi"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:1935863093@qq.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="qq"
               href="http://wpa.qq.com/msgrd?v=3&uin=1935863093&site=qq&menu=yes"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-qq"></use>
                    </svg>
                
            </a>
        
    
</div>





<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(19)</small>
            
        </div>
    </li>
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
            <a class="about  hasFriend  site_url"
               
               href="/about">About</a>
        
        <a style="width: 50%"
                
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="19">

<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All "
           href="/2024/11/18/Netty/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Netty">Netty</span>
            <span class="post-date" title="2024-11-18 09:00:27">2024/11/18</span>
        </a>
        
        
        <a  class="All "
           href="/2024/10/10/IELTS-Writing/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="IELTS Writing">IELTS Writing</span>
            <span class="post-date" title="2024-10-10 15:06:24">2024/10/10</span>
        </a>
        
        
        <a  class="All "
           href="/2024/04/18/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="操作系统">操作系统</span>
            <span class="post-date" title="2024-04-18 11:20:09">2024/04/18</span>
        </a>
        
        
        <a  class="All "
           href="/2024/04/03/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RPC/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解RPC">深入理解RPC</span>
            <span class="post-date" title="2024-04-03 13:06:31">2024/04/03</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="设计模式">设计模式</span>
            <span class="post-date" title="2024-03-29 21:02:25">2024/03/29</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/20/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="UNIX网络编程">UNIX网络编程</span>
            <span class="post-date" title="2024-03-20 15:03:46">2024/03/20</span>
        </a>
        
        
        <a  class="All "
           href="/2024/03/17/Spring/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Spring">Spring</span>
            <span class="post-date" title="2024-03-17 00:40:34">2024/03/17</span>
        </a>
        
        
        <a  class="All "
           href="/2024/02/25/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="后端开发面试题">后端开发面试题</span>
            <span class="post-date" title="2024-02-25 15:47:51">2024/02/25</span>
        </a>
        
        
        <a  class="All "
           href="/2024/01/05/Linux/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Linux">Linux</span>
            <span class="post-date" title="2024-01-05 13:29:00">2024/01/05</span>
        </a>
        
        
        <a  class="All "
           href="/2023/11/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="力扣刷题">力扣刷题</span>
            <span class="post-date" title="2023-11-22 17:10:44">2023/11/22</span>
        </a>
        
        
        <a  class="All "
           href="/2023/10/08/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="动态代理">动态代理</span>
            <span class="post-date" title="2023-10-08 22:49:01">2023/10/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/04/08/%E9%A1%B9%E7%9B%AERPC%E6%A1%86%E6%9E%B6/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="项目RPC框架">项目RPC框架</span>
            <span class="post-date" title="2023-04-08 19:49:23">2023/04/08</span>
        </a>
        
        
        <a  class="All "
           href="/2023/01/02/redis/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="redis">redis</span>
            <span class="post-date" title="2023-01-02 17:46:17">2023/01/02</span>
        </a>
        
        
        <a  class="All "
           href="/2022/12/24/MySQL/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="MySQL">MySQL</span>
            <span class="post-date" title="2022-12-24 11:40:50">2022/12/24</span>
        </a>
        
        
        <a  class="All "
           href="/2022/11/11/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java并发编程">Java并发编程</span>
            <span class="post-date" title="2022-11-11 16:20:42">2022/11/11</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/30/JVM%E8%B0%83%E4%BC%98/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="JVM调优">JVM调优</span>
            <span class="post-date" title="2022-10-30 20:09:07">2022/10/30</span>
        </a>
        
        
        <a  class="All "
           href="/2022/10/19/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="深入理解Java虚拟机">深入理解Java虚拟机</span>
            <span class="post-date" title="2022-10-19 10:40:02">2022/10/19</span>
        </a>
        
        
        <a  class="All "
           href="/2022/06/04/Java%E7%9F%A5%E8%AF%86%E7%82%B9/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Java知识点">Java知识点</span>
            <span class="post-date" title="2022-06-04 10:58:21">2022/06/04</span>
        </a>
        
        
        <a  class="All "
           href="/2022/02/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"
           data-tag=""
           data-author="" >
            <span class="post-title" title="计算机网络">计算机网络</span>
            <span class="post-date" title="2022-02-06 18:11:21">2022/02/06</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-MySQL" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">MySQL</h1>
    
    <div class="article-meta">
        
        
        
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2025-01-05 23:27:20'>2022-12-24 11:40</time>
        
    </div>
    <div class="article-meta">
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">一、基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MySQL-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="toc-text">1. MySQL 服务器逻辑架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E9%80%BB%E8%BE%91%E5%88%86%E5%B1%82"><span class="toc-text">1.1 逻辑分层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-SQL-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%88%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;1.2 SQL 执行流程（服务器角度）&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-SQL-%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%88%E4%BB%A3%E7%A0%81%E8%A7%92%E5%BA%A6%EF%BC%89"><span class="toc-text">1.3 SQL 语句执行顺序（代码角度）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%AF%87"><span class="toc-text">锁篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%94%81%E7%B2%92%E5%BA%A6%E5%88%86%E7%B1%BB"><span class="toc-text">按锁粒度分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-text">1）全局锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-text">2）表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%EF%BC%88MDL%EF%BC%89"><span class="toc-text">元数据锁（MDL）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">意向锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E8%A1%8C%E7%BA%A7%E9%94%81%EF%BC%88InnoDB%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;3）行级锁（InnoDB）&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Record-Lock"><span class="toc-text">Record Lock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Gap-Lock"><span class="toc-text">Gap Lock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Next-Key-Lock"><span class="toc-text">Next-Key Lock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-text">插入意向锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-MySQL-%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%EF%BC%9F"><span class="toc-text">2.3 MySQL 是怎么加行级锁的？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="toc-text">唯一索引等值查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-text">唯一索引范围查询</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2"><span class="toc-text">非唯一索引等值查询</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%AE%B0%E5%BD%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">1、记录不存在的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E8%AE%B0%E5%BD%95%E5%AD%98%E5%9C%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">2、记录存在的情况</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-text">非唯一索引范围查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E5%8A%A0%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-text">没有加索引的查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#update%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%85%B7%E4%BD%93%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-text">update语句的具体执行过程是怎样的？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%AF%87"><span class="toc-text">事务篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID"><span class="toc-text">ACID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-text">隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%89%E6%9C%AA%E6%8F%90%E4%BA%A4%E8%AF%BB-READ-UNCOMMITTED"><span class="toc-text">1）未提交读 READ UNCOMMITTED</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%89%E6%8F%90%E4%BA%A4%E8%AF%BB%EF%BC%88%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%89READ-COMMITTED"><span class="toc-text">2）提交读（不可重复读）READ COMMITTED</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%89%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89REPEATABLE-READ"><span class="toc-text">3）可重复读（默认）REPEATABLE READ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%89%E4%B8%B2%E8%A1%8C%E5%8C%96-SERIALIZABLE"><span class="toc-text">4）串行化 SERIALIZABLE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC"><span class="toc-text">MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-text">幻读的解决方法：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%AD%BB%E9%94%81"><span class="toc-text">3.3 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="toc-text">3.4 事务日志</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%8B%E7%BB%8D"><span class="toc-text">4. 存储引擎介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-InnoDB"><span class="toc-text">4.1 InnoDB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-MyISAM"><span class="toc-text">4.2 MyISAM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%97%A5%E5%BF%97%EF%BC%88%E4%B8%8D%E4%BA%86%E8%A7%A3%EF%BC%8C%E5%AD%A6%E4%B8%80%E4%B8%8B%EF%BC%89"><span class="toc-text">5. 日志（不了解，学一下）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8Bmysql-%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-text">介绍一下mysql 的日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84%EF%BC%9F"><span class="toc-text">redo log怎么保证持久性的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E5%8F%AA%E7%94%A8binlog%E4%B8%8D%E7%94%A8relo-log%EF%BC%9F"><span class="toc-text">能不能只用binlog不用relo log？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%93%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="toc-text">库表优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">优化数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySql-schema-%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-text">MySql schema 设计中的陷阱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%BC%8F%E5%92%8C%E5%8F%8D%E8%8C%83%E5%BC%8F"><span class="toc-text">范式和反范式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A1%A8%E5%92%8C%E6%B1%87%E6%80%BB%E8%A1%A8"><span class="toc-text">缓存表和汇总表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%BF%AB-ALTER-TABLE-%E6%93%8D%E4%BD%9C%E7%9A%84%E9%80%9F%E5%BA%A6"><span class="toc-text">加快 ALTER TABLE 操作的速度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E4%BF%AE%E6%94%B9-frm-%E6%96%87%E4%BB%B6"><span class="toc-text">只修改 .frm 文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA-MyISAM-%E7%B4%A2%E5%BC%95"><span class="toc-text">快速创建 MyISAM 索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AF%87"><span class="toc-text">索引篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 索引类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-Tree-%E7%B4%A2%E5%BC%95"><span class="toc-text">B-Tree 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#why-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E6%98%AFB-%E6%A0%91%E4%B8%8D%E6%98%AFB%E6%A0%91%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D;why 索引结构是B+树不是B树？&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%EF%BC%9AMySQL-%E4%B8%AD%E6%98%AF%E6%80%8E%E4%B9%88%E5%88%A9%E7%94%A8%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E8%8C%83%E5%9B%B4%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F"><span class="toc-text">&#x3D;&#x3D;问：MySQL 中是怎么利用索引查找范围数据的？&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-text">哈希索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-text">聚簇索引 &amp; 二级索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">索引的优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%8F%B6%E8%A7%92%E5%BA%A6%E7%9C%8B-B-%E6%A0%91"><span class="toc-text">从数据叶角度看 B+ 树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84%EF%BC%9F"><span class="toc-text"> InnoDB 是如何存储数据的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%B8%8D%E9%9C%80%E8%A6%81%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-text">什么时候不需要创建索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text">3.索引失效的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%AF%B9%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E3%80%81%E5%87%BD%E6%95%B0"><span class="toc-text">3.1 对索引使用表达式、函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E5%92%8C%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9%E6%80%A7"><span class="toc-text">3.2 前缀索引和索引选择性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E7%B4%A2%E5%BC%95%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">对索引隐式类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%A4%9A%E5%88%97%E7%B4%A2%E5%BC%95"><span class="toc-text">3.3 多列索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E5%90%88%E9%80%82%E7%9A%84%E7%B4%A2%E5%BC%95%E9%A1%BA%E5%BA%8F"><span class="toc-text">3.4 合适的索引顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%81%EF%BC%81-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-text">！！&#x3D;&#x3D;覆盖索引&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%E6%89%AB%E6%8F%8F%E6%8E%92%E5%BA%8F"><span class="toc-text">使用索引扫描排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%8E%8B%E7%BC%A9%E7%B4%A2%E5%BC%95"><span class="toc-text">前缀压缩索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E5%92%8C%E9%87%8D%E5%A4%8D%E7%B4%A2%E5%BC%95"><span class="toc-text">冗余和重复索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%92%8C%E9%94%81"><span class="toc-text">索引和锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%8A%A4%E7%B4%A2%E5%BC%95%E5%92%8C%E8%A1%A8"><span class="toc-text">维护索引和表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%BE%E5%88%B0%E5%B9%B6%E4%BF%AE%E5%A4%8D%E7%B4%A2%E5%BC%95%E8%A1%A8"><span class="toc-text">找到并修复索引表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%B4%A2%E5%BC%95%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-text">更新索引统计信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E7%B4%A2%E5%BC%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%9A%84%E7%A2%8E%E7%89%87"><span class="toc-text">减少索引和数据的碎片</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">四、查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E4%B8%8BSQL%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95-%EF%BC%88%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B8%8D%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;讲一下SQL优化方法&#x3D;&#x3D;（联表查询不了解）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-text">1. 优化数据访问</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%98%AF%E5%90%A6%E5%90%91%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%B7%E6%B1%82%E4%BA%86%E4%B8%8D%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-text">1.1 是否向数据库请求了不需要的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-MySQL-%E6%98%AF%E5%90%A6%E5%9C%A8%E6%89%AB%E6%8F%8F%E9%A2%9D%E5%A4%96%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="toc-text">1.2 MySQL 是否在扫描额外的记录</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%87%8D%E6%9E%84%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 重构查询的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2%E8%BF%98%E6%98%AF%E5%A4%9A%E4%B8%AA%E7%AE%80%E5%8D%95%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.1 一个复杂查询还是多个简单查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%88%87%E5%88%86%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.2 切分查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E5%88%86%E8%A7%A3%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-text">2.3 分解关联查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9F%BA%E7%A1%80"><span class="toc-text">3. 查询执行的基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-MySQL-%E5%AE%A2%E6%88%B7%E7%AB%AF-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-text">3.1 MySQL 客户端&#x2F;服务器通信协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93%E5%87%BD%E6%95%B0%E7%BC%93%E5%AD%98"><span class="toc-text">库函数缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-text">查询缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-text">查询优化处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%B8%8E%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%BF%A1%E6%81%AF"><span class="toc-text">数据与索引的统计信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E4%B8%AD%E7%9A%84%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-text">mysql中的关联查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-text">关联查询优化器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96"><span class="toc-text">排序优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">返回结果给客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E5%99%A8%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">mysql查询优化器的局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">关联子查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-text">特定类型查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-COUNT-%E6%9F%A5%E8%AF%A2"><span class="toc-text">优化 COUNT()查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2"><span class="toc-text">优化关联查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-text">优化子查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96union%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-text">优化union的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%9B%B4%E6%96%B0"><span class="toc-text">在同一个表查询与更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-GROUP-BY-%E5%92%8C-DISTINCT"><span class="toc-text">优化 GROUP BY 和 DISTINCT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LIMIT-%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96-%EF%BC%88%E6%B2%A1%E7%90%86%E8%A7%A3%EF%BC%89"><span class="toc-text">&#x3D;&#x3D;LIMIT 分页优化&#x3D;&#x3D;（没理解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96union%E6%9F%A5%E8%AF%A2"><span class="toc-text">优化union查询</span></a></li></ol></li></ol></li></ol></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><h3 id="1-MySQL-服务器逻辑架构"><a href="#1-MySQL-服务器逻辑架构" class="headerlink" title="1. MySQL 服务器逻辑架构"></a>1. <strong>MySQL 服务器逻辑架构</strong></h3><h4 id="1-1-逻辑分层"><a href="#1-1-逻辑分层" class="headerlink" title="1.1 逻辑分层"></a>1.1 逻辑分层</h4><p><strong>服务器包括三层：连接层、服务层、引擎层</strong></p>
<img src="/2022/12/24/MySQL/image-20221207213412809.png" style="zoom:60%;"> 



<h4 id="1-2-SQL-执行流程（服务器角度）"><a href="#1-2-SQL-执行流程（服务器角度）" class="headerlink" title="&#x3D;&#x3D;1.2 SQL 执行流程（服务器角度）&#x3D;&#x3D;"></a>&#x3D;&#x3D;1.2 <strong>SQL</strong> <strong>执行流程（服务器角度）</strong>&#x3D;&#x3D;</h4><img src="/2022/12/24/MySQL/image-20240318110730166.png" style="zoom: 67%;"> 

<ol>
<li><p><strong>查询缓存：</strong>Server 如果在查询缓存中发现了这条 SQL 语句，就会直接将结果返回给客户端；如果没有，就进入到解析器阶段。需要说明的是，因为查询缓存往往效率不高，因为两条 SQL 语句必须完全一样，而且表可能也会改变。所以在 MySOL 8.0 之后就抛弃了这个功能。</p>
</li>
<li><p><strong>解析器：</strong>在解析器中对 SQL 语句进行语法分析、语义分析，生成解析树。</p>
</li>
<li><p><strong>优化器</strong>：在优化器中会确定 SQL 语句的执行路径，比如是根据 全表检索 ，还是根据 索引检索 等。</p>
<p>经过了解析器，MySQL 就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是找到这其中最好的<strong>执行计划</strong>。</p>
<p>比如：<strong>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候决定各个表的连接顺序</strong>，还有表达式简化、子查询转为连接、外连接转为内连接等。</p>
<p>举例:如下语句是执行两个表的 join：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> test1 <span class="keyword">join</span> test2 <span class="keyword">using</span>(ID)</span><br><span class="line"><span class="keyword">where</span> test1.name<span class="operator">=</span><span class="string">&#x27;zhangwei&#x27;</span> <span class="keyword">and</span> test2.name<span class="operator">=</span><span class="string">&#x27;mysql&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方案1:可以先从表 test1 里面取出 name=&#x27;zhangwei&#x27; 的记录的 ID 值，再根据 ID 值关联到表 test2，再判断 test2里面 name的值是否等于 mysql。</span><br><span class="line">方案2:可以先从表 test2 里面取出 name=&#x27;mysql”的记录的 ID 值，再根据 ID 值关联到 test1，再判断 test1 里面 name 的值是否等于 zhangwei。</span><br><span class="line">这两种执行方法的逻辑结界是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行器：</strong>截止到现在，还没有真正去读写真实的表，仅仅只是产出了一个执行计划。于是就进入了执行器阶段。</p>
<p>在执行之前需要判断该用户是否 <strong>具备权限</strong>。如果没有，就会返回权限错误；如果具备权限，就执行 SQL 查询并返回结果。</p>
<p>在 MySQL 8.0 以下的版本，如果设置了<strong>查询缓存</strong>，这时会将查询结果进行缓存。</p>
<p><code>select * from test where id=1</code></p>
<p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，<strong>调用存储引擎 API</strong> 对表进行的读写。存储引擎 API 只是抽象接口，下面还有个存储引擎层，具体实现还是要看表选择的存储引擎。</p>
</li>
</ol>
<img src="/2022/12/24/MySQL/image-20240318112636655.png" style="zoom:67%;"> 

<h4 id="1-3-SQL-语句执行顺序（代码角度）"><a href="#1-3-SQL-语句执行顺序（代码角度）" class="headerlink" title="1.3 SQL 语句执行顺序（代码角度）"></a>1.3 SQL 语句执行顺序（代码角度）</h4><p>假设我们有两个表，<code>students</code>和<code>courses</code>，每个表包含以下字段：</p>
<ul>
<li><code>students</code>：id, name, age, course_id</li>
<li><code>courses</code>：id, course_name, teacher</li>
</ul>
<p>我们要执行一个包含多个子句的查询，目的是获取所有选修了某门课程（比如”Math”）的学生姓名和年龄，并按照年龄从小到大排序，最多返回10个结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT s.name, s.age	# 4</span><br><span class="line">FROM students s		# 1</span><br><span class="line">JOIN courses c ON s.course_id = c.id  # 2</span><br><span class="line">WHERE c.course_name = &#x27;Math&#x27;	# 3</span><br><span class="line">ORDER BY s.age	# 5</span><br><span class="line">LIMIT 10;	# 6</span><br></pre></td></tr></table></figure>

<p>下面是这个查询语句的执行过程：</p>
<ol>
<li><strong>FROM 子句</strong>：<ul>
<li>MySQL首先处理FROM子句。它会找到需要操作的表<code>students</code>和<code>courses</code>，检查是否有必要的权限来访问这些表，然后确定如何访问这些表。</li>
</ul>
</li>
<li><strong>JOIN 子句</strong>：<ul>
<li>在处理FROM子句之后，MySQL会处理JOIN子句。在这个例子中，我们使用了INNER JOIN，它会根据<code>students</code>表的<code>course_id</code>字段和<code>courses</code>表的<code>id</code>字段进行连接。MySQL会找到满足连接条件的行，并将它们合并在一起。</li>
</ul>
</li>
<li><strong>WHERE 子句</strong>：<ul>
<li>接下来，MySQL会处理WHERE子句。它会应用WHERE条件来筛选出满足条件的行，即选修了名称为”Math”的课程的学生。</li>
</ul>
</li>
<li><strong>SELECT 子句</strong>：<ul>
<li>一旦确定了要操作的行，MySQL会执行SELECT子句。它会从每一行中提取出学生的姓名和年龄。</li>
</ul>
</li>
<li><strong>ORDER BY 子句</strong>：<ul>
<li>如果查询包含ORDER BY子句，MySQL会根据指定的排序规则对结果进行排序。在这个例子中，我们按照学生的年龄从小到大排序。</li>
</ul>
</li>
<li><strong>LIMIT 子句</strong>：<ul>
<li>最后，MySQL会根据LIMIT子句来限制返回的结果集的行数，最多返回10个结果。</li>
</ul>
</li>
</ol>
<p>这个例子涵盖了一个典型的查询过程，包括了FROM、JOIN、WHERE、SELECT、ORDER BY和LIMIT等子句的处理顺序。MySQL会依次处理这些子句，并根据查询的逻辑生成最终的结果。</p>
<h2 id="锁篇"><a href="#锁篇" class="headerlink" title="锁篇"></a>锁篇</h2><p>参考：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/show_lock.html">https://xiaolincoding.com/mysql/lock/show_lock.html</a></p>
<p>&#x3D;&#x3D;讨论 Mysql 在两个层面的并发控制：服务器层和存储引擎层。&#x3D;&#x3D;</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a><strong>读写锁</strong></h3><ul>
<li><p>读锁（共享锁）：读-读并发，读-写互斥</p>
</li>
<li><p>写锁（排他锁）：读-写互斥，写-写互斥。</p>
<img src="/2022/12/24/MySQL/x锁和s锁.png" style="zoom:67%;"> 

<p>写锁比读锁优先级高（写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁之前）</p>
<p>一个用户在对表进行写操作（增删改）前，要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获取读锁，读锁之间是不互相阻塞的。</p>
</li>
</ul>
<h3 id="按锁粒度分类"><a href="#按锁粒度分类" class="headerlink" title="按锁粒度分类"></a><strong>按锁粒度分类</strong></h3><h4 id="1）全局锁"><a href="#1）全局锁" class="headerlink" title="1）全局锁"></a><strong>1）全局锁</strong></h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flush tables <span class="keyword">with</span> read lock	 #加全局锁，整个数据库处于只读状态，对数据和表结构的操作改变会被阻塞。</span><br><span class="line">unlock tables	# 释放全局锁。</span><br></pre></td></tr></table></figure>

<p>加全局锁后，整个数据库就处于只读状态了，这时其他线程执行以下操作，都会被阻塞</p>
<ul>
<li>对数据的增删改操作（insert、delete、update）</li>
<li>对表结构的更改操作（alter table、drop table）</li>
</ul>
<p><strong>应用场景：</strong></p>
<p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p>
<p>比如：备份数据库中的用户余额表和商品库存表时，如果不添加全局锁，先备份用户表，然后用户购买了商品，再备份商品表，这相当于用户白嫖了商品。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？</span><br><span class="line"></span><br><span class="line">如果数据库的引擎支持的事务支持 **可重复读的隔离级别** ，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</span><br><span class="line"></span><br><span class="line">因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。</span><br><span class="line"></span><br><span class="line">备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 `–single-transaction` 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</span><br><span class="line"></span><br><span class="line">InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</span><br><span class="line"></span><br><span class="line">但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法</span><br></pre></td></tr></table></figure>

<h4 id="2）表级锁"><a href="#2）表级锁" class="headerlink" title="2）表级锁"></a>2）表级锁</h4><p>Mysql 中表级别的锁有这几种：</p>
<ul>
<li>表锁</li>
<li>元数据锁（MDL）</li>
<li>意向锁</li>
<li>AUTO-INC 锁</li>
</ul>
<h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a><strong>表锁</strong></h5><p>对学生表(t_student)加表锁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"># 表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br><span class="line"># 释放当前会话的所有表锁</span><br><span class="line">unlock tables;</span><br></pre></td></tr></table></figure>

<p>注意，表锁不仅会限制其他线程的读写操作，也会限制本线程的读写操作。例如，线程对表添加【共享锁】，那本线程和其他线程的写操作都会阻塞，直到锁释放。</p>
<p>另外，一个线程对 t1 加锁，就不能对 t2 进行读写操作。</p>
<blockquote>
<p>尽量别在 InnoDB 使用表级锁，粒度大影响并发性能，InnoDB 有更 6 的行级锁</p>
<p>表级锁是在服务层实现的，因此与具体的存储引擎无关。无论表使用的是哪种存储引擎（如 InnoDB 或 MyISAM），表级锁的行为都是一致的。</p>
</blockquote>
<h5 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a><strong>元数据锁</strong>（MDL）</h5><p>我们不需要显式的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL:<br>·对一张表进行 CRUD 操作时，加的是 MDL 读锁:<br>·对一张表做结构变更操作的时候，加的是 MDL写锁:<br>MDL是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更<br>当有线程在执行 select 语句 (加 MDL 读锁)的期间，如果有其他线程要更改该表的结构 (申请 MDL写锁)，那么将会被阻塞，直到执行完 select 语句(释放 MDL读锁)。<br>反之，当有线程对表结构进行变更(加 MDL写锁)的期间，如果有其他线程执行了 CRUD 操作 (申请MDL读锁)，那么就会被阻塞，直到表结构变更完成(释放 MDL写锁)。<br>MDL不需要显示调用，那它是在什么时候释放的?<br>MDL是在事务提交后才会释放，这意味着事务执行期间，MDL是一直持有的<br>那如果数据库有一个长事务(所谓的长事务，就是开启了事务，但是一直还没提交)，那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景:<br>1.首先，线程 A先启用了事务(但是一直不提交)，然后执行一条 select 语句，此时就先对该表加上MDL 读锁;<br>2.然后，线程 B也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突;3.接着，线程C修改了表字段，此时由于线程 A的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程C 就无法申请到 MDL写锁，就会被阻塞<br>那么在线程C阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。</p>
<p>为什么线程 C因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞?<br>这是因为申请 MDL锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。<br>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 ki 掉这个长事务，然后再做表结构的变更。</p>
<hr>
<h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a><strong>意向锁</strong></h5><p><strong>意向锁的目的是告诉数据库“我打算锁表中的某些行”，这样当其他事务想要加表锁时，就不用检查每一行，而只需要检查意向锁，从而提高效率。</strong></p>
<p>&#x3D;&#x3D;我的理解：意向锁就是<strong>把行锁变成一个假的表锁</strong>，用于<strong>快速判断表里是否有记录被加锁</strong>，进行表锁和行锁之间的冲突检测&#x3D;&#x3D;</p>
<ul>
<li><p>在使用 InnoDB 引擎的表里对<strong>一行</strong>加上<strong>「共享锁」</strong>之前，会隐式在<strong>表级别</strong>加<strong>「意向共享锁」</strong>；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数据库会先对整张表加一个意向共享锁（IS 锁）。</p>
</li>
<li><p>然后对指定的行加共享锁（S 锁）。</p>
</li>
<li><p>IS 锁会<strong>阻塞</strong>表级别的写锁（即<strong>表级排他锁 X 锁</strong>），但是不会阻塞其他<strong>兼容</strong>的锁（如 <strong>IS 锁</strong>、<strong>S 锁</strong>、<strong>IX 锁</strong>）。这是一种优化机制，用来<strong>快速进行表锁和行锁之间的冲突检测。</strong></p>
</li>
</ul>
</li>
<li><p>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，触发在表级别加上一个<strong>「意向独占锁」</strong>；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数据库会先对整张表加一个意向独占锁（IX 锁）。</p>
</li>
<li><p>然后对指定的行加独占锁（X 锁）。</p>
</li>
<li><p>IS 锁会<strong>阻塞</strong>表级别的读锁、写锁（即<strong>表级 S 锁、X 锁</strong>），但是不会阻塞其他<strong>兼容</strong>的锁（如 <strong>IS 锁</strong>、<strong>IX 锁</strong>）。这是一种优化机制，用来<strong>快速进行表锁和行锁之间的冲突检测。</strong></p>
</li>
</ul>
</li>
</ul>
<p><u><em>注意：意向共享锁（IS）和意向排他锁（IX）可以共存，因为它们只是分别<strong>声明</strong>了行级共享锁和行级排他锁的<strong>意图</strong>，并不直接对表或行产生冲突。</em></u></p>
<p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁、独占锁冲突，而且意向锁之间也不会冲突，只会共享表锁和（<em>lock tables … read</em>）和独占表锁（<em>lock tables … write</em>）发生冲突。</strong></p>
<blockquote>
<p>注：普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC快照读 实现一致性读，是无锁的。</p>
</blockquote>
<hr>
<h4 id="3）行级锁（InnoDB）"><a href="#3）行级锁（InnoDB）" class="headerlink" title="&#x3D;&#x3D;3）行级锁（InnoDB）&#x3D;&#x3D;"></a>&#x3D;&#x3D;3）行级锁（InnoDB）&#x3D;&#x3D;</h4><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p>
<p>行级锁的类型主要有三类：</p>
<ul>
<li>Record Lock，<strong>记录锁</strong>，也就是仅仅把一条记录锁上（在【读已提交】级别下，行级锁只有记录锁）；</li>
<li>Gap Lock，<strong>间隙锁</strong>，锁定一个范围，但是不包含记录本身，可以避免<strong>幻读</strong>（在【可重复读】级别下有间隙锁）；</li>
<li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>
<h5 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a><strong>Record</strong> <strong>Lock</strong></h5><p>Record Lock 称为<strong>记录锁</strong>，锁住的是一条记录。而且记录锁有 S 锁和 X 锁之分。</p>
<ul>
<li>当一个事务对一条记录加了 S 型记录锁后，其他事务可继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li>
<li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li>
</ul>
<p>举个例子，当一个事务执行了下面这条语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">mysql <span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_test <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>就是对 t_test 表中主键 id 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了，会阻塞。注意，其他事务插入一条 id &#x3D; 1 的新记录并不会被阻塞，而是会报主键冲突的错误，这是因为主键有唯一性的约束。</p>
<p><img src="/2022/12/24/MySQL/%E8%AE%B0%E5%BD%95%E9%94%81.drawio.png"> </p>
<p>当事务执行 commit 后，事务过程中生成的锁都会被释放。</p>
<h5 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a><strong>Gap</strong> <strong>Lock</strong></h5><p>Gap Lock 称为<strong>间隙锁</strong>，只存在于可重复读隔离级别，<u>目的是为了解决【可重复读】隔离级别下 <strong>幻读</strong> 的现象。</u></p>
<p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id &#x3D; 4 这条记录了，这样就有效的防止幻读现象的发生。</p>
<p><img src="/2022/12/24/MySQL/gap%E9%94%81.drawio.png"> </p>
<p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong> (?)</p>
<blockquote>
<p>一个事务如果在(10, 20) 加间隙锁，那它肯定不会在(10, 20) 之间插入数据</p>
</blockquote>
<h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a><strong>Next-Key Lock</strong></h5><p>Next-Key Lock 称为<strong>临键锁</strong>，是 <strong>记录锁 + 间隙锁</strong> 的组合，<strong>锁定一个范围，并且锁定记录本身</strong>。</p>
<p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id &#x3D; 4 记录，也不能修改 id &#x3D; 5 这条记录。</p>
<p><img src="/2022/12/24/MySQL/%E4%B8%B4%E9%94%AE%E9%94%81.drawio.png"> </p>
<p>所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p>
<p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p>
<p>比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。</p>
<p>虽然相同范围的间隙锁是多个事务相互兼容的，但对于记录锁，我们是要考虑 X 型与 S 型关系，X 型的记录锁与 X 型的记录锁是冲突的。</p>
<h5 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a><strong>插入意向锁</strong></h5><p>一个事务在 <strong>插入</strong> 一条记录的时候，需要判断插入位置是否已被其他事务加了 <strong>间隙锁</strong>（next-key lock 也包含<strong>临键锁</strong>）。</p>
<p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p>
<p>举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。</p>
<p><img src="/2022/12/24/MySQL/gap%E9%94%81.drawio-1711789472243-9.png" alt="img"> </p>
<p><strong>当事务 A 还没提交的时候，事务 B 向该表插入一条 id &#x3D; 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态</strong>（<em>PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</em>），<strong>此时事务 B 就会发生阻塞，直到事务 A 提交了事务。</strong></p>
<p>插入意向锁<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p>
<p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p>
<p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p>
<h4 id="2-3-MySQL-是怎么加行级锁的？"><a href="#2-3-MySQL-是怎么加行级锁的？" class="headerlink" title="2.3 MySQL 是怎么加行级锁的？"></a>2.3 MySQL 是怎么加行级锁的？</h4><p>行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。</p>
<p><strong>加锁的对象是索引，加锁的基本单位是 next-key lock</strong>，它是由记录锁和间隙锁组合而成的，<strong>next-key lock 是前开后闭区间，而间隙锁是前开后开区间</strong>。</p>
<p>但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。</p>
<p>那到底是什么场景呢？总结一句，<strong>在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁</strong>。</p>
<p>这次会以下面这个表结构来进行实验说明：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">30</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `index_age` (`age`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<p>其中，id 是主键索引（唯一索引），age 是普通索引（非唯一索引），name 是普通的列。</p>
<p>表中的有这些行记录：</p>
<img src="/2022/12/24/MySQL/user.png" style="zoom:67%;"> 

<p>这次实验环境的 <strong>MySQL 版本是 8.0.26，隔离级别是「可重复读」</strong>。不同版本的加锁规则可能是不同的，但是大体上是相同的。</p>
<h5 id="唯一索引等值查询"><a href="#唯一索引等值查询" class="headerlink" title="唯一索引等值查询"></a>唯一索引等值查询</h5><p>当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：</p>
<ul>
<li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</li>
<li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。</li>
</ul>
<blockquote>
<p>TIP</p>
<p>我本篇文章的「唯一索引」是用「主键索引」作为案例说明的，加锁只加在主键索引项上。</p>
<p>然后，很多同学误以为如果是二级索引的「唯一索引」，加锁也是只加在二级索引项上。</p>
<p>其实这是不对的，所以这里特此说明下，如果是用二级索引（不管是不是非唯一索引，还是唯一索引）进行锁定读查询的时候，除了会对二级索引项加行级锁（如果是唯一索引的二级索引，加锁规则和主键索引的案例相同），而且还会对查询到的记录的主键索引项上加「记录锁」。</p>
<p>在文章的「非唯一索引」的案例中，我就是用二级索引作为例子，在后面的章节我有说明，对二级索引进行锁定读查询的时候，因为存在两个索引（二级索引和主键索引），所以两个索引都会加锁。</p>
</blockquote>
<p>接下里用两个案例来说明。</p>
<p><strong>记录存在的情况</strong></p>
<p>假设事务 A 执行了这条等值查询语句，查询的记录是「存在」于表中的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 路飞   <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure>

<p>那么，事务 A 会为 id 为 1 的这条记录就会加上 <strong>X 型的记录锁</strong>。</p>
<p><img src="/2022/12/24/MySQL/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%AE%B0%E5%BD%95%E9%94%81.drawio.png"> </p>
<p>接下来，如果有其他事务，对 id 为 1 的记录进行更新或者删除操作的话，这些操作都会被阻塞，因为更新或者删除操作也会对记录加 X 型的记录锁，而 X 锁和 X 锁之间是互斥关系。</p>
<p>比如，下面这个例子：</p>
<img src="/2022/12/24/MySQL/唯一索引等值查询（存在）.drawio.png" style="zoom:67%;"> 

<p>因为事务 A 对 id &#x3D; 1的记录加了 <strong>X 型的记录锁</strong>，所以事务 B 在修改 id&#x3D;1 的记录时会被阻塞，事务 C 在删除 id&#x3D;1 的记录时也会被阻塞。</p>
<blockquote>
<p>有什么命令可以分析加了什么锁？</p>
</blockquote>
<p>我们可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务执行 SQL 过程中加了什么锁。</p>
<p>我们以前面的事务 A 作为例子，分析下下它加了什么锁。</p>
<img src="/2022/12/24/MySQL/事务a加锁分析.png" style="zoom: 50%;"> 

<p>从上图可以看到，共加了两个锁，分别是：</p>
<ul>
<li>表锁：X 类型的意向锁；</li>
<li>行锁：X 类型的记录锁；</li>
</ul>
<p>这里我们重点关注行级锁，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思。</p>
<p>通过 LOCK_MODE 可以确认是 next-key 锁，还是间隙锁，还是记录锁：</p>
<ul>
<li>如果 LOCK_MODE 为 <code>X</code>，说明是 next-key 锁；</li>
<li>如果 LOCK_MODE 为 <code>X, REC_NOT_GAP</code>，说明是记录锁；</li>
<li>如果 LOCK_MODE 为 <code>X, GAP</code>，说明是间隙锁；</li>
</ul>
<p>因此，<strong>此时事务 A 在 id &#x3D; 1 记录的主键索引上加的是记录锁，锁住的范围是 id 为 1 的这条记录。</strong>这样其他事务就无法对 id 为 1 的这条记录进行更新和删除操作了。</p>
<p>从这里我们也可以得知，<strong>加锁的对象是针对索引</strong>，因为这里查询语句扫描的 B+ 树是聚簇索引树，即主键索引树，所以是对主键索引加锁。将对应记录的主键索引加 记录锁后，就意味着其他事务无法对该记录进行更新和删除操作了。</p>
<blockquote>
<p>为什么唯一索引等值查询并且查询记录存在的场景下，该记录的索引中的 next-key lock 会退化成记录锁？</p>
</blockquote>
<p>原因就是在唯一索引等值查询并且查询记录存在的场景下，仅靠记录锁也能避免幻读的问题。</p>
<p>幻读的定义就是，当一个事务前后两次查询的结果集，不相同时，就认为发生幻读。所以，要避免幻读就是避免结果集某一条记录被其他事务删除，或者有其他事务插入了一条新记录，这样前后两次查询的结果集就不会出现不相同的情况。</p>
<ul>
<li>由于主键具有唯一性，所以<strong>其他事务插入 id &#x3D; 1 的时候，会因为主键冲突，导致无法插入 id &#x3D; 1 的新记录</strong>。这样事务 A 在多次查询 id &#x3D; 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。</li>
<li>由于对 id &#x3D; 1 加了记录锁，<strong>其他事务无法删除该记录</strong>，这样事务 A 在多次查询 id &#x3D; 1 的记录的时候，不会出现前后两次查询的结果集不同，也就避免了幻读的问题。</li>
</ul>
<p><strong>记录不存在的情况</strong></p>
<p>假设事务 A 执行了这条等值查询语句，查询的记录是「不存在」于表中的。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.03</span> sec)</span><br></pre></td></tr></table></figure>

<p>接下来，通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句，查看事务执行 SQL 过程中加了什么锁。</p>
<img src="/2022/12/24/MySQL/事务a分析1.png" style="zoom: 50%;"> 

<p>从上图可以看到，共加了两个锁，分别是：</p>
<ul>
<li>表锁：X 类型的意向锁；</li>
<li>行锁：X 类型的间隙锁；</li>
</ul>
<p>因此，<strong>此时事务 A 在 id &#x3D; 5 记录的主键索引上加的是间隙锁，锁住的范围是 (1, 5)。</strong></p>
<img src="/2022/12/24/MySQL/唯一索引间隙锁.drawio.png" style="zoom: 67%;"> 

<p>接下来，如果有其他事务插入 id 值为 2、3、4 这一些记录的话，这些插入语句都会发生阻塞。</p>
<p>注意，如果其他事务插入的 id &#x3D; 1 或者 id &#x3D; 5 的记录话，并不会发生阻塞，而是报主键冲突的错误，因为表中已经存在 id &#x3D; 1 和 id &#x3D; 5 的记录了。</p>
<p>比如，下面这个例子：</p>
<p><img src="/2022/12/24/MySQL/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%EF%BC%88%E4%B8%8D%E5%AD%98%E5%9C%A8%EF%BC%89.drawio.png" alt="img"> </p>
<p>因为事务 A 在 id &#x3D; 5 记录的主键索引上加了范围为 (1, 5) 的 X 型间隙锁，所以事务 B 在插入一条 id 为 3 的记录时会被阻塞住，即无法插入 id &#x3D; 3 的记录。</p>
<blockquote>
<p>间隙锁的范围<code>(1, 5)</code> ，是怎么确定的？</p>
</blockquote>
<p>根据我的经验，如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示锁的范围「右边界」，此次的事务 A 的 LOCK_DATA 是 5。</p>
<p>然后锁范围的「左边界」是表中 id 为 5 的上一条记录的 id 值，即 1。</p>
<p>因此，间隙锁的范围<code>(1, 5)</code>。</p>
<blockquote>
<p>为什么唯一索引等值查询并且查询记录「不存在」的场景下，在索引树找到第一条大于该查询记录的记录后，要将该记录的索引中的 next-key lock 会退化成「间隙锁」？</p>
</blockquote>
<p>原因就是在唯一索引等值查询并且查询记录不存在的场景下，仅靠间隙锁就能避免幻读的问题。</p>
<ul>
<li>为什么 id &#x3D; 5 记录上的主键索引的锁不可以是 next-key lock？如果是 next-key lock，就意味着其他事务无法删除 id &#x3D; 5 这条记录，但是这次的案例是查询 id &#x3D; 2 的记录，只要保证前后两次查询 id &#x3D; 2 的结果集相同，就能避免幻读的问题了，所以即使 id &#x3D;5 被删除，也不会有什么影响，那就没必须加 next-key lock，因此只需要在 id &#x3D; 5 加间隙锁，避免其他事务插入 id &#x3D; 2 的新记录就行了。</li>
<li>为什么不可以针对不存在的记录加记录锁？锁是加在索引上的，而这个场景下查询的记录是不存在的，自然就没办法锁住这条不存在的记录。</li>
</ul>
<h5 id="唯一索引范围查询"><a href="#唯一索引范围查询" class="headerlink" title="唯一索引范围查询"></a><strong>唯一索引范围查询</strong></h5><p>范围查询和等值查询的加锁规则是不同的。</p>
<p>当唯一索引进行范围查询时，<strong>会对每一个扫描到的索引加 next-key 锁，然后如果遇到下面这些情况，会退化成记录锁或者间隙锁</strong>：</p>
<ul>
<li>情况一：针对「大于等于」的范围查询，因为存在等值查询的条件，那么如果等值查询的记录是存在于表中，那么该记录的索引中的 next-key 锁会<strong>退化成记录锁</strong>。</li>
<li>情况二：针对「小于或者小于等于」的范围查询，要看条件值的记录是否存在于表中：<ul>
<li>当条件值的记录不在表中，那么不管是「小于」还是「小于等于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li>
<li>当条件值的记录在表中，如果是「小于」条件的范围查询，<strong>扫描到终止范围查询的记录时，该记录的索引的 next-key 锁会退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的索引上加 next-key 锁；如果「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的索引 next-key 锁不会退化成间隙锁。其他扫描到的记录，都是在这些记录的索引上加 next-key 锁。</li>
</ul>
</li>
</ul>
<p>接下来，通过几个实验，才验证我上面说的结论。</p>
<p><strong>针对「大于或者大于等于」的范围查询针对「大于或者大于等于」的范围查询</strong></p>
<blockquote>
<p>实验一：针对「大于」的范围查询的情况。</p>
</blockquote>
<p>假设事务 A 执行了这条范围查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name      <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 香克斯    <span class="operator">|</span>  <span class="number">39</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>事务 A 加锁变化过程如下：</p>
<ol>
<li>最开始要找的第一行是 id &#x3D; 20，由于查询该记录不是一个等值查询（不是大于等于条件查询），所以对该主键索引加的是范围为 (15, 20] 的 next-key 锁；</li>
<li>由于是范围查找，就会继续往后找存在的记录，虽然我们看见表中最后一条记录是 id &#x3D; 20 的记录，但是实际在 Innodb 存储引擎中，会用一个特殊的记录来标识最后一条记录，该特殊的记录的名字叫 supremum pseudo-record ，所以扫描第二行的时候，也就扫描到了这个特殊记录的时候，会对该主键索引加的是范围为 (20, +∞] 的 next-key 锁。</li>
<li>停止扫描。</li>
</ol>
<p>可以得知，事务 A 在主键索引上加了两个 X 型 的 next-key 锁：</p>
<img src="/2022/12/24/MySQL/唯一索引范围查询大于15.drawio.png" style="zoom:67%;"> 

<ul>
<li>在 id &#x3D; 20 这条记录的主键索引上，加了范围为 (15, 20] 的 next-key 锁，意味着其他事务即无法更新或者删除 id &#x3D; 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。</li>
<li>在特殊记录（ supremum pseudo-record）的主键索引上，加了范围为 (20, +∞] 的 next-key 锁，意味着其他事务无法插入 id 值大于 20 的这一些新记录。</li>
</ul>
<p>我们也可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句来看看事务 A 加了什么锁。</p>
<p>输出结果如下，我这里只截取了行级锁的内容。</p>
<p><img src="/2022/12/24/MySQL/%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%A4%A7%E4%BA%8E.png" alt="img"></p>
<p>从上图中的分析中，也可以得到<strong>事务 A 在主键索引上加了两个 X 型 的next-key 锁：</strong></p>
<ul>
<li>在 id &#x3D; 20 这条记录的主键索引上，加了范围为 (15, 20] 的 next-key 锁，意味着其他事务即无法更新或者删除 id &#x3D; 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。</li>
<li>在特殊记录（ supremum pseudo-record）的主键索引上，加了范围为 (20, +∞] 的 next-key 锁，意味着其他事务无法插入 id 值大于 20 的这一些新记录。</li>
</ul>
<blockquote>
<p>实验二：针对「大于等于」的范围查询的情况。</p>
</blockquote>
<p>假设事务 A 执行了这条范围查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">15</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name      <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">15</span> <span class="operator">|</span> 乌索普    <span class="operator">|</span>  <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 香克斯    <span class="operator">|</span>  <span class="number">39</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>事务 A 加锁变化过程如下：</p>
<ol>
<li>最开始要找的第一行是 id &#x3D; 15，由于查询该记录是一个等值查询（等于 15），所以该主键索引的 next-key 锁会<strong>退化成记录锁</strong>，也就是仅锁住 id &#x3D; 15 这一行记录。</li>
<li>由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id &#x3D; 20，于是对该主键索引加的是范围为 (15, 20] 的 next-key 锁；</li>
<li>接着扫描到第三行的时候，扫描到了特殊记录（ supremum pseudo-record），于是对该主键索引加的是范围为 (20, +∞] 的 next-key 锁。</li>
<li>停止扫描。</li>
</ol>
<p>可以得知，事务 A 在主键索引上加了三个 X 型 的锁，分别是：</p>
<img src="/2022/12/24/MySQL/唯一索引范围查询大于等于15.drawio.png" alt="img" style="zoom:67%;"> 

<ul>
<li>在 id &#x3D; 15 这条记录的主键索引上，加了记录锁，范围是 id &#x3D; 15 这一行记录；意味着其他事务无法更新或者删除 id &#x3D; 15 的这一条记录；</li>
<li>在 id &#x3D; 20 这条记录的主键索引上，加了 next-key 锁，范围是 (15, 20] 。意味着其他事务即无法更新或者删除 id &#x3D; 20 的记录，同时无法插入 id 值为 16、17、18、19 的这一些新记录。</li>
<li>在特殊记录（ supremum pseudo-record）的主键索引上，加了 next-key 锁，范围是 (20, +∞] 。意味着其他事务无法插入 id 值大于 20 的这一些新记录。</li>
</ul>
<p>我们也可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句来看看事务 A 加了什么锁。</p>
<p>输出结果如下，我这里只截取了行级锁的内容。</p>
<img src="/2022/12/24/MySQL/范围查询大于等于.png" alt="img" style="zoom:50%;"> 

<p>通过前面这个实验，我们证明了：</p>
<ul>
<li>针对「大于等于」条件的唯一索引范围查询的情况下， 如果条件值的记录存在于表中，那么由于查询该条件值的记录是包含一个等值查询的操作，所以该记录的索引中的 next-key 锁会<strong>退化成记录锁</strong>。</li>
</ul>
<p><strong>针对「小于或者小于等于」的范围查询</strong></p>
<blockquote>
<p>实验一：针对「小于」的范围查询时，查询条件值的记录「不存在」表中的情况。</p>
</blockquote>
<p>假设事务 A 执行了这条范围查询语句，注意查询条件值的记录（id 为 6）并不存在于表中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">6</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 路飞   <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 索隆   <span class="operator">|</span>  <span class="number">21</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>事务 A 加锁变化过程如下：</p>
<ol>
<li>最开始要找的第一行是 id &#x3D; 1，于是对该主键索引加的是范围为 (-∞, 1] 的 next-key 锁；</li>
<li>由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id &#x3D; 5，所以对该主键索引加的是范围为 (1, 5] 的 next-key 锁；</li>
<li>由于扫描到的第二行记录（id &#x3D; 5），满足 id &lt; 6 条件，而且也没有达到终止扫描的条件，接着会继续扫描。</li>
<li>扫描到的第三行是 id &#x3D; 10，该记录不满足 id &lt; 6 条件的记录，所以 id &#x3D; 10 这一行记录的锁会<strong>退化成间隙锁</strong>，于是对该主键索引加的是范围为 (5, 10) 的间隙锁。</li>
<li>由于扫描到的第三行记录（id &#x3D; 10），不满足 id &lt; 6 条件，达到了终止扫描的条件，于是停止扫描。</li>
</ol>
<p>从上面的分析中，可以得知事务 A 在主键索引上加了三个 X 型的锁：</p>
<p><img src="/2022/12/24/MySQL/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E6.drawio.png" alt="img"></p>
<ul>
<li>在 id &#x3D; 1 这条记录的主键索引上，加了范围为 (-∞, 1] 的 next-key 锁，意味着其他事务即无法更新或者删除 id &#x3D; 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。</li>
<li>在 id &#x3D; 5 这条记录的主键索引上，加了范围为 (1, 5] 的 next-key 锁，意味着其他事务即无法更新或者删除 id &#x3D; 5 的这一条记录，同时也无法插入 id 值为 2、3、4 的这一些新记录。</li>
<li>在 id &#x3D; 10 这条记录的主键索引上，加了范围为 (5, 10) 的间隙锁，意味着其他事务无法插入 id 值为 6、7、8、9 的这一些新记录。</li>
</ul>
<p>我们也可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句来看看事务 A 加了什么锁。</p>
<p>输出结果如下，我这里只截取了行级锁的内容。</p>
<p><img src="/2022/12/24/MySQL/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E6.png" alt="img"></p>
<p>从上图中的分析中，也可以得知事务 A 在主键索引加的三个锁，就是我们前面分析出那三个锁。</p>
<p>虽然这次范围查询的条件是「小于」，但是查询条件值的记录不存在于表中（ id 为 6 的记录不在表中），所以如果事务 A 的范围查询的条件改成 &lt;&#x3D; 6 的话，加的锁还是和范围查询条件为 &lt; 6 是一样的。 大家自己也验证下这个结论。</p>
<p>因此，<strong>针对「小于或者小于等于」的唯一索引范围查询，如果条件值的记录不在表中，那么不管是「小于」还是「小于等于」的范围查询，扫描到终止范围查询的记录时，该记录中索引的 next-key 锁会退化成间隙锁，其他扫描的记录，则是在这些记录的索引上加 next-key 锁</strong>。</p>
<blockquote>
<p>实验二：针对「小于等于」的范围查询时，查询条件值的记录「存在」表中的情况。</p>
</blockquote>
<p>假设事务 A 执行了这条范围查询语句，注意查询条件值的记录（id 为 5）存在于表中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;=</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> 路飞   <span class="operator">|</span>  <span class="number">19</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> 索隆   <span class="operator">|</span>  <span class="number">21</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>事务 A 加锁变化过程如下：</p>
<ol>
<li>最开始要找的第一行是 id &#x3D; 1，于是对该记录加的是范围为 (-∞, 1] 的 next-key 锁；</li>
<li>由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id &#x3D; 5，于是对该记录加的是范围为 (1, 5] 的 next-key 锁。</li>
<li>由于主键索引具有唯一性，不会存在两个 id &#x3D; 5 的记录，所以不会再继续扫描，于是停止扫描。</li>
</ol>
<p>从上面的分析中，可以得到<strong>事务 A 在主键索引上加了 2 个 X 型的锁</strong>：</p>
<p><img src="/2022/12/24/MySQL/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E5.drawio.png" alt="img"></p>
<ul>
<li>在 id &#x3D; 1 这条记录的主键索引上，加了范围为 (-∞, 1] 的 next-key 锁。意味着其他事务即无法更新或者删除 id &#x3D; 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。</li>
<li>在 id &#x3D; 5 这条记录的主键索引上，加了范围为 (1, 5] 的 next-key 锁。意味着其他事务即无法更新或者删除 id &#x3D; 5 的这一条记录，同时也无法插入 id 值为 2、3、4 的这一些新记录。</li>
</ul>
<p>我们也可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句来看看事务 A 加了什么锁。</p>
<p>输出结果如下，我这里只截取了行级锁的内容。</p>
<p><img src="/2022/12/24/MySQL/%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E.png" alt="img"></p>
<p>从上图中的分析中，可以得到事务 A 在主键索引上加了两个 X 型 next-key 锁，分别是：</p>
<ul>
<li>在 id &#x3D; 1 这条记录的主键索引上，加了范围为 (-∞, 1] 的 next-key 锁；</li>
<li>在 id &#x3D; 5 这条记录的主键索引上，加了范围为(1, 5 ] 的 next-key 锁。</li>
</ul>
<blockquote>
<p>实验三：再来看针对「小于」的范围查询时，查询条件值的记录「存在」表中的情况。</p>
</blockquote>
<p>如果事务 A 的查询语句是小于的范围查询，且查询条件值的记录（id 为 5）存在于表中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">5</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>事务 A 加锁变化过程如下：</p>
<ol>
<li>最开始要找的第一行是 id &#x3D; 1，于是对该记录加的是范围为 (-∞, 1] 的 next-key 锁；</li>
<li>由于是范围查找，就会继续往后找存在的记录，扫描到的第二行是 id &#x3D; 5，该记录是第一条不满足 id &lt; 5 条件的记录，于是**该记录的锁会退化为间隙锁，锁范围是 (1,5)**。</li>
<li>由于找到了第一条不满足 id &lt; 5 条件的记录，于是停止扫描。</li>
</ol>
<p>可以得知，此时<strong>事务 A 在主键索引上加了两种 X 型锁：</strong></p>
<p><img src="/2022/12/24/MySQL/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E5.drawio.png" alt="img"></p>
<ul>
<li>在 id &#x3D; 1 这条记录的主键索引上，加了范围为 (-∞, 1] 的 next-key 锁，意味着其他事务即无法更新或者删除 id &#x3D; 1 的这一条记录，同时也无法插入 id 小于 1 的这一些新记录。</li>
<li>在 id &#x3D; 5 这条记录的主键索引上，加了范围为 (1,5) 的间隙锁，意味着其他事务无法插入 id 值为 2、3、4 的这一些新记录。</li>
</ul>
<p>我们也可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句来看看事务 A 加了什么锁。</p>
<p>输出结果如下，我这里只截取了行级锁的内容。</p>
<p><img src="/2022/12/24/MySQL/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2%E5%B0%8F%E4%BA%8E.png" alt="img"></p>
<p>从上图中的分析中，可以得到事务 A 在主键索引上加了 <strong>X 型的范围为 (-∞, 1] 的 next-key 锁，和 X 型的范围为 (1, 5) 的间隙锁</strong>。</p>
<p>因此，通过前面这三个实验，可以得知。</p>
<p>在针对「小于或者小于等于」的唯一索引（主键索引）范围查询时，存在这两种情况会将索引的 next-key 锁会退化成间隙锁的：</p>
<ul>
<li>当条件值的记录「不在」表中时，那么不管是「小于」还是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 next-key 锁会<strong>退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的主键索引上加 next-key 锁。</li>
<li>当条件值的记录「在」表中时：<ul>
<li>如果是「小于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 next-key 锁会<strong>退化成间隙锁</strong>，其他扫描到的记录，都是在这些记录的主键索引上，加 next-key 锁。</li>
<li>如果是「小于等于」条件的范围查询，扫描到终止范围查询的记录时，该记录的主键索引中的 next-key 锁「不会」退化成间隙锁，其他扫描到的记录，都是在这些记录的主键索引上加 next-key 锁。</li>
</ul>
</li>
</ul>
<h3 id="非唯一索引等值查询"><a href="#非唯一索引等值查询" class="headerlink" title="#非唯一索引等值查询"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/how_to_lock.html#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2">#</a>非唯一索引等值查询</h3><p>当我们用非唯一索引进行等值查询的时候，<strong>因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁</strong>。</p>
<p>针对非唯一索引等值查询时，查询的记录存不存在，加锁的规则也会不同：</p>
<ul>
<li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是<strong>非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁</strong>。</li>
<li>当查询的记录「不存在」时，<strong>扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁</strong>。</li>
</ul>
<p>接下里用两个实验来说明。</p>
<h4 id="1、记录不存在的情况"><a href="#1、记录不存在的情况" class="headerlink" title="#1、记录不存在的情况"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/how_to_lock.html#_1%E3%80%81%E8%AE%B0%E5%BD%95%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E6%83%85%E5%86%B5">#</a>1、记录不存在的情况</h4><blockquote>
<p>实验一：针对非唯一索引等值查询时，查询的值不存在的情况。</p>
</blockquote>
<p>先来说说非唯一索引等值查询时，查询的记录不存在的情况，因为这个比较简单。</p>
<p>假设事务 A 对非唯一索引（age）进行了等值查询，且表中不存在 age &#x3D; 25 的记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">25</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>事务 A 加锁变化过程如下：</p>
<ul>
<li>定位到第一条不符合查询条件的二级索引记录，即扫描到 age &#x3D; 39，于是**该二级索引的 next-key 锁会退化成间隙锁，范围是 (22, 39)**。</li>
<li>停止查询</li>
</ul>
<p>事务 A 在 age &#x3D; 39 记录的二级索引上，加了 X 型的间隙锁，范围是 (22, 39)。意味着其他事务无法插入 age 值为 23、24、25、26、….、38 这些新记录。不过对于插入 age &#x3D; 22 和 age &#x3D; 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。</p>
<p><img src="/2022/12/24/MySQL/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.drawio.png" alt="img"></p>
<p>我们也可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句来看看事务 A 加了什么锁。</p>
<p>输出结果如下，我这里只截取了行级锁的内容。</p>
<p><img src="/2022/12/24/MySQL/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25.png" alt="img"></p>
<p>从上图的分析，可以看到，事务 A 在 age &#x3D; 39 记录的二级索引上（INDEX_NAME: index_age ），加了范围为 (22, 39) 的 X 型间隙锁。</p>
<p>此时，如果有其他事务插入了 age 值为 23、24、25、26、….、38 这些新记录，那么这些插入语句都会发生阻塞。不过对于插入 age &#x3D; 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，接下来我们就说！</p>
<blockquote>
<p>当有一个事务持有二级索引的间隙锁 (22, 39) 时，什么情况下，可以让其他事务的插入 age &#x3D; 22 或者 age &#x3D; 39 记录的语句成功？又是什么情况下，插入 age &#x3D; 22 或者 age &#x3D; 39 记录时的语句会被阻塞？</p>
</blockquote>
<p>我们先要清楚，什么情况下插入语句会发生阻塞。</p>
<p><strong>插入语句在插入一条记录之前，需要先定位到该记录在 B+树 的位置，如果插入的位置的下一条记录的索引上有间隙锁，才会发生阻塞</strong>。</p>
<p>在分析二级索引的间隙锁是否可以成功插入记录时，我们要先要知道二级索引树是如何存放记录的？</p>
<p>二级索引树是按照二级索引值（age列）按顺序存放的，在相同的二级索引值情况下， 再按主键 id 的顺序存放。知道了这个前提，我们才能知道执行插入语句的时候，插入的位置的下一条记录是谁。</p>
<p>基于前面的实验，事务 A 是在 age &#x3D; 39 记录的二级索引上，加了 X 型的间隙锁，范围是 (22, 39)。</p>
<p>插入 age &#x3D; 22 记录的成功和失败的情况分别如下：</p>
<ul>
<li>当其他事务插入一条 age &#x3D; 22，id &#x3D; 3 的记录的时候，在二级索引树上定位到插入的位置，而<strong>该位置的下一条是 id &#x3D; 10、age &#x3D; 22 的记录，该记录的二级索引上没有间隙锁，所以这条插入语句可以执行成功</strong>。</li>
<li>当其他事务插入一条 age &#x3D; 22，id &#x3D; 12 的记录的时候，在二级索引树上定位到插入的位置，而<strong>该位置的下一条是 id &#x3D; 20、age &#x3D; 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功</strong>。</li>
</ul>
<p>插入 age &#x3D; 39 记录的成功和失败的情况分别如下：</p>
<ul>
<li>当其他事务插入一条 age &#x3D; 39，id &#x3D; 3 的记录的时候，在二级索引树上定位到插入的位置，而<strong>该位置的下一条是 id &#x3D; 20、age &#x3D; 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功</strong>。</li>
<li>当其他事务插入一条 age &#x3D; 39，id &#x3D; 21 的记录的时候，在二级索引树上定位到插入的位置，而<strong>该位置的下一条记录不存在，也就没有间隙锁了，所以这条插入语句可以插入成功</strong>。</li>
</ul>
<p>所以，<strong>当有一个事务持有二级索引的间隙锁 (22, 39) 时，插入 age &#x3D; 22 或者 age &#x3D; 39 记录的语句是否可以执行成功，关键还要考虑插入记录的主键值，因为「二级索引值（age列）+主键值（id列）」才可以确定插入的位置，确定了插入位置后，就要看插入的位置的下一条记录是否有间隙锁，如果有间隙锁，就会发生阻塞，如果没有间隙锁，则可以插入成功</strong>。</p>
<p>知道了这个结论之后，我们再回过头看，非唯一索引等值查询时，查询的记录不存在时，执行<code>select * from performance_schema.data_locks\G;</code> 输出的结果。</p>
<p><img src="/2022/12/24/MySQL/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2age=25_1.png" alt="img"></p>
<p>在前面分析输出结果的时候，我说的结论是：「<em>事务 A 在 age &#x3D; 39 记录的二级索引上（INDEX_NAME: index_age ），加了范围为 (22, 39) 的 X 型间隙锁</em>」。这个结论其实还不够准确，因为只考虑了 LOCK_DATA 第一个数值（39），没有考虑 LOCK_DATA 第二个数值（20）。</p>
<p>那 <code>LOCK_DATA：39，20</code> 是什么意思？</p>
<ul>
<li>LOCK_DATA 第一个数值，也就是 39， 它代表的是 age 值。从前面我们也知道了，LOCK_DATA 第一个数值是 next-key 锁和间隙锁<strong>锁住的范围的右边界值</strong>。</li>
<li>LOCK_DATA 第二个数值，也就是 20， 它代表的是 id 值。</li>
</ul>
<p>之所以 LOCK_DATA 要多显示一个数值（ID值），是因为针对「当某个事务持有非唯一索引的 (22, 39) 间隙锁的时候，其他事务是否可以插入 age &#x3D; 39 新记录」的问题，还需要考虑插入记录的 id 值。而 <strong>LOCK_DATA 的第二个数值，就是说明在插入 age &#x3D; 39 新记录时，哪些范围的 id 值是不可以插入的</strong>。</p>
<p>因此， <code>LOCK_DATA：39，20</code> + <code>LOCK_MODE : X, GAP</code> 的意思是，事务 A 在 age &#x3D; 39 记录的二级索引上（INDEX_NAME: index_age ），加了 age 值范围为 (22, 39) 的 X 型间隙锁，**同时针对其他事务插入 age 值为 39 的新记录时，不允许插入的新记录的 id 值小于 20 **。如果插入的新记录的 id 值大于 20，则可以插入成功。</p>
<p>但是我们无法从<code>select * from performance_schema.data_locks\G;</code> 输出的结果分析出「在插入 age &#x3D;22 新记录时，哪些范围的 id 值是可以插入成功的」，这时候就<strong>得自己画出二级索引的 B+ 树的结构，然后确定插入位置后，看下该位置的下一条记录是否存在间隙锁，如果存在间隙锁，则无法插入成功，如果不存在间隙锁，则可以插入成功</strong>。</p>
<h4 id="2、记录存在的情况"><a href="#2、记录存在的情况" class="headerlink" title="#2、记录存在的情况"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/how_to_lock.html#_2%E3%80%81%E8%AE%B0%E5%BD%95%E5%AD%98%E5%9C%A8%E7%9A%84%E6%83%85%E5%86%B5">#</a>2、记录存在的情况</h4><blockquote>
<p>实验二：针对非唯一索引等值查询时，查询的值存在的情况。</p>
</blockquote>
<p>假设事务 A 对非唯一索引（age）进行了等值查询，且表中存在 age &#x3D; 22 的记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 山治   <span class="operator">|</span>  <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+-----+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>事务 A 加锁变化过程如下：</p>
<ul>
<li>由于不是唯一索引，所以肯定存在值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，最开始要找的第一行是 age &#x3D; 22，于是对该二级索引记录加上范围为 (21, 22] 的 next-key 锁。同时，因为 age &#x3D; 22 符合查询条件，于是对 age &#x3D; 22 的记录的主键索引加上记录锁，即对 id &#x3D; 10 这一行加记录锁。</li>
<li>接着继续扫描，扫描到的第二行是 age &#x3D; 39，该记录是第一个不符合条件的二级索引记录，所以该二级索引的 next-key 锁会<strong>退化成间隙锁</strong>，范围是 (22, 39)。</li>
<li>停止查询。</li>
</ul>
<p>可以看到，事务 A 对主键索引和二级索引都加了 X 型的锁：</p>
<p><img src="/2022/12/24/MySQL/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%E5%AD%98%E5%9C%A8.drawio.png" alt="img"></p>
<ul>
<li>主键索引：<ul>
<li>在 id &#x3D; 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id &#x3D; 10 的这一行记录。</li>
</ul>
</li>
<li>二级索引（非唯一索引）：<ul>
<li>在 age &#x3D; 22 这条记录的二级索引上，加了范围为 (21, 22] 的 next-key 锁，意味着其他事务无法更新或者删除 age &#x3D; 22 的这一些新记录，不过对于插入 age &#x3D; 20 和 age &#x3D; 21 新记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。</li>
<li>在 age &#x3D; 39 这条记录的二级索引上，加了范围 (22, 39) 的间隙锁。意味着其他事务无法插入 age 值为 23、24、….. 、38 的这一些新记录。不过对于插入 age &#x3D; 22 和 age &#x3D; 39 记录的语句，在一些情况是可以成功插入的，而一些情况则无法成功插入，具体哪些情况，会在后面说。</li>
</ul>
</li>
</ul>
<p>我们也可以通过 <code>select * from performance_schema.data_locks\G;</code> 这条语句来看看事务 A 加了什么锁。</p>
<p>输出结果如下，我这里只截取了行级锁的内容。</p>
<p><img src="/2022/12/24/MySQL/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E7%AD%89%E5%80%BC%E6%9F%A5%E8%AF%A2%EF%BC%88%E5%AD%98%E5%9C%A8%EF%BC%89.png" alt="img"></p>
<p>从上图的分析，可以看到，事务 A 对二级索引（INDEX_NAME: index_age ）加了两个 X 型锁，分别是：</p>
<ul>
<li>在 age &#x3D; 22 这条记录的二级索引上，加了范围为 (21, 22] 的 next-key 锁，意味着其他事务无法更新或者删除 age &#x3D; 22 的这一些新记录，针对是否可以插入 age &#x3D; 21 和 age &#x3D; 22 的新记录，分析如下：<ul>
<li>是否可以插入 age &#x3D; 21 的新记录，还要看插入的新记录的 id 值，<strong>如果插入 age &#x3D; 21 新记录的 id 值小于 5，那么就可以插入成功</strong>，因为此时插入的位置的下一条记录是 id &#x3D; 5，age &#x3D; 21 的记录，该记录的二级索引上没有间隙锁。<strong>如果插入 age &#x3D; 21 新记录的 id 值大于 5，那么就无法插入成功</strong>，因为此时插入的位置的下一条记录是 id &#x3D; 10，age &#x3D; 22 的记录，该记录的二级索引上有间隙锁。</li>
<li>是否可以插入 age &#x3D; 22 的新记录，还要看插入的新记录的 id 值，从 <code>LOCK_DATA : 22, 10</code> 可以得知，其他事务插入 age 值为 22 的新记录时，<strong>如果插入的新记录的 id 值小于 10，那么插入语句会发生阻塞；如果插入的新记录的 id 大于 10，还要看该新记录插入的位置的下一条记录是否有间隙锁，如果没有间隙锁则可以插入成功，如果有间隙锁，则无法插入成功</strong>。</li>
</ul>
</li>
<li>在 age &#x3D; 39 这条记录的二级索引上，加了范围 (22, 39) 的间隙锁。意味着其他事务无法插入 age 值为 23、24、….. 、38 的这一些新记录，针对是否可以插入 age &#x3D; 22 和 age &#x3D; 39 的新记录，分析如下：<ul>
<li>是否可以插入 age &#x3D; 22 的新记录，还要看插入的新记录的 id 值，<strong>如果插入 age &#x3D; 22 新记录的 id 值小于 10，那么插入语句会被阻塞，无法插入</strong>，因为此时插入的位置的下一条记录是 id &#x3D; 10，age &#x3D; 22 的记录，该记录的二级索引上有间隙锁（ age &#x3D; 22 这条记录的二级索引上有 next-key 锁）。<strong>如果插入 age &#x3D; 22 新记录的 id 值大于 10，也无法插入</strong>，因为此时插入的位置的下一条记录是 id &#x3D; 20，age &#x3D; 39 的记录，该记录的二级索引上有间隙锁。</li>
<li>是否可以插入 age &#x3D; 39 的新记录，还要看插入的新记录的 id 值，从 <code>LOCK_DATA : 39, 20</code> 可以得知，其他事务插入 age 值为 39 的新记录时，<strong>如果插入的新记录的 id 值小于 20，那么插入语句会发生阻塞，如果插入的新记录的 id 大于 20，则可以插入成功</strong>。</li>
</ul>
</li>
</ul>
<p>同时，事务 A 还对主键索引（INDEX_NAME: PRIMARY ）加了 X 型的记录锁：</p>
<ul>
<li>在 id &#x3D; 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id &#x3D; 10 的这一行记录。</li>
</ul>
<blockquote>
<p>为什么这个实验案例中，需要在二级索引索引上加范围 (22, 39) 的间隙锁？</p>
</blockquote>
<p>要找到这个问题的答案，我们要明白 MySQL 在可重复读的隔离级别场景下，为什么要引入间隙锁？其实<strong>是为了避免幻读现象的发生</strong>。</p>
<p>如果这个实验案例中：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">=</span> <span class="number">22</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br></pre></td></tr></table></figure>

<p>如果事务 A 不在二级索引索引上加范围 (22, 39) 的间隙锁，只在二级索引索引上加范围为 (21, 22] 的 next-key 锁的话，那么就会有幻读的问题。</p>
<p>前面我也说过，在非唯一索引上加了范围为 (21, 22] 的 next-key 锁，是无法完全锁住 age &#x3D; 22 新记录的插入，因为对于是否可以插入 age &#x3D; 22 的新记录，还要看插入的新记录的 id 值，从 <code>LOCK_DATA : 22, 10</code> 可以得知，其他事务插入 age 值为 22 的新记录时，如果插入的新记录的 id 值小于 10，那么插入语句会发生阻塞，<strong>如果插入的新记录的 id 值大于 10，则可以插入成功</strong>。</p>
<p>也就是说，只在二级索引索引（非唯一索引）上加范围为 (21, 22] 的 next-key 锁，其他事务是有可能插入 age 值为 22 的新记录的（比如插入一个 age &#x3D; 22，id &#x3D; 12 的新记录），那么如果事务 A 再一次查询 age &#x3D; 22 的记录的时候，前后两次查询 age &#x3D; 22 的结果集就不一样了，这时就发生了幻读的现象。</p>
<p><strong>那么当在 age &#x3D; 39 这条记录的二级索引索引上加了范围为 (22, 39) 的间隙锁后，其他事务是无法插入一个 age &#x3D; 22，id &#x3D; 12 的新记录，因为当其他事务插入一条 age &#x3D; 22，id &#x3D; 12 的新记录的时候，在二级索引树上定位到插入的位置，而该位置的下一条是 id &#x3D; 20、age &#x3D; 39 的记录，正好该记录的二级索引上有间隙锁，所以这条插入语句会被阻塞，无法插入成功，这样就避免幻读现象的发生</strong>。</p>
<p>所以，为了避免幻读现象的发生，就需要在二级索引索引上加范围 (22, 39) 的间隙锁。</p>
<h3 id="非唯一索引范围查询"><a href="#非唯一索引范围查询" class="headerlink" title="#非唯一索引范围查询"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/how_to_lock.html#%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2">#</a>非唯一索引范围查询</h3><p>非唯一索引和主键索引的范围查询的加锁也有所不同，不同之处在于<strong>非唯一索引范围查询，索引的 next-key lock 不会有退化为间隙锁和记录锁的情况</strong>，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 next-key 锁。</p>
<p>就带大家简单分析一下，事务 A 的这条范围查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">begin</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age <span class="operator">&gt;=</span> <span class="number">22</span>  <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name      <span class="operator">|</span> age <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">10</span> <span class="operator">|</span> 山治      <span class="operator">|</span>  <span class="number">22</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">20</span> <span class="operator">|</span> 香克斯    <span class="operator">|</span>  <span class="number">39</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-----------+-----+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>事务 A 的加锁变化：</p>
<ul>
<li>最开始要找的第一行是 age &#x3D; 22，虽然范围查询语句包含等值查询，但是这里不是唯一索引范围查询，所以是不会发生退化锁的现象，因此对该二级索引记录加 next-key 锁，范围是 (21, 22]。同时，对 age &#x3D; 22 这条记录的主键索引加记录锁，即对 id &#x3D; 10 这一行记录的主键索引加记录锁。</li>
<li>由于是范围查询，接着继续扫描已经存在的二级索引记录。扫面的第二行是 age &#x3D; 39 的二级索引记录，于是对该二级索引记录加 next-key 锁，范围是 (22, 39]，同时，对 age &#x3D; 39 这条记录的主键索引加记录锁，即对 id &#x3D; 20 这一行记录的主键索引加记录锁。</li>
<li>虽然我们看见表中最后一条二级索引记录是 age &#x3D; 39 的记录，但是实际在 Innodb 存储引擎中，会用一个特殊的记录来标识最后一条记录，该特殊的记录的名字叫 supremum pseudo-record ，所以扫描第二行的时候，也就扫描到了这个特殊记录的时候，会对该二级索引记录加的是范围为 (39, +∞] 的 next-key 锁。</li>
<li>停止查询</li>
</ul>
<p>可以看到，事务 A 对主键索引和二级索引都加了 X 型的锁：</p>
<p><img src="/2022/12/24/MySQL/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2age%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E22.drawio.png" alt="img"></p>
<ul>
<li>主键索引（id 列）：<ul>
<li>在 id &#x3D; 10 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id &#x3D; 10 的这一行记录。</li>
<li>在 id &#x3D; 20 这条记录的主键索引上，加了记录锁，意味着其他事务无法更新或者删除 id &#x3D; 20 的这一行记录。</li>
</ul>
</li>
<li>二级索引（age 列）：<ul>
<li>在 age &#x3D; 22 这条记录的二级索引上，加了范围为 (21, 22] 的 next-key 锁，意味着其他事务无法更新或者删除 age &#x3D; 22 的这一些新记录，不过对于是否可以插入 age &#x3D; 21 和 age &#x3D; 22 的新记录，还需要看新记录的 id 值，有些情况是可以成功插入的，而一些情况则无法插入，具体哪些情况，我们前面也讲了。</li>
<li>在 age &#x3D; 39 这条记录的二级索引上，加了范围为 (22, 39] 的 next-key 锁，意味着其他事务无法更新或者删除 age &#x3D; 39 的这一些记录，也无法插入 age 值为 23、24、25、…、38 的这一些新记录。不过对于是否可以插入 age &#x3D; 22 和 age &#x3D; 39 的新记录，还需要看新记录的 id 值，有些情况是可以成功插入的，而一些情况则无法插入，具体哪些情况，我们前面也讲了。</li>
<li>在特殊的记录（supremum pseudo-record）的二级索引上，加了范围为 (39, +∞] 的 next-key 锁，意味着其他事务无法插入 age 值大于 39 的这些新记录。</li>
</ul>
</li>
</ul>
<blockquote>
<p>在 age &gt;&#x3D; 22 的范围查询中，明明查询 age &#x3D; 22 的记录存在并且属于等值查询，为什么不会像唯一索引那样，将 age &#x3D; 22 记录的二级索引上的 next-key 锁退化为记录锁？</p>
</blockquote>
<p>因为 age 字段是非唯一索引，不具有唯一性，所以如果只加记录锁（记录锁无法防止插入，只能防止删除或者修改），就会导致其他事务插入一条 age &#x3D; 22 的记录，这样前后两次查询的结果集就不相同了，出现了幻读现象。</p>
<h3 id="没有加索引的查询"><a href="#没有加索引的查询" class="headerlink" title="#没有加索引的查询"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/how_to_lock.html#%E6%B2%A1%E6%9C%89%E5%8A%A0%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2">#</a>没有加索引的查询</h3><p>前面的案例，我们的查询语句都有使用索引查询，也就是查询记录的时候，是通过索引扫描的方式查询的，然后对扫描出来的记录进行加锁。</p>
<p><strong>如果锁定读查询语句，没有使用索引列作为查询条件，或者查询语句没有走索引查询，导致扫描是全表扫描。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞</strong>。</p>
<p>不只是锁定读查询语句不加索引才会导致这种情况，update 和 delete 语句如果查询条件不加索引，那么由于扫描的方式是全表扫描，于是就会对每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表。</p>
<p>因此，<strong>在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了</strong>，这是挺严重的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="#总结"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/lock/how_to_lock.html#%E6%80%BB%E7%BB%93">#</a>总结</h2><p>这次我以 <strong>MySQL 8.0.26</strong> 版本，在可重复读隔离级别之下，做了几个实验，让大家了解了唯一索引和非唯一索引的行级锁的加锁规则。</p>
<p>我这里总结下， MySQL 行级锁的加锁规则。</p>
<p>唯一索引等值查询：</p>
<ul>
<li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会<strong>退化成「记录锁」</strong>。</li>
<li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会<strong>退化成「间隙锁」</strong>。</li>
</ul>
<p>非唯一索引等值查询：</p>
<ul>
<li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后<strong>在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁</strong>。</li>
<li>当查询的记录「不存在」时，<strong>扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁</strong>。</li>
</ul>
<p>非唯一索引和主键索引的范围查询的加锁规则不同之处在于：</p>
<ul>
<li>唯一索引在满足一些条件的时候，索引的 next-key lock 退化为间隙锁或者记录锁。</li>
<li>非唯一索引范围查询，索引的 next-key lock 不会退化为间隙锁和记录锁。</li>
</ul>
<p>其实理解 MySQL 为什么要这样加锁，主要要以避免幻读角度去分析，这样就很容易理解这些加锁的规则了。</p>
<p>还有一件很重要的事情，在线上在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，<strong>如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了</strong>，这是挺严重的问题。</p>
<p>最后附上「@一只小铭」同学总结的流程图。</p>
<p>唯一索引（主键索引）加锁的流程图如下。（<em>注意这个流程图是针对「主键索引」的，如果是二级索引的唯一索引，除了流程图中对二级索引的加锁规则之外，还会对查询到的记录的主键索引项加「记录锁」，流程图没有提示这一个点，所以在这里用文字补充说明下</em>）</p>
<p><img src="/2022/12/24/MySQL/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B.jpeg" alt="img"></p>
<p>非唯一索引加锁的流程图：</p>
<p><img src="/2022/12/24/MySQL/%E9%9D%9E%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%8A%A0%E9%94%81%E6%B5%81%E7%A8%8B.jpeg" alt="img"></p>
<p>就说到这啦， 我们下次见啦！</p>
<h3 id="update语句的具体执行过程是怎样的？"><a href="#update语句的具体执行过程是怎样的？" class="headerlink" title="update语句的具体执行过程是怎样的？"></a>update语句的具体执行过程是怎样的？</h3><p>具体更新一条记录 UPDATE t_user SET name &#x3D; ‘xiaolin’ WHERE id &#x3D; 1; 的流程如下:</p>
<ol>
<li><p>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：</p>
</li>
<li><ul>
<li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li>
<li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li>
</ul>
</li>
<li><p>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：</p>
</li>
<li><ul>
<li>如果一样的话就不进行后续更新流程；</li>
<li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li>
</ul>
</li>
<li><p>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</p>
</li>
<li><p>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 <strong>WAL 技术</strong>，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</p>
</li>
<li><p>至此，一条记录更新完了。</p>
</li>
<li><p>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</p>
</li>
<li><p>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：</p>
</li>
<li><ul>
<li><strong>prepare 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong>commit 阶段</strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
</ul>
</li>
<li><p>至此，一条更新语句执行完成。</p>
</li>
</ol>
<h2 id="事务篇"><a href="#事务篇" class="headerlink" title="事务篇"></a><strong>事务</strong>篇</h2><p><strong>事务就是一组原子性的 SQL 查询，要么全部执行成功，要么全部执行失败。</strong></p>
<h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>事务必须满足 ACID 特征！（想想银行转账的例子）</p>
<ul>
<li><strong>A 原子性</strong><ul>
<li>事务必须被是为一个不可分割的最小工作单元，事务中的操作<strong>要么全部执行完，要么全部失败回滚</strong>。</li>
</ul>
</li>
<li><strong>C 一致性</strong><ul>
<li>数据库总是从一个一致性状态转变成另一个一致性状态，未提交事务所做的修改不会存入数据库，否则这个状态就是不一致的状态</li>
</ul>
</li>
<li><strong>I 隔离性</strong><ul>
<li>与具体隔离级别有关，通常一个事务提交前的中间结果对另一个事务不可见</li>
</ul>
</li>
<li><strong>D 持久性</strong><ul>
<li>事务提交后，所做的修改永久保存在数据库中，即使系统崩溃，修改的数据也不会消失</li>
</ul>
</li>
</ul>
<p>可以根据业务是否需要事务处理，选择合适的存储引擎。<strong>InnnoDB 支持事务</strong>，MyISAM 不支持。</p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a><strong>隔离级别</strong></h3><p>SQL标准中定义了四种隔离级别，每一种级别都规定了<strong>一个事务中所做的修改，在事务内和事务间是不是可见的</strong>。</p>
<h4 id="1）未提交读-READ-UNCOMMITTED"><a href="#1）未提交读-READ-UNCOMMITTED" class="headerlink" title="1）未提交读 READ UNCOMMITTED"></a>1）未提交读 READ UNCOMMITTED</h4><ul>
<li>&#x3D;&#x3D;事务提交前的修改对另一事务可见，造成<strong>脏读</strong>&#x3D;&#x3D; （很少用）</li>
<li>隔离级别最低，并发性最高，系统开销最低</li>
</ul>
<h4 id="2）提交读（不可重复读）READ-COMMITTED"><a href="#2）提交读（不可重复读）READ-COMMITTED" class="headerlink" title="2）提交读（不可重复读）READ COMMITTED"></a>2）提交读（不可重复读）READ COMMITTED</h4><ul>
<li>避免脏读，&#x3D;&#x3D;事务提交前的结果对其他事务不可见&#x3D;&#x3D;</li>
<li>但&#x3D;&#x3D;同一事务两次读取可能得到不同结果&#x3D;&#x3D;，无法避免<strong>不可重复读</strong></li>
<li><em><u>不可重复读的原因是，读取了其他（已提交）事务更改的数据。可使用<strong>行级锁</strong>解决不可重复读</u></em></li>
</ul>
<h4 id="3）可重复读（默认）REPEATABLE-READ"><a href="#3）可重复读（默认）REPEATABLE-READ" class="headerlink" title="3）可重复读（默认）REPEATABLE READ"></a>3）可重复读（默认）REPEATABLE READ</h4><ul>
<li>避免了脏读、不可重复读，&#x3D;&#x3D;在同一事务中读取多次记录结果一致&#x3D;&#x3D;，因为只能看到事务启动的数据</li>
<li>可能<strong>幻读</strong>，事务读取某个范围内的记录时，另一个事务在该范围内插入新记录，之前事务再次读取该范围的记录时，会产生<strong>幻行</strong></li>
<li><u><em>可通过 <strong>MVCC</strong> 和 <strong>表级锁</strong> 解决幻读</em></u></li>
</ul>
<h4 id="4）串行化-SERIALIZABLE"><a href="#4）串行化-SERIALIZABLE" class="headerlink" title="4）串行化 SERIALIZABLE"></a>4）串行化 SERIALIZABLE</h4><ul>
<li>最高隔离级别，强制事务串行执行，导致大量超时和锁争用问题。只有在非常需要保证数据一致性并且接受没有并发的情况下才使用</li>
</ul>
<img src="/2022/12/24/MySQL/image-20231022210520595.png" alt="image-20231022210520595" style="zoom:67%;"> 

<img src="/2022/12/24/MySQL/d5de450e901ed926d0b5278c8b65b9fe.png" alt="图片" style="zoom:60%;"> 

<p>在不同隔离级别下，事务 A 执行过程中查询到的余额可能会不同：</p>
<ul>
<li>在「读未提交」隔离级别下，事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；</li>
<li>在「不可重复读」隔离级别下，事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；</li>
<li>在「可重复读」隔离级别下，事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；</li>
<li>在「串行化」隔离级别下，事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200万。</li>
</ul>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a><strong>MVCC</strong></h3><p>多版本并发控制，大多数存储引擎都同时实现了 <strong>MVCC</strong> 和<strong>行级锁</strong>。MVCC 可以认为是行级锁的变种，但是它再很多情况下避免了加锁的操作。它的实现是通过<strong>保存数据在某个时间点的快照</strong>实现的，也就是说，<strong>不管需要执行多长时间，事务看到的数据是一致的。</strong></p>
<p>例如，<strong>InnoDB</strong> 的 MVCC 通过在每行记录后保存<strong>两个隐藏列</strong>来实现的。这两个列保存了<strong>行的创建时间</strong>和<strong>删除时间</strong>（不是真正的时间，是<strong>系统版本号</strong>）。每开始一个新事务，系统版本号自动递增。事务开始时刻的系统版本号会作为事务版本号，用来与查询到的每行记录的版本号对比，从而得知改行对本事务是否可见。<strong>可重复读</strong>级别下MVCC 的操作如下：</p>
<ul>
<li><p><strong>SELECT 查</strong></p>
<ul>
<li><p>InnoDB会根据以下两个条件检查每行记录：</p>
<ul>
<li>行的创建版本号 &lt;&#x3D; 当前事务版本号，确保<strong>行该在事务开始前就已经存在</strong>，或者是由事务自身插入或修改过的；</li>
<li>行的删除版本号 &gt; 当前事务版本 或者 删除版本未定义，确保该<strong>行在事务开始之前未删除</strong>；</li>
</ul>
<p>只有符合这两个条件，才能作为查询结果。</p>
</li>
</ul>
</li>
<li><p><strong>INSERT 增</strong></p>
<ul>
<li>InnoDB 为新插入的行保存<strong>当前系统版本号</strong>作为行版本号。</li>
</ul>
</li>
<li><p><strong>DELETE 删</strong></p>
<ul>
<li>InnoDB 为删除的行保存<strong>当前系统版本号</strong>为删除标识；</li>
<li>由于旧版本没有真正删除，InnoDB 开启后台线程清理工作（purge）。</li>
</ul>
</li>
<li><p><strong>UPDATE 改</strong></p>
<ul>
<li>相当于 INSERT + DELETE，InnoDB插入一条新纪录，并保存当前系统版本号为行版本号，同时保存当前系统版本号到原来的行，作为删除标识。</li>
</ul>
</li>
</ul>
<blockquote>
<p>保存这两个版本号，使得大多数读操作不用加锁。不仅能提升性能，而且而且也能保证只读到符合标准的行。但是，这需要更多的储存空间，更多的行检查，以及额外的维护成本。</p>
<p>MVCC只在<strong>可重复读</strong>和<strong>读已提交</strong>隔离级别下工作，因为<strong>读未提交</strong>总是读取最新的行，<strong>串行化</strong>则会所有行加锁。</p>
</blockquote>
<h3 id="幻读的解决方法："><a href="#幻读的解决方法：" class="headerlink" title="幻读的解决方法："></a>幻读的解决方法：</h3><p>快照读——MVCC</p>
<p>当前读——间隙锁</p>
<p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/transaction/phantom.html#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%9C%BA%E6%99%AF">https://www.xiaolincoding.com/mysql/transaction/phantom.html#%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%8F%91%E7%94%9F%E5%B9%BB%E8%AF%BB%E7%8E%B0%E8%B1%A1%E7%9A%84%E5%9C%BA%E6%99%AF</a></p>
<p><img src="/2022/12/24/MySQL/image-20241217152736828.png" alt="image-20241217152736828"></p>
<p>可重复读隔离级是由 MVCC (多版本并发控制)实现的，实现的方式是开始事务后(执行 begin 语句后)，在执行第一个查询语句后，会创建一个 Read View，后续的查询语句利用这个 Read View，通过这个Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是-样的，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</p>
<hr>
<h2 id="3-3-死锁"><a href="#3-3-死锁" class="headerlink" title="3.3 死锁"></a><strong>3.3 死锁</strong></h2><p>两个或多个事务，你占用我的资源，我占用你的资源，同时又在等对方释放自己需要的资源，称为死锁。</p>
<p>数据库实现了各种死锁检测和死锁超时机制。InnoDB 能检测死锁的循环依赖，并立即返回一个错误，将持有最少行级排他锁的事务进行回滚。</p>
<p>锁的行为和顺序是和存储引擎相关的，以相同的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有双重原因：因为真正的数据冲突（很难避免）或因为存储引擎的实现方式导致。</p>
<p>死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。</p>
<h4 id="3-4-事务日志"><a href="#3-4-事务日志" class="headerlink" title="3.4 事务日志"></a><strong>3.4 事务日志</strong></h4><p>事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时<strong>只需要修改其内存拷贝</strong>，再把<strong>修该修改行为记录到持久在硬盘上的事务日志</strong>中，而不用每次都<strong>将修改的数据本身持久到磁盘</strong>。事务日志采用的是<strong>追加</strong>的方式，因此写日志的操作是磁盘上一小块区域内的顺序IO，而不像随机I&#x2F;O需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。事务日志持久以后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。目前大多数存储引擎都是这样实现的，我们通常称之为<strong>预写式日志</strong>( Write-Ahead Logging)，<strong>修改数据需要写两次磁盘</strong>。</p>
<p>如果数据的修改已经记录到事务日志并持久化，但数据本身还没有写回磁盘，此时系统崩溃，存储引擎在<strong>重启时能够自动恢复这部分修改的数据</strong>。具体的恢复方式则视存储引擎而定。</p>
<h3 id="4-存储引擎介绍"><a href="#4-存储引擎介绍" class="headerlink" title="4. 存储引擎介绍"></a>4. 存储引擎介绍</h3><h4 id="4-1-InnoDB"><a href="#4-1-InnoDB" class="headerlink" title="4.1 InnoDB"></a>4.1 InnoDB</h4><h4 id="4-2-MyISAM"><a href="#4-2-MyISAM" class="headerlink" title="4.2 MyISAM"></a>4.2 MyISAM</h4><p>InnoDB 的特征：</p>
<p>支持事务、外键、行级锁</p>
<p>自适应哈希索引</p>
<p>1、原理过程</p>
<p> <img src="/2022/12/24/MySQL/1113510-20170830183917780-959160821.png" alt="img"></p>
<p>　　Innodb存储引擎会监控对表上二级索引的查找，如果发现某二级索引被频繁访问，二级索引成为热数据，建立哈希索引可以带来速度的提升，则：</p>
<p>　　1、自适应hash索引功能被打开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%ap%hash_index&#x27;;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| innodb_adaptive_hash_index | ON    |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>　　2、经常访问的二级索引数据会自动被生成到hash索引里面去(最近连续被访问三次的数据)，自适应哈希索引通过缓冲池的B+树构造而来，因此建立的速度很快。</p>
<h3 id="5-日志（不了解，学一下）"><a href="#5-日志（不了解，学一下）" class="headerlink" title="5. 日志（不了解，学一下）"></a>5. 日志（不了解，学一下）</h3><h4 id="介绍一下mysql-的日志"><a href="#介绍一下mysql-的日志" class="headerlink" title="介绍一下mysql 的日志"></a>介绍一下mysql 的日志</h4><ul>
<li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li>
<li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li>
<li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li>
</ul>
<h4 id="redo-log怎么保证持久性的？"><a href="#redo-log怎么保证持久性的？" class="headerlink" title="redo log怎么保证持久性的？"></a>redo log怎么保证持久性的？</h4><p>Redo log是MySQL中用于保证持久性的重要机制之一。它通过以下方式来保证持久性：</p>
<ol>
<li>Write-ahead logging（WAL）：在事务提交之前，将事务所做的修改操作记录到redo log中，然后再将数据写入磁盘。这样即使在数据写入磁盘之前发生了宕机，系统可以通过redo log中的记录来恢复数据。</li>
<li>Redo log的顺序写入：redo log采用追加写入的方式，将redo日志记录追加到文件末尾，而不是随机写入。这样可以减少磁盘的随机I&#x2F;O操作，提高写入性能。</li>
<li>Checkpoint机制：MySQL会定期将内存中的数据刷新到磁盘，同时将最新的LSN（Log Sequence Number）记录到磁盘中，这个LSN可以确保redo log中的操作是按顺序执行的。在恢复数据时，系统会根据LSN来确定从哪个位置开始应用redo log。</li>
</ol>
<h4 id="能不能只用binlog不用relo-log？"><a href="#能不能只用binlog不用relo-log？" class="headerlink" title="能不能只用binlog不用relo log？"></a>能不能只用binlog不用relo log？</h4><p>不行，binlog是 server 层的日志，没办法记录哪些脏页还没有刷盘，redolog 是存储引擎层的日志，可以记录哪些脏页还没有刷盘，这样崩溃恢复的时候，就能恢复那些还没有被刷盘的脏页数据。</p>
<h2 id="库表优化"><a href="#库表优化" class="headerlink" title="库表优化"></a>库表优化</h2><h3 id="优化数据类型"><a href="#优化数据类型" class="headerlink" title="优化数据类型"></a>优化数据类型</h3><p>选择正确的数据类型对到高性能至关重要，以下为几个原则：</p>
<ul>
<li><p>更小的通常更好</p>
<blockquote>
<p>1.尽量使用可以存储数据的最小数据类型，通常更快，占用更少的磁盘、内存、CPU资源，处理时需要的CPU周期也更少</p>
<p>2.必须确保没有低估要存储的值的范围，因为在 Schema 中多个地方增加数据类型的范围是个耗时且痛苦的的操作</p>
</blockquote>
</li>
<li><p>简单就好</p>
<blockquote>
<p>简单的数据类型操作需要更少的CPU周期</p>
<p>例如：整型比字符操作代价低，因为字符集和校对规则使字符比较比整型比较更复杂</p>
<p>应用：使用MySQL内建的类型而不是字符串存储日期和时间；使用整型存储IP地址而不是字符串</p>
</blockquote>
</li>
<li><p>&#x3D;&#x3D;尽量避免 NULL&#x3D;&#x3D;</p>
<blockquote>
<p>通常情况指定列为 NOT NULL，因为可能为 NULL 的列使得索引、索引统计、值比较都更复杂，占用更多存储空间，在 MySQL 中需要特殊处理。</p>
<p>当可为 NULL 的列被索引时，每个索引记录需要一个额外的字节，在 MyIASAM 甚至可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。但是把 NULL 变成 NOT NULL 带来的性能提升较小，优化时不优先考虑，除非要在该列上创建索引，这时应尽量避免 NULL</p>
<p>例外：InnoDB 使用单独的bit存储 NULL 值，对于稀疏数据有很好的空间效率</p>
</blockquote>
</li>
</ul>
<p><strong>选择标识符</strong></p>
<blockquote>
<p>标识符选择合适的类型非常重要，一般来说它可能会被用于与其他值比较、外键关联、查找，在用于外键关联时，需要严格要求外键类型一致，避免关联的性能问题和类型隐式转换问题<br><strong>整数类型是标识列最好的选择</strong>，因为他们可以使用<code>auto_increment</code>,应该避免使用字符串类型作为标识列，因为他们很消耗空间，通常，字符串比数字类型慢，在<code>myisam</code>，对字符串默认使用的是压缩索引，对于随机的字符串比如<code>MD5</code>()，<code>SHA1</code>()，<code>UUID</code>()产生的字符串，任意分布在很大的空间内，这会导致查询语句<code>insert/select</code>变得很慢：<br>插入新值会随机的写到索引的不同位置，导致分页、磁盘随机访问，聚簇索引产生碎片化<br><code>select</code>语句慢，因为逻辑上相邻的行会分布到磁盘和内存的任意地方，导致缓存对所有类型的查询语句效果都很差，访问局部性原理失效<br>存储<code>UUID</code>值应该去掉<code>-</code>,更好的做法是使用<code>HEX</code>()函数转化成<code>16</code>字节的数字，并采用<code>binary(16)</code>存储,如果要将<code>16</code>字节数字转化回去，应该使用<code>unhex()</code></p>
</blockquote>
<p><strong>使用枚举（ENUM）代替字符串类型</strong></p>
<p>枚举列把一些常用的字符串存储成一个预定的集合。MySQL 存储枚举十分紧凑，会根据列表值的数量压缩至1-2个字节，并将每个值在列表中的位置保存为整数，在<code>.frm</code>文件中保存“数字-字符串”映射关系的”查找表“</p>
<blockquote>
<p>注意：</p>
<ol>
<li>避免使用数字作为 ENUM 枚举常量，如<code>ENUM(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code>，这种双重性容易导致混乱</li>
<li>枚举字段按照内部存储的整数进行排序，而非字符串。绕过这种限制的方法按照需要的顺序定义枚举列，也可以在查询中用 FIELD（）指定顺序，但这会导致无法使用索引排序</li>
<li>字符串列表固定，增加或删除字符串用 ALTER TABLE</li>
</ol>
</blockquote>
<h3 id="MySql-schema-设计中的陷阱"><a href="#MySql-schema-设计中的陷阱" class="headerlink" title="MySql schema 设计中的陷阱"></a>MySql schema 设计中的陷阱</h3><blockquote>
<p>有一些问题由 MySQL 的实现机制导致</p>
</blockquote>
<ul>
<li><p>太多的列</p>
<blockquote>
<p>存储引擎 API 在服务器层和存储引擎层通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。<strong>从行缓冲中将编码过的列转换为行数据结构的代价非常高</strong>。MyISAM 的定长行结构与服务器层的行结构正好匹配，不需要转换；而 MyISAM 变长行结构和 InnoDB 的行结构需要转换，转换的代价依赖于列的数量。</p>
<p>例子：客户使用一个非常宽的表，但是只有一部分列会用到，转换代价高，CPU 占用高 </p>
</blockquote>
</li>
<li><p>太多关联</p>
<blockquote>
<p>MySQL 限制了每个关联操作最多只能 61 个表，实际上，如果希望查询进行的快且性能好，单个查询最好在 12 个表以内做关联</p>
</blockquote>
</li>
<li><p>全能的枚举</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ... (</span><br><span class="line">	country enum(&#x27;&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;...&#x27;31&#x27;));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>应该使用整数作为外键关联到查找表来查找具体值</p>
<p>而且只要改变枚举内元素，都需要 ALTER TABLE</p>
</blockquote>
</li>
<li><p>变相的枚举</p>
<blockquote>
<p>对于单一结果情况要用枚举列代替集合列</p>
</blockquote>
</li>
<li><p>不要绝对避免 NULL</p>
<blockquote>
<p>从特定类型的值域选择一个不可能的值可能导致代码复杂，引入 bug</p>
</blockquote>
</li>
</ul>
<h3 id="范式和反范式"><a href="#范式和反范式" class="headerlink" title="范式和反范式"></a>范式和反范式</h3><p><strong>范式的优点</strong></p>
<ul>
<li>范式化的数据只有很少或没有重复数据，所以<strong>更新操作更快</strong>，只需要修改更少的数据，并且检索列表数据时更少需要 <strong>DISTINCT</strong> 或 <strong>GROUP BY</strong> </li>
<li>范式化的表通常更小，可以更好的放在内存里，执行操作更快</li>
</ul>
<p><strong>范式的缺点</strong></p>
<ul>
<li>通常需要<strong>关联</strong>，代价昂贵，而且可能导致一些<strong>索引策略失效</strong>。比如：范式化将列存储在不同的表中，如果这些列在同一个表本可以属于同一索引</li>
</ul>
<p><strong>反范式的优点</strong></p>
<ul>
<li>所有数据在同一张表中，<strong>避免关联</strong>。因此，对于查询最差的情况——即使没有使用索引——是全表扫描，当数据比内存大时，肯呢个比关联快很多，因为这样避免了随机 IO</li>
<li>单独的表使用<strong>更有效的索引策略</strong></li>
</ul>
<p><strong>反范式的缺点</strong></p>
<ul>
<li>数据冗余，不利于更新</li>
<li>完全反范式化可能造成信息丢失</li>
</ul>
<p><strong>实际应用</strong></p>
<p>实际上使用部分范式的Schema，反范式化的方法有：</p>
<ul>
<li>通过复制或缓存，在不同表中存储相同的列，通过触发器更新缓存值</li>
<li>父表中冗余一些数据到子表中，从而方便索引和排序</li>
<li>缓存衍生值</li>
</ul>
<h3 id="缓存表和汇总表"><a href="#缓存表和汇总表" class="headerlink" title="缓存表和汇总表"></a>缓存表和汇总表</h3><p>维护方式：</p>
<ul>
<li>实时维护：准确</li>
<li>定期重建：节省资源，碎片少，有完全顺序组织的索引</li>
</ul>
<h3 id="加快-ALTER-TABLE-操作的速度"><a href="#加快-ALTER-TABLE-操作的速度" class="headerlink" title="加快 ALTER TABLE 操作的速度"></a>加快 ALTER TABLE 操作的速度</h3><blockquote>
<p>MySQL执行大部分修改表操作操作方式是，用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。在内存不同、表又很多、索引很多的情况下，会花费很长时间</p>
</blockquote>
<p>大部分 ALTER TABLE 会导致 MySQL 服务中断，常用技巧有两种：</p>
<ul>
<li>先在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库进行切换</li>
<li>“影子拷贝”，用要求的表结构创建一张与原表无关的新表，通过重命名和删表操作交换两张表</li>
</ul>
<p><strong>改变或删除一个列的默认值</strong></p>
<ul>
<li><pre><code class="mysql">ALTER TABLE sakila.film
MODIFY COLUMN tental_diration TINYINT(3) NOT NULL DEFAULT 5
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  `MODIFY COLUMN`通过表重建改变列的属性，慢</span><br><span class="line"></span><br><span class="line">- ```mysql</span><br><span class="line">  ALTER TABLE sakila.film</span><br><span class="line">  ALTER COLUMN tental_diration SET DEFAULT 5</span><br></pre></td></tr></table></figure>

`ALTER COLUMN`直接修改 . frm 文件，快
</code></pre>
</li>
</ul>
<h4 id="只修改-frm-文件"><a href="#只修改-frm-文件" class="headerlink" title="只修改 .frm 文件"></a>只修改 .frm 文件</h4><p>不需要重建表的情况：</p>
<ul>
<li>移除列的自增属性</li>
<li>增删改 ENUM、SET 常量（移除后已用到的常量值返回空）</li>
</ul>
<p>操作：</p>
<blockquote>
<p>为想要的表创建一个新的.frm文件，替换掉旧的文件</p>
</blockquote>
<ul>
<li>创建一张具有相同结构的空表，并进行修改（如增加 ENUM 常量）</li>
<li>关闭所有正在使用的表，并禁止任何表打开</li>
<li>交换.frm 文件</li>
<li>释放第二步的读锁</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE sakila.film_new LIKE sakila.film;</span><br><span class="line">ALTER TABLE sakila.film_new MODIFY COLUMN rating ENUM(\\\);</span><br><span class="line">FLUSH TABLES WITH READ LOCK;</span><br><span class="line">//用操作系统命令交换.frm文件</span><br><span class="line">UNLOCK TABLES;</span><br></pre></td></tr></table></figure>

<h4 id="快速创建-MyISAM-索引"><a href="#快速创建-MyISAM-索引" class="headerlink" title="快速创建 MyISAM 索引"></a>快速创建 MyISAM 索引</h4><p>为了高效载入数据到 MyISAM 表，有一个常用技巧是<strong>禁用索引</strong><code>ALTER TABLE ... DISABLE KEYS</code>、<strong>载入数据</strong>、<strong>启用索引</strong><code>ALTER TABLE ... ENABLE KEYS</code></p>
<p>将构建索引的工作延迟到数据完全载入，可以通过排序构建索引，并使索引树的碎片更少、更紧凑</p>
<p>但是，<code>DISABALE KEYS </code> 对唯一索引无效，当知道数据都是有效的并且没必要做唯一性检查时可以这样做：</p>
<ul>
<li>用需要的表结构创建一张表，但不包括索引</li>
<li>载入数据到 .MYD 文件</li>
<li>按照需要的结构创建另一张空表，包含索引。这时创建需要的.frm 和 .MYI 文件</li>
<li>获取读锁并刷新表</li>
<li>重命名第二张表的.frm .MYI 文件，让 MySQL 认为是第一张表的文件</li>
<li>释放读锁</li>
<li>使用 REPAIR TABLE 重建表的索引，该操作会通过排序构建所有索引，包括唯一索引</li>
</ul>
<h2 id="索引篇"><a href="#索引篇" class="headerlink" title="索引篇"></a>索引篇</h2><p><strong>索引</strong>是<strong>存储引擎</strong>用于快速找到记录的一种<strong>数据结构</strong>，可以比作字典中的目录。MySQL先在索引找到匹配的索引记录，再根据记录找到对应的数据行。</p>
<h3 id="1-索引类型"><a href="#1-索引类型" class="headerlink" title="1. 索引类型"></a>1. 索引类型</h3><p>按索引数据结构分：B树索引 &amp; 哈希索引； 按存储引擎分：InnoDB使用聚簇索引+二级索引，MyISAM使用主键索引+二级索引</p>
<h4 id="B-Tree-索引"><a href="#B-Tree-索引" class="headerlink" title="B-Tree 索引"></a>B-Tree 索引</h4><p>InnoDB，MyISAM 使用的是B+Tree 实现。</p>
<p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/page.html#innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84">https://xiaolincoding.com/mysql/index/page.html#innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84</a></p>
<h5 id="why-索引结构是B-树不是B树？"><a href="#why-索引结构是B-树不是B树？" class="headerlink" title="&#x3D;&#x3D;why 索引结构是B+树不是B树？&#x3D;&#x3D;"></a>&#x3D;&#x3D;why 索引结构是B+树不是B树？&#x3D;&#x3D;</h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JCpeng/p/15231338.html">B+树和B树的区别</a></p>
<img src="/2022/12/24/MySQL/image-20241208163805161.png" style="zoom:50%;">

<img src="/2022/12/24/MySQL/image-20241208163825551.png" style="zoom:50%;">

<ul>
<li><p>B+ 树<strong>非叶子结点不存储数据</strong>，同样大小的<strong>磁盘页可以容纳更多的节点</strong>，树更矮胖，<strong>I&#x2F;O 次数少</strong></p>
<blockquote>
<p>正因为 B+ 树非叶子节点不存储数据，所有数据都放在叶子节点，所以会出现重复元素。而 B 树节点不会出现重复元素。</p>
</blockquote>
</li>
<li><p>B+ 树<strong>叶子结点组成链表</strong>，方便范围查询</p>
</li>
</ul>
<p>工作过程：</p>
<p>B-Tree 索引能加快访问数据的速度，因为存储引擎不再需要全表扫描获取数据，而是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值从而找到合适的指针进入下层节点，这些指针实际定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么不存在。</p>
<p>优点：</p>
<p>加快访问数据的速度，树的深度影响 IO 次数；对索引列顺序组织存储，适合查找范围数据。</p>
<h5 id="问：MySQL-中是怎么利用索引查找范围数据的？"><a href="#问：MySQL-中是怎么利用索引查找范围数据的？" class="headerlink" title="&#x3D;&#x3D;问：MySQL 中是怎么利用索引查找范围数据的？&#x3D;&#x3D;"></a>&#x3D;&#x3D;问：MySQL 中是怎么利用索引查找范围数据的？&#x3D;&#x3D;</h5><p>在 MySQL 中，利用索引查找范围数据的过程可以分为以下几个步骤：</p>
<ol>
<li><strong>索引结构</strong></li>
</ol>
<p>MySQL 中最常用的索引结构是 <strong>B+树</strong> 索引。B+树是一种平衡树，其叶子节点存储索引键值和指向数据表行的指针（可以这么理解）。范围查找的高效性源于 B+树的有序性，能够快速锁定范围的起始位置。</p>
<ol start="2">
<li><strong>查找范围起点</strong></li>
</ol>
<p>MySQL 使用索引的过程通常如下：</p>
<p>（1）<strong>定位范围起始值</strong>：通过 B+树的二分查找算法，从根节点到叶子节点，快速定位到范围的<strong>起始节点</strong>。</p>
<p>（2）如果范围查找中有多个条件（如 <code>WHERE a &gt; 10 AND a &lt; 20</code>），则会根据范围条件中的左值（如 <code>a &gt; 10</code>）确定起点。</p>
<ol start="3">
<li><strong>顺序扫描叶子节点</strong></li>
</ol>
<p>一旦定位到起点，MySQL 不需要再次从根节点开始，而是直接通过 B+树叶子节点的链表结构<strong>顺序扫描</strong>数据：</p>
<ul>
<li><strong>判断条件</strong>：每扫描一条数据，都会根据范围条件判断是否符合目标范围。</li>
<li><strong>终止扫描</strong>：当遇到索引键值超出范围条件（如 <code>a &gt;= 20</code>）时，停止扫描。</li>
</ul>
<p>这种顺序扫描是范围查找的核心优化点，它避免了全表扫描，大幅提升查询效率。</p>
<ol start="4">
<li><strong>&#x3D;&#x3D;覆盖索引的优化&#x3D;&#x3D;（如果有覆盖索引）</strong></li>
</ol>
<p>如果查询只需要读取索引列的数据（例如 <code>SELECT a FROM table WHERE a &gt; 10 AND a &lt; 20</code>），则可以完全在索引中完成范围扫描，无需访问表数据（即避免回表操作）。</p>
<ol start="5">
<li><strong>回表操作（如果索引不覆盖查询列）</strong></li>
</ol>
<p>如果查询需要的列超出了索引包含的范围（例如 <code>SELECT * FROM table WHERE a &gt; 10 AND a &lt; 20</code>），则需要：</p>
<ol>
<li>从叶子节点的指针找到实际的数据行。</li>
<li>读取其他非索引列。</li>
</ol>
<p>这个过程叫<strong>回表</strong>，会增加一定的 IO 开销。</p>
<ol start="6">
<li><strong>常见的范围查询条件</strong></li>
</ol>
<p>索引范围查找常见的条件包括：</p>
<ul>
<li><strong>比较运算符</strong>：<code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
<li><strong>范围操作符</strong>：<code>BETWEEN ... AND ...</code></li>
<li><strong>LIKE（前缀匹配）</strong>：<code>LIKE &#39;abc%&#39;</code></li>
</ul>
<p>MySQL 会利用索引的有序性高效处理这些范围查询。</p>
<ol start="7">
<li><strong>范围查询的优化</strong></li>
</ol>
<ul>
<li>**&#x3D;&#x3D;组合索引的使用&#x3D;&#x3D;**：对于多列范围条件，MySQL 通常只能利用最左前缀列（例如 <code>(a, b)</code> 的索引，查询 <code>WHERE a &gt; 10 AND b &lt; 5</code> 时只能用到 <code>a</code> 的范围查询，<code>b</code> 的范围只能用于过滤）。</li>
<li><strong>&#x3D;&#x3D;索引下推&#x3D;&#x3D;（Index Condition Pushdown，ICP）</strong>：MySQL 5.6 之后引入的优化，在索引扫描过程中提前过滤满足条件的行，减少回表次数。</li>
</ul>
<ol start="8">
<li><strong>案例分析（面试举这个例子 + 组合索引（最左前缀） + 索引下推 + 覆盖索引  【三种优化】）</strong></li>
</ol>
<p>假设有以下表和查询语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    <span class="keyword">value</span> <span class="type">INT</span>,</span><br><span class="line">    INDEX (<span class="keyword">value</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> <span class="keyword">value</span> <span class="operator">&gt;</span> <span class="number">10</span> <span class="keyword">AND</span> <span class="keyword">value</span> <span class="operator">&lt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p><strong>查询过程：</strong></p>
<p>a. MySQL 通过 B+树索引 <code>value</code>，快速定位到索引值 <code>11</code> 的起始位置。</p>
<p>b. 顺序扫描叶子节点中 <code>value</code> 范围在 <code>11</code> 到 <code>19</code> 的所有记录。</p>
<p>c. 如果查询需要其他列（如 <code>id</code>），会进行回表操作读取完整数据。</p>
<hr>
<p><strong>已知建立了一个多列索引，可以使用B-Tree索引的查询类型：</strong></p>
<ul>
<li><p>全值匹配：与索引中的所有列进行匹配；</p>
</li>
<li><p>匹配最左前缀：只用索引的第一列；</p>
</li>
<li><p>匹配列前缀 ：匹配第一列值的开头部分；</p>
</li>
<li><p>匹配范围值 ；精确匹配某一列并范围匹配另一列 ；只访问索引的查询。</p>
</li>
</ul>
<p><strong>不可以使用B-Tree索引的查询类型：</strong></p>
<ul>
<li>不符合最左前缀；跳过索引中的列；不能先范围，后精确。</li>
</ul>
<p>ps：索引的列的顺序非常重要，上述限制都和索引列的顺序有关。所以，优化可以使用相同的列但顺序不同的索引，满足不同的查询要求！</p>
<hr>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>（不重要，先不用看）</p>
<p>基于哈希表实现，只有精确匹配索引的所有列的查询才有效。存储引擎对所有索引列计算一个哈希码，哈希索引将所有哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针</p>
<p>Memory 支持非唯一哈希索引（默认）InnoDB 支持自适应哈希索引</p>
<blockquote>
<p>工作过程：</p>
<p>根据索引列计算哈希值，根据哈希值找到对应的记录指针，最后比较索引列值和所查找的是否相同（可能有哈希冲突，索引列不同，但是哈希码相同）</p>
</blockquote>
<p><strong>哈希索引的优点</strong></p>
<ul>
<li>索引本身只存储哈希值和行指针，结构紧凑，查找速度快</li>
</ul>
<p><strong>哈希索引的缺点</strong></p>
<ul>
<li><p>哈希索引只包含<strong>哈希值</strong>和<strong>行指针</strong>，不存储<strong>字段值</strong>，不可能做到<strong>覆盖索引查询</strong></p>
<blockquote>
<p>由于访问内存中行的速度很快，所以这一点对性能影响不明显</p>
</blockquote>
</li>
<li><p>哈希索引数据不是<strong>按索引值顺序存储</strong>的，而是按照经过哈希函数运算得到的槽编号顺序排序的，随意无法<strong>用于排序</strong></p>
</li>
<li><p>哈希索引不支持<strong>部分索引列匹配查询</strong>。索引列的全部内容用于计算哈希值</p>
<blockquote>
<p>(A,B) 索引，不能提供单独对 A 的查询</p>
</blockquote>
</li>
<li><p>只支持等值查询，不支持范围查询</p>
</li>
<li><p>可能有哈希冲突（查找和删除，遍历整个链表所有的行指针，逐行比较）</p>
</li>
</ul>
<blockquote>
<p>InnoDB 自适应哈希索引：</p>
<p>当某些索引值被频繁使用，在内存中基于B-Tree索引再创建一个哈希索引。这样 B-Tree 索引也具有哈希索引的优点，比如快速查找。</p>
<p>这时完全自动的、内部的行为，用户无法控制，但是可以关闭</p>
</blockquote>
<p><strong>自定义哈希索引</strong></p>
<p>B-Tree基础上创建一个伪哈希索引，利用哈希值而不是键本身进行索引查找。只需再where中指定使用的哈希函数</p>
<ul>
<li><p>R-Tree（空间数据索引）</p>
</li>
<li><p>全文索引</p>
</li>
</ul>
<hr>
<h4 id="聚簇索引-二级索引"><a href="#聚簇索引-二级索引" class="headerlink" title="聚簇索引 &amp; 二级索引"></a>聚簇索引 &amp; 二级索引</h4><p>（配合<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/page.html#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95">聚簇索引和二级索引</a>学习）</p>
<p>聚簇索引不只是一种索引类型，更是表示数据聚集的一种数据存储方式，数据都存放在B+树的叶子节点上，<strong>数据即索引、索引即数据。</strong>InnoDB 通过主键聚集数据，并且自动创建聚簇索引：</p>
<img src="/2022/12/24/MySQL/image-20240318122307563.png" alt="image-20240318122307563" style="zoom: 50%;"> 

<blockquote>
<p>页和页之间双向链表，页内数据项之间单向链表。根据主键升序排序。</p>
</blockquote>
<ol>
<li>索引和数据存储在一起</li>
<li>同一页内的数据记录存储在一起（InnoDB 只聚集同一个页面中的记录，包含相邻键值的页面可能相距很远）</li>
</ol>
<p>​	<strong>聚簇索引的优点</strong></p>
<ol>
<li><strong>IO 次数少</strong>，相关数据保存在一起，只需要从磁盘中读取少量数据页就能获得全部所需数据，并且对主键的<strong>排序查找</strong>和<strong>范围查找</strong>很快</li>
<li>查找速度快，通过索引直接访问到数据，省去通过行指针跳转的过程（<strong>回表</strong>）</li>
<li>使用覆盖索引扫描的查询可以直接使用叶结点中的主键值</li>
</ol>
<p>​	<strong>聚簇索引的缺点</strong></p>
<ol>
<li>如果数据能全部放在内存中，那么访问的顺序没那么重要，聚簇索引失去优势</li>
<li>&#x3D;&#x3D;插入速度严重依赖插入顺序，随机插入会导致页分裂的情况&#x3D;&#x3D;，做好按照主键增加的顺序插入</li>
<li>更新索引、&#x3D;&#x3D;更新主键代价高&#x3D;&#x3D;</li>
<li>二级索引因保存主键值而占用更多空间，并且需要回表</li>
</ol>
<p>​	<strong>InnoDB 和 MyISAM 数据分布对比</strong></p>
<ul>
<li>MyISAM 按照数据插入顺序存储在磁盘上，表存储结构的叶子节点上保存了当前索引列值和物理行所在的位置，主键索引（名称为 PRIMARY 的唯一非空索引）和其他索引在结构上没有不同</li>
</ul>
<center>
    <img src="/2022/12/24/MySQL/Users\19358\AppData\Roaming\Typora\typora-user-images\image-20221224172839116.png" alt="image-20221224172839116" style="zoom:67%;"><img src="/2022/12/24/MySQL/Users\19358\AppData\Roaming\Typora\typora-user-images\image-20221224172912677.png" alt="image-20221224172912677" style="zoom:67%;"><img src="/2022/12/24/MySQL/Users\19358\AppData\Roaming\Typora\typora-user-images\image-20221224172936821.png" alt="image-20221224172936821" style="zoom:67%;">
</center>



<ul>
<li><p>InnoDB 支持聚簇索引，每个叶子节点包括主键值、事务ID、回滚指针和<strong>剩余列</strong></p>
</li>
<li><p>在InnoDB聚簇索引中，节点页上保存的是行主键，如果没有主键列，InnoDB会选择一个非空索引代替，如果也没有这样的索引，InnoDB会创建一个隐式的主键来进行聚簇</p>
<img src="/2022/12/24/MySQL/image-20221224173249890.png" alt="image-20221224173249890" style="zoom:67%;">
</li>
<li><p>在Innodb中，没有被用来做聚簇的索引，被称为是二级索引，在索引中保存的并不是物理行的位置，而是行记录的主键，需要根据二级索引找到行主键之后再到聚簇B-Tree中查找指定的行记录</p>
<img src="/2022/12/24/MySQL/image-20221224173309788.png" alt="image-20221224173309788" style="zoom:67%;">

<img src="/2022/12/24/MySQL/image-20221224173407605.png" alt="image-20221224173407605" style="zoom:67%;"></li>
</ul>
<p>总结：聚簇索引查询效率高（不用回表），增删改效率低（索引即数据，都要改）	</p>
<p><strong>InnoDB 按主键顺序插入行</strong></p>
<blockquote>
<p>随即插入的后果：</p>
<ul>
<li>写入的目标页可能已经刷到磁盘并从缓存中移除，或者还没加载到缓存，InnoDB 插入前不得不先找到磁盘并读取目标页到缓存中。导致大量随机 IO</li>
<li>写入乱序，产生页分裂，以便为新行分配空间，移动大量数据，产生内存碎片</li>
</ul>
<p>注：插入后 OPTIMIZE TABLE 重建表并优化页的填充</p>
</blockquote>
<h4 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h4><ul>
<li>大大减少服务器要扫描的数据量</li>
<li>帮助服务器避免排序和临时表</li>
<li>将随机 IO 变为顺序 IO</li>
</ul>
<h3 id="从数据叶角度看-B-树"><a href="#从数据叶角度看-B-树" class="headerlink" title="从数据叶角度看 B+ 树"></a>从数据叶角度看 B+ 树</h3><h4 id="InnoDB-是如何存储数据的？"><a href="#InnoDB-是如何存储数据的？" class="headerlink" title="# InnoDB 是如何存储数据的？"></a><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/page.html#innodb-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84">#</a> InnoDB 是如何存储数据的？</h4><h3 id="什么时候不需要创建索引？"><a href="#什么时候不需要创建索引？" class="headerlink" title="什么时候不需要创建索引？"></a>什么时候不需要创建索引？</h3><p>索引最大的好处是<strong>提高查询速度</strong>，也有<strong>缺点</strong>的，比如:</p>
<ul>
<li><p>占用物理空间，数量越大，<strong>占用空间</strong>越大;</p>
</li>
<li><p><strong>创建索引和维护索引</strong>要耗费时间，这种时间随着数据量的增加而增大;</p>
</li>
<li><p>会<strong>降低表的增删改的效率</strong>，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</p>
</li>
</ul>
<p><img src="/2022/12/24/MySQL/image-20241220094505854.png" alt="image-20241220094505854"></p>
<p>所以，索引不是万能钥匙，它也是根据场景来使用的。</p>
<hr>
<p><strong>什么时候适用索引？</strong></p>
<ul>
<li><p>字段有<strong>唯一性</strong>限制的，比如商品编码;</p>
</li>
<li><p><strong>经常用于 WHERE 查询条件</strong>的字段，这样能够提高整个表的查询速度，<strong>如果查询条件不是一个字段，可以建立联合索引。</strong></p>
</li>
<li><p><strong>经常用于 GROUP BY 和 ORDER BY 的字段</strong>，这样在査询的时候就<strong>不需要再去做一次排序</strong>了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</p>
</li>
</ul>
<hr>
<p><strong>什么时候不需要创建索引？</strong></p>
<p><strong>WHERE 条件，GROUP BY 字段 ORDER BY</strong> 里用不到的字段，索引的价值是快速定位，如果起不到定位的通常是不需要创建索引的，因为索引是会占用物理空间的。</p>
<p>字段中存在<strong>大量重复数据</strong>，不需要创建索引，比如<strong>性别字段，只有男女</strong>，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</p>
<p><strong>表数据太少</strong>的时候，不需要创建索引，直接全表扫描也不慢；</p>
<p><strong>经常更新的字段</strong>不用创建索引，比如不要对电商项目的<strong>用户余额</strong>建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</p>
<p>&#x3D;&#x3D;问：讲讲索引优化，能说多少就说多少。&#x3D;&#x3D;</p>
<p>（1）索引覆盖、索引下推——减少回表</p>
<p>（2）要防止索引失效，索引失效有这么几种情况：</p>
<h3 id="3-索引失效的情况"><a href="#3-索引失效的情况" class="headerlink" title="3.索引失效的情况"></a>3.索引失效的情况</h3><h4 id="3-1-对索引使用表达式、函数"><a href="#3-1-对索引使用表达式、函数" class="headerlink" title="3.1 对索引使用表达式、函数"></a>3.1 对索引使用表达式、函数</h4><p>一些查询不当地使用索引，可能导致Mysql 不能使用现有索引。如果查询中的列不是独立的，就不能使用索引。也就是说，<strong>索引列不能是表达式的一部分，也不能是函数的参数</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> id <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> TO_DAYS(<span class="built_in">CURRENT_DATE</span>) <span class="operator">-</span> TO_DAYS(date_col) <span class="operator">=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>养成简化 WHERE 条件的习惯，将<strong>索引列单独放在比较符号一侧</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHere</span> id <span class="operator">=</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> data_cTA_SUB(CURRENT_DATA, <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">DAY</span>)</span><br></pre></td></tr></table></figure>

<p>索引列 id 和 data_col 都在等号的左侧</p>
<blockquote>
<p>为什么对索引使用函数或表达式，就无法走索引了呢？</p>
</blockquote>
<p>因为索引保存的是索引字段的原始值，而不是经过函数或表达式计算后的值，只能通过把索引字段的值都取出来，依次进行函数&#x2F;表达式计算并进行条件判断，采用全表扫描。</p>
<p>不过，从 MySQL 8.0 开始，索引特性增加了函数索引，即可以针对函数计算后的值建立一个索引，例如对<code>length(name)</code> 的计算结果建立一个名为 <code>idx_name_length</code> 的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t <span class="keyword">add</span> key idx_name_length (length(name))</span><br></pre></td></tr></table></figure>

<h4 id="3-2-前缀索引和索引选择性"><a href="#3-2-前缀索引和索引选择性" class="headerlink" title="3.2 前缀索引和索引选择性"></a>3.2 前缀索引和索引选择性</h4><p>当需要<strong>索引很长的字符串</strong>时，会让索引变得很大且慢。除了使用自定义哈希索引外，还可以<strong>使用前缀索引</strong>，也就是<strong>索引开始的部分字符</strong>，这样可以<strong>大大节约索引空间</strong>，提高索引效率。</p>
<p>索引的选择性指的是不重复的索引值与总记录数的比值。唯一索引的选择性是1，是性能最好的因为高选择性的索引可以在查询时过滤掉很多行。</p>
<p>一般情况某个列前缀的选择性也是足够高的，对于BLOB、TEXT 或者很长的 VARCHAR 类型的列，必须使用前缀索引，因为 MySQL 不允许索引这些列的完整长度。</p>
<p>​	<strong>前缀索引长度的确定</strong></p>
<ol>
<li>索引前缀不能太短，会导致选择性太低；不能太长，会占用索引空间。我们<strong>增加前缀的&#x3D;&#x3D;长度&#x3D;&#x3D;直到选择性接近完整列的选择性</strong>；</li>
<li>除了考虑平均选择性，还要考虑最坏情况下的选择性（特别是数据分布不均匀的时候，比如很多城市都以“San”“New”开头，那对于这种城市如果建立长度为3的前缀索引，选择性会非常糟糕，远远低于平均选择性）。</li>
</ol>
<p>​	<strong>前缀索引的优缺点</strong></p>
<ul>
<li>大大节约索引空间，提高索引效率（控制长度别太大）；</li>
<li>降低索引的选择性（控制长度别太小）；</li>
<li><strong>Mysql无法使用前缀索引做 ORDER BY &#x2F; GROUP BY，也不能做覆盖扫描</strong>（如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引）。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://chatgpt.com/share/675579c8-10b0-800a-b4d9-46786d65c319">https://chatgpt.com/share/675579c8-10b0-800a-b4d9-46786d65c319</a></p>
<hr>
<h4 id="对索引隐式类型转换"><a href="#对索引隐式类型转换" class="headerlink" title="对索引隐式类型转换"></a>对索引隐式类型转换</h4><p><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/index_lose.html#%E5%AF%B9%E7%B4%A2%E5%BC%95%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">https://xiaolincoding.com/mysql/index/index_lose.html#%E5%AF%B9%E7%B4%A2%E5%BC%95%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2</a></p>
<hr>
<h4 id="3-3-多列索引"><a href="#3-3-多列索引" class="headerlink" title="3.3 多列索引"></a>3.3 多列索引</h4><p>很多人对索引的理解不够，一个常见的错误就是，为每个列单独创建索引。大多数情况下，这并不能提高Mysql的查询性能。Mysql5.0之后引入了“索引合并”策略，可以使用多个单列索引来定位指定的行。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, actor_id <span class="keyword">FROM</span> film_actor</span><br><span class="line"><span class="keyword">WHERE</span> actor_id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">OR</span> film_id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>在旧版Mysql中，两个actor_id、film_id的单列索引都不能用，只能全表扫描。除非写成两个查询UNION的形式。</p>
<p>使用多个列创建的索引有时比多个单列索引更高效</p>
<h4 id="3-4-合适的索引顺序"><a href="#3-4-合适的索引顺序" class="headerlink" title="3.4 合适的索引顺序"></a>3.4 合适的索引顺序</h4><p>索引列正确的顺序依赖于使用该索引的查询，，同时考虑如何更好地满足排序和分组的需要。在一个多列的B树索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是的二列。</p>
<p>在不需要考虑排序和分组时，<strong>将选择性最高的列放在索引最前列</strong>，这样能最快的过滤出需要的行</p>
<blockquote>
<p>注意：不要假设平均情况下的性能能代表特殊情况下的性能。特殊情况可能毁掉整个应用的性能</p>
</blockquote>
<h4 id="！！-覆盖索引"><a href="#！！-覆盖索引" class="headerlink" title="！！&#x3D;&#x3D;覆盖索引&#x3D;&#x3D;"></a>！！&#x3D;&#x3D;覆盖索引&#x3D;&#x3D;</h4><p>​	<strong>索引包含所需要查询的字段的值</strong>，查询不需要再读取数据行，称为覆盖索引。覆盖索引只需扫描索引，<strong>不需回表</strong></p>
<p>​	<strong>覆盖索引的好处</strong></p>
<ol>
<li><p>索引条目通常远小于数据行大小，只需要读取索引，<strong>减少数据访问量</strong></p>
<blockquote>
<p>这对缓存的负载十分重要，因为这种情况响应时间大部分花在数据拷贝上；对 IO 密集型应用也有帮助，因为索引比数据小，更容易放在内存</p>
</blockquote>
</li>
<li><p>因为索引是按照列值顺序存储的，所以对于 IO 密集型的范围查询会比随机从磁盘读取一行数据的I&#x2F;O要少的多</p>
</li>
<li><p>一些存储引擎如 MyISAM <strong>在内存中只缓存索引</strong>，数据则依赖于操作系统来缓存，因此访问数据意味着还需要一次<strong>系统调用</strong>，采用覆盖索引则减少了这样的系统调用</p>
</li>
<li><p>针对 InnoDB 的聚簇索引，覆盖索引可以<strong>避免二级索引根据主键值查找数据行记录</strong><br>覆盖索引必须要存储索引列的值，而hash索引、空间索引、全文索引都不存储索引列的值，所以mysql只能使用b-tree索引做覆盖索引</p>
<blockquote>
<p>当发起一个索引覆盖查询时，通过explain分析语句会看到extra Using index<br>如果查询的列没有被索引覆盖，也就是无法使用索引覆盖查询时，explain查询分析出来extra Using where</p>
</blockquote>
</li>
</ol>
<h4 id="使用索引扫描排序"><a href="#使用索引扫描排序" class="headerlink" title="使用索引扫描排序"></a>使用索引扫描排序</h4><p>Mysql 有两种方式生成有序的结果：通过排序操作，或通过索引顺序扫描。如果 EXPLAIN 出来的 type 列为“Index”，说明使用了索引顺序扫描（不要和 Extra 的“Using Index”弄混）。</p>
<p>索引扫描本身很快，只需要从一条索引记录移动到下一条。但是如果索引本身不能覆盖查询所需的所有列，那每扫描一次索引记录都要回表查询对应行，这基本是随机 IO。因此，按索引顺序读取数据的速度通常要比顺序的全表扫描慢，尤其对于 IO 密集型工作。</p>
<p>能使用索引排序的情况：</p>
<ul>
<li><p>只有当索引列的顺序和 ORDER BY 字句的顺序完全一致，并且所有列的排序方向（正序倒序）都一样时，才能使用索引排序</p>
</li>
<li><p>如果查询关联多张表，则只有当order by子句引用的字段全部为第一个表，才能使用索引做排序</p>
</li>
<li><p>如果索引前导列（where语句或者join子句中包含的索引第一列）设置为常量时，就可以使用索引进行排序</p>
</li>
</ul>
<p><strong>下面列出不能使用索引做排序的查询</strong></p>
<ol>
<li>使用两种不同的排序方向，但是索引列都是正序排列<br>where rental_date&#x3D;2005-05-25’ order by inventory_id desc,customer_id asc;</li>
<li>引用不存在与索引中的列<br>where rental_date&#x3D;2005-05-25’ order by inventory_id,staff_id</li>
<li>where与order by中的列无法组合成索引的最左前缀<br>where rental_date&#x3D;’2005-05-25’ order by customer_id</li>
<li>查询在索引列的第一列为范围查询条件，所以mysql无法使用其他的索引列<br>where rental_date &gt; ‘2005-05-25’ order by inventory_id,customer_id</li>
<li>索引列上存在多个等值条件，对于查询来说其实就相当于范围查询<br>where rental_date &#x3D; ‘2005-05-25’ and inventory_id in(1,2) order by customer_id</li>
</ol>
<h4 id="前缀压缩索引"><a href="#前缀压缩索引" class="headerlink" title="前缀压缩索引"></a>前缀压缩索引</h4><blockquote>
<p>MyISAM 使用<strong>前缀压缩索引</strong>减少索引的大小，从而让更多的索引能放入内存，默认只压缩字符串，但是也可以配置压缩整数</p>
<p>压缩索引块的方法:</p>
<p>先完全保存索引块的第一个值，然后将其他值和第一个值进行比较得到相同的前缀的字节数和不同的后缀，把这部分存储起来即可，比如：索引块中第一个值为perform，第二个值为performance，那么第二个值的前缀压缩后存储的是7,ance这样的形式</p>
<p>代价：</p>
<p>某些操作可能更慢，因为每个值的压缩前缀依赖于前面的值。前缀索引无法通过二分查找只能从头开始扫描，正序的扫描速度还不错，但反序——ORDER BY DESC——就不是很好了。所有在块中查找某一行的平均操作需要扫描半个索引块</p>
</blockquote>
<h4 id="冗余和重复索引"><a href="#冗余和重复索引" class="headerlink" title="冗余和重复索引"></a>冗余和重复索引</h4><ul>
<li><strong>重复索引</strong>，具有相同类型、按照相同顺序的索引，应该避免，发现后立即删除</li>
<li><strong>冗余索引</strong>，(A,B)为索引，再创建索引(A)就是冗余索引，因为A索引只是AB索引的前缀索引，因此索引(AB)也可以当做(A)来算<br>默认情况下在创建innodb二级索引时，主键索引已经默认添加到该索引上了，例如(A, ID)其中id为主键索引<br>冗余索引必须是相同的类型，其他类型的索引，比如hash索引或者全文索引页不会是B-TREE索引的冗余索引</li>
</ul>
<h4 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a>索引和锁</h4><p>索引可以让查询锁定更少的行，这对效率有好处。虽然Innodb行锁的效率很高，内心使用也少，但是锁定行的时候仍然会带来额外的开销；其次，锁定超过需要的行会增加锁的争用减少并发。</p>
<p>InnoDB 只有在访问行的时候才会对其加锁，而索引能够减少 InnoDB 访问的行数，从而减少锁的数量，但这只有在存储引擎层过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在 InnoDB 检索到数据并返回给服务器以后，Mysql 服务器才使用 WHERE 字句，这时候就无法避免锁定行了。5.1版本后，InnoDB 可以在服务器端过滤掉行后就释放锁，但是早期版本只能在事务提交后才释放锁，意味着一些不需要的行一直被锁定！</p>
<h3 id="维护索引和表"><a href="#维护索引和表" class="headerlink" title="维护索引和表"></a><strong>维护索引和表</strong></h3><h5 id="找到并修复索引表"><a href="#找到并修复索引表" class="headerlink" title="找到并修复索引表"></a>找到并修复索引表</h5><blockquote>
<p>通过 check table 来检查是否发生了表损坏，并通过 repair table 来修复表；但是如果存储引擎不支持该命令，也可以通过alter table 重建表来达到修复目的<br><code>alter table innodb_tbl ENGINE=INNODB</code></p>
</blockquote>
<h5 id="更新索引统计信息"><a href="#更新索引统计信息" class="headerlink" title="更新索引统计信息"></a>更新索引统计信息</h5><blockquote>
<p>查询优化器通过两个API来了解存储引擎的索引值分布，通过这两个API的结果来决定使用哪个索引进行查询优化</p>
<ol>
<li>records_in_range();传入两个边界值计算之间的记录数</li>
<li>info();返回各种类型的数据包括索引基数（通过show index from table）</li>
</ol>
<p>如果统计信息不准确，那么定会影响到查询优化器的优化策略，通过analyze table重新生成统计信息</p>
</blockquote>
<h5 id="减少索引和数据的碎片"><a href="#减少索引和数据的碎片" class="headerlink" title="减少索引和数据的碎片"></a>减少索引和数据的碎片</h5><ul>
<li><p><strong>行碎片</strong>：指数据行被存储为多个地方的多个片段中。即使查询只从查询中访问一行记录，行碎片也会导致性能下降</p>
</li>
<li><p><strong>行间碎片</strong>：逻辑上顺序的页&#x2F;行，在磁盘上不是顺序的。行间碎片对全表扫描和聚簇索引扫描之类的操作有很大影响，因为这些操作原本能从磁盘上顺序存储的数据中获益</p>
</li>
<li><p><strong>剩余空间碎片</strong>：数据页中大量的空余空间，导致服务器读取大量不需要的数据，造成浪费</p>
<blockquote>
<p>通过optimize table 或者导出再导入的方式来重新整理数据，对于不支持该命令的存 储引擎，可以通过<code>alter table table_name engine=&lt;engine&gt;</code>来进行优化<br>每种存储引擎实现索引统计信息的方式不同，所以需要进行analyze table的频率也不同：</p>
</blockquote>
</li>
</ul>
<h2 id="四、查询优化"><a href="#四、查询优化" class="headerlink" title="四、查询优化"></a>四、查询优化</h2><p>我们已经了解了库表优化、索引优化，建立了较好的库表结构和索引结构。现在，我们还需要写出较好的 SQL 语句进行查询，也就是查询优化。</p>
<p>查询真正重要的是响应时间，查询的生命周期分为：【从客户端连接到服务器】，【在服务器上进行解析】，【生成执行计划】，【执行】，【将结果返回给客户端】，优化查询的目的就是为了减少和消除这些操作所花费的时间。</p>
<h3 id="讲一下SQL优化方法-（联表查询不了解）"><a href="#讲一下SQL优化方法-（联表查询不了解）" class="headerlink" title="&#x3D;&#x3D;讲一下SQL优化方法&#x3D;&#x3D;（联表查询不了解）"></a>&#x3D;&#x3D;讲一下SQL优化方法&#x3D;&#x3D;（联表查询不了解）</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/409390845">字节面试官：一条sql执行慢的原因？如何优化？</a></p>
<ul>
<li>通过 <strong>explain</strong> 执行结果，查看 sql 是否走索引，如果不走索引，考虑增加索引。</li>
<li>可以通过建立 联合索引，实现 <strong>覆盖索引</strong> 优化，减少回表</li>
<li>联合索引符合<strong>最左匹配原则</strong>，不然会索引失效</li>
<li>避免索引失效，比如不要用左模糊匹配、函数计算、表达式计算等等。</li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7143784859775795207">联表查询</a> 最好 小表驱动大表，并且被驱动表的字段要有索引，当然最好通过<a target="_blank" rel="noopener" href="https://www.cnblogs.com/lyn8100/p/15527559.html">冗余字段</a>的设计，避免联表查询。</li>
<li>针对 limit n,y 深分页的查询优化，可以把Limit查询转换成某个位置的查询：<code>select * from tb_sku where id&gt;20000 limit 10;</code>，该方案适用于主键自增的表，</li>
<li><strong>垂直分表</strong>，将字段多的表分解成多个表，有些字段使用频率高，有些低，数据量大时，会由于使用频率低的存在而变慢，可以考虑分开</li>
</ul>
<h3 id="1-优化数据访问"><a href="#1-优化数据访问" class="headerlink" title="1. 优化数据访问"></a>1. 优化数据访问</h3><p><strong>查询性能低下最基本的原因是访问的数据太多</strong>，也就是做了无用功。可以通过下面两种方式来分析：</p>
<ul>
<li><p>确认<strong>应用程序</strong>是否在检索大量超过需要的数据，这通常意味着访问了太多的行，但有时候也可能是访问了太多的列</p>
</li>
<li><p><strong>mysql服务器层</strong>是否在分析大量超过需要的数据行</p>
</li>
</ul>
<h4 id="1-1-是否向数据库请求了不需要的数据"><a href="#1-1-是否向数据库请求了不需要的数据" class="headerlink" title="1.1 是否向数据库请求了不需要的数据"></a>1.1 是否向数据库请求了不需要的数据</h4><p>有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给 <em>MySQL 服务器</em> 带来额外的负担，并增加<em>网络开销</em>，另外也会消耗 <em>应用服务器</em> 的 CPU 和内存资源。</p>
<p>以下是一些常见案例：</p>
<p><strong>查询不需要的记录</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一个常见的错误是常常会误以为 MySQL 会只返回需要的数据，实际上 MySQL 却是先返回全部结果集再进行计算。</span><br><span class="line"></span><br><span class="line">比如，先使用 <span class="keyword">SELECT</span> 语句查询大量的结果，然后获取前面的 N 行后关闭结果集 (例如在新闻网站中取出 <span class="number">100</span> 条记录但是只是在页面上显示前面 <span class="number">10</span> 条)。他们认为 MySQL 会执行查询，并只返回他们需要的 <span class="number">10</span> 条数据，然后停止查询。实际情况是 MySQL 会查询出全部的结果集，客户端的应用程序会接收全部的结果集数据，然后抛弃其中大部分数据。最简单有效的解决方法就是在这样的查询后面加上 LIMIT</span><br><span class="line"></span><br><span class="line">换句话说，就是把 在应用程序 上进行记录筛选，改成在 Mysql服务器 上进行筛选</span><br></pre></td></tr></table></figure>

<p><strong>多表关联时返回全部列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果你想查询所有在电影 Academy Dinosaur 中出现的演员，千万不要按下面的写法编写查询:</span><br><span class="line">	mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> actor</span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> film_actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">INNER</span> <span class="keyword">JOIN</span> film <span class="keyword">USING</span>(film id)</span><br><span class="line">		<span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">WHERE</span> film.title <span class="operator">=</span><span class="string">&#x27;Academy Dinosaur&#x27;</span>;</span><br><span class="line">这将返回这三个表的全部数据列。正确的方式应该是像下面这样只取需要的列:</span><br><span class="line">	mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> actor.<span class="operator">*</span> <span class="keyword">FROM</span> actor...;</span><br></pre></td></tr></table></figure>

<p><strong>总是取出全部的列</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每看到 <span class="keyword">SELECT</span> <span class="operator">*</span> 的时候都需要怀疑，是不是真的需要返回全部的列?很可能不是必需的。取出全部列，会让优化器无法完成索引覆盖扫描这类优化,还会为服务器带来额外的I<span class="operator">/</span><span class="number">0</span>、内存和CPU的消耗。因此，一些 DBA 是严格禁止 <span class="keyword">SELECT</span> <span class="operator">*</span> 的写法的，这样做有时候还能避免某些列被修改带来的问题。</span><br><span class="line">当然，查询返回超过需要的数据也不总是坏事。在我们研究过的许多案例中，人们会告诉我们说这种有点浪费数据库资源的方式可以简化开发，因为能提高相同代码片段的复用性，如果清楚这样做的性能影响，那么这种做法也是值得考虑的。</span><br><span class="line">如果应用程序使用了某种缓存机制，或者有其他考虑，获取超过需要的数据也可能有其好处，但不要忘记这样做的代价是什么。获取并缓存所有的列的查询，相比多个独立的只获取部分列的查询可能就更有好处</span><br></pre></td></tr></table></figure>

<p><strong>重复查询相同的数据</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果你不太小心，很容易出现这样的错误一一不断地重复执行相同的查询，然后每次都返回完全相同的数据。例如，在用户评论的地方需要查询用户头像的 URL，那么用户多次评论的时候，可能就会反复查询这个数据。比较好的方案是，当初次查询的时候将这个数据缓存起来，需要的时候从缓存中取出，这样性能显然会更好</span><br></pre></td></tr></table></figure>

<h4 id="1-2-MySQL-是否在扫描额外的记录"><a href="#1-2-MySQL-是否在扫描额外的记录" class="headerlink" title="1.2 MySQL 是否在扫描额外的记录"></a>1.2 MySQL 是否在扫描额外的记录</h4><p>在确定查询只返回需要的数据以后，接下来应该看看查询为了返回结果是否扫描了过多的数据。对于 MySQL，最简单的量查询开销的三个指标如下</p>
<ul>
<li><p>响应时间</p>
</li>
<li><p>扫描的行数</p>
</li>
<li><p>返回的行数</p>
</li>
</ul>
<p>没有哪个指标能够完美地衡量查询的开销，但它们大致反映了 MySQL 在内部执行查询时需要访问多少数据，并可以大概推算出查询运行的时间。这三个指标都会记录到 MySQL 的慢日志中，所以<strong>检查慢日志记录是找出扫描行数过多的查询的好办法</strong>。</p>
<p><strong>响应时间</strong></p>
<p>要记住，响应时间只是一个表面上的值。这样说可能看起来和前面关于响应时间的说法有矛盾？其实不矛盾，响应时间仍然是最重要的指标，这有一点复杂，后面细细道来。</p>
<p><em><strong>响应时间是两个部分之和：服务时间 + 排队时间。</strong></em>服务时间是指数据库处理这个查询真正花了多长时间。排队时间是指服务器因为等待某些资源而没有真正执行查询的时间——可能是等 I&#x2F;O 操作完成，也可能是等待行锁。 </p>
<p>所以在不同类型的应用压力下，响应时间并没有什么一致的规律或者公式。诸如存储引擎的锁(表锁、行锁)、高并发资源竞争、硬件响应等诸多因素都会影响响应时间。所以响应时间既可能是一个问题的结果也可能是一个问题的原因。</p>
<p><strong>扫描的行数和返回的行数</strong></p>
<p>分析查询时，查看该查询扫描的行数是非常有帮助的。这在一定程度上能够说明该查询找到需要的数据的效率高不高。</p>
<p>对于找出那些“糟糕”的查询，这个指标可能还不够完美，因为并不是所有的行的访问代价都是相同的。较短的行的访问速度更快，内存中的行也比磁盘中的行的访问速度要快得多。</p>
<p>理想情况下扫描的行数和返回的行数应该是相同的。但实际情况中这种“美事”并不多。例如在做一个关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在 1:1 和 10:1之间，不过有时候这个值也可能非常非常大。</p>
<p><strong>扫描的行数和访问类型</strong></p>
<p>在评估查询开销的时候，需要考虑一下从表中找到某一行数据的成本。MySOL 有好几种访问方式可以查找并返回一行结果。有些访问方式可能需要扫描很多行才能返回一行结果，也有些访问方式可能无须扫描就能返回结果。</p>
<p>在 EXPLAIN 语句中的 type 列反应了访问类型。访问类型有很多种，从全表扫描到索引扫描、范围扫描、唯一索引查询、常数引用等。这里列的这些，速度是从慢到快，扫描的行数也是从小到大。你不需要记住这些访问类型，但需要明白<strong>扫描表</strong>、<strong>扫描索引</strong>、<strong>范围访问</strong>和<strong>单值访问</strong>的概念。</p>
<p>如果查询没有办法找到合适的访问类型，那么解决的最好办法通常就是增加一个合适的索引，这也正是我们前一章讨论过的问题。现在应该明白为什么索引对于查询优化如此重要了。索引让 MySQL 以最高效、扫描行数最少的方式找到需要的记录。</p>
<p>例如，我们看看示例数据库 sakila 中的一个查询案例 ：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sakila.film_actor <span class="keyword">WHERE</span> file_id <span class="operator">=</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<img src="/2022/12/24/MySQL/image-20240405083048860.png" alt="image-20240405083048860" style="zoom:67%;"> 

<p>MySQL 在索引 idx_fk_film_id 上使用 ref 访问类型执行查询，并且预估要查询 10 条数据。换句话说，优化器认为这种访问类型可以高效的完成查询。</p>
<p>如果没有索引，会使用更糟糕的访问类型。下面我们删除索引再查询一次。</p>
<img src="/2022/12/24/MySQL/image-20240405083621225.png" alt="image-20240405083621225" style="zoom:67%;"> 

<p>正如我们预测的，访问类型变成了一个全表扫描 (ALL)，现在MySQL预估需要扫描5073条记录来完成这个查询。这里的“Using Where”表示 MySQL 将通过 WHERE 条件来筛选存储引擎返回的记录.</p>
<p>一般 MySQL 能够使用如下三种方式应用 WHERE 条件，从好到坏依次为：（？？？）</p>
<ul>
<li><p>在 <em><strong>索引</strong></em> 中使用 WHERE 条件来过滤不匹配的记录。这是在 <em><strong>存储引擎</strong></em> 层完成的。</p>
</li>
<li><p>使用索引覆盖扫描（在 Extra 列中出现了 Using index)来返回记录，直接从索引中过滤不需要的记录并返回命中的结果。这是在 MySQL 服务器层完成的，但无须再回表查询记录。</p>
</li>
<li><p>从数据表中返回数据，然后过滤不满足条件的记录(在 Extra 列中出现 Using Where)。这在 MySQL 服务器层完成，MySQL 需要先从数据表读出记录然后过滤</p>
</li>
</ul>
<p>上面这个例子说明了好的索引多么重要。好的索引可以让查询使用合适的访问类型，尽可能地只扫描需要的数据行。但也不是说增加索引就能让扫描的行数等于返回的行数。例如下面使用聚合函数 COUNT() 的查询</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> actor_id,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> sakila.film actor <span class="keyword">GROUP</span> <span class="keyword">BY</span> actor_id;</span><br></pre></td></tr></table></figure>

<p>这个查询需要读取几千行数据，但是仅返回 200 行结果。没有什么索引能够让这样的查询减少需要扫描的行数。</p>
<p>如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的技巧去优化它：</p>
<ul>
<li><p>使用索引覆盖扫描，把所有需要用的列都放到索引中，这样存储引擎无须回表获取对应行就可以返回结果了。</p>
</li>
<li><p>改变库表结构。例如使用单独的汇总表</p>
</li>
<li><p>重写这个复杂的查询，让 MySQL 优化器能够以更优化的方式执行这个查询（这是本章后续需要讨论的问题）。</p>
</li>
</ul>
<h3 id="2-重构查询的方式"><a href="#2-重构查询的方式" class="headerlink" title="2. 重构查询的方式"></a>2. 重构查询的方式</h3><p>通过上面优化数据访问，我们确定了所访问的数据就是所需要的数据。现在，如果还是出现慢 sql ，那可能时查询的方式有问题。访问相同的数据，得到相同的结果，我们可以尝试换一种写法性能更好，也就是重构查询方式。</p>
<h4 id="2-1-一个复杂查询还是多个简单查询"><a href="#2-1-一个复杂查询还是多个简单查询" class="headerlink" title="2.1 一个复杂查询还是多个简单查询"></a>2.1 一个复杂查询还是多个简单查询</h4><p>设计查询的时候一个需要考虑的重要问题是，是否需要**<em>将 一个复杂的查询 分成 多个简单的查询</em> **。在传统实现中，总是强调需要数据库层完成尽可能多的工作，这样做的逻辑在于以前总是认为网络通信、查询解析和优化是一件代价很高的事情。</p>
<p>但是这样的想法对于 MySQL 并不适用。【<strong>从连接的角度</strong>】MySQL 从设计上让连接和断开连接都很轻量级，在返回一个小的查询结果方面很高效。现代的网络速度比以前要快很多，无论是带宽还是延迟。【<strong>从查询解析和优化的角度</strong>】在某些版本的 MySOL 上，即使在一个通用服务器上，也能够运行每秒超过 10万的查询，即使是一个千兆网卡也能轻松满足每秒超过 2000 次的查询。所以运行多个小查询现在已经不是大问题了。</p>
<p>MySQL内部每秒能够扫描内存中上百万行数据，相比之下，MySOL 响应数据给客户端就慢得多了。<strong>在其他条件都相同的时候,使用尽可能少的查询当然是更好的。但是有时候，将一个大查询分解为多个小查询是很有必要的。</strong>别害怕这样做，好好衡量一下这样做是不是会减少工作量。稍后我们将通过本章的一个示例来展示这个技巧的优势。</p>
<p>不过，在应用设计的时候，<strong>如果一个查询能够胜任时还写成多个独立查询是不明智的</strong>。例如，我们看到有些应用对一个数据表做 10 次独立的查询来返回 10 行数据，每个查询返回一条结果，查询 10 次！</p>
<h4 id="2-2-切分查询"><a href="#2-2-切分查询" class="headerlink" title="2.2 切分查询"></a>2.2 切分查询</h4><p>有时候对于一个大查询我们需要“分而治之”，将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。</p>
<p><strong>删除旧的数据</strong>就是一个很好的例子。定期地清除大量数据时，如果用一个大的语句一次性完成的话，则可能需要一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p>
<p>将一个大的 DELETE 语句切分成多个较小的查询可以尽可能小地影响 MySQL 性能，同时还可以减少 MySQL 复制的延迟。例如，我们需要每个月运行一次下面的查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> messages <span class="keyword">WHERE</span> created <span class="operator">&lt;</span> DATE_SUB(NOH(),<span class="type">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">row_affacted = <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">    rows_affacted = do_quary(</span><br><span class="line">    	<span class="string">&quot;DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">while</span> rows_affacted &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>一次删除一万行数据一般来说是一个比较高效而且对服务器影响也最小的做法。同时，需要注意的是，如果每次删除数据后，都暂停一会儿再做下一次删除，这样也可以将服务器上原本一次性的压力分散到一个很长的时间段中，就可以大大降低对服务器的影响，还可以大大减少删除时锁的持有时间</p>
<h4 id="2-3-分解关联查询"><a href="#2-3-分解关联查询" class="headerlink" title="2.3 分解关联查询"></a>2.3 分解关联查询</h4><p>很多高性能应用都会对关联查询进行分解，也就是<strong>对单表进行查询，然后在应用程序中进行关联</strong>。比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> tag </span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id <span class="operator">=</span> tag.id </span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id <span class="operator">=</span> post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag <span class="operator">=</span> <span class="string">&#x27;mysql&#x27;</span>;</span><br><span class="line">#分解</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag<span class="operator">=</span>&quot;mysq1&#x27;;</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id=1234;</span><br><span class="line">SELECT * FROM post WHERE post.id in (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure>

<p>到底为什么要这样做？乍一看，这样做并没有什么好处，原本一条查询，这里却变成多条查询，返回的结果又是一模一样的。事实上，用<em>分解关联查询</em> 的方式重构查询有如下优点：</p>
<ul>
<li><p><strong>让缓存效率更高</strong></p>
<p>许多应用程序可以方便地缓存单表查询对应的结果对象。例如，上面查询中的tag已经被缓存了，那么应用就可以跳过第一个查询。再例如，应用中已经缓存了ID为123、567、9098的内容,那么第三个查询的IN()中就可以少几个 ID。另外，对MySQL的查询缓存来说<br>如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少改变，那么基于该表的查询就可以重复利用查询缓存结果了。</p>
</li>
<li><p><strong>执行单个查询可以减少锁的竞争</strong></p>
</li>
<li><p>在应用层做关联，可以更容易对数据库进行拆分</p>
</li>
<li><p>可以减少冗余记录的查询，在应用层进行关联查询时，往往对于某条记录应用只需要查询一次，但是在数据库层做关联可能需要重复地访问一部分数据</p>
</li>
</ul>
<h3 id="3-查询执行的基础"><a href="#3-查询执行的基础" class="headerlink" title="3. 查询执行的基础"></a>3. 查询执行的基础</h3><p>当希望 MySQL 能够以更高的性能运行查询时，最好的办法就是弄清楚 MySQL 是如何优化和执行查询的。一旦理解这一点，很多查询优化工作实际上就是遵循一些原则让优化器能够按照预想的合理的方式运行。</p>
<p>换句话说，是时候回头看看我们前面讨论的内容了：MySQL 执行一个查询的过程。我们可以看一下，当向 MySQL 发送一个请求的时候，MySQL 到底做了些什么:</p>
<img src="/2022/12/24/MySQL/image-20240405194243037.png" alt="image-20240405194243037" style="zoom:67%;">  

<p><em><strong>SQL 查询过程:</strong></em></p>
<ol>
<li><strong>客户端发送查询请求给服务器</strong></li>
<li><strong>服务器先检查查询缓存是否命中，命中则立刻返回给客户端，否则进入下一阶段</strong></li>
<li><strong>服务器端进行 SQL 解析，预处理，再由优化器生成查询执行计划</strong></li>
<li><strong>MySQl 根据优化器生成的查询执行计划，调用存储引擎API来执行查询</strong></li>
<li><strong>将结果返回给客户端，同时将结果保存到服务器缓存中</strong></li>
</ol>
<h4 id="3-1-MySQL-客户端-服务器通信协议"><a href="#3-1-MySQL-客户端-服务器通信协议" class="headerlink" title="3.1 MySQL 客户端&#x2F;服务器通信协议"></a>3.1 MySQL 客户端&#x2F;服务器通信协议</h4><p>MySQL 客户端和服务器之间的通信协议是<strong>“半双工”</strong>的，这意味着,在任何一个时刻，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作不能同时发生。</p>
<p>这种协议让 MySQL 通信简单快速，但是也从很多地方限制了 MySQL。一个明显的限制是，这意味着<strong>没法进行流量控制</strong>（个人理解是因为流量控制需要有 ACK 的反馈，不符合半双工）。一旦一端开始发生消息，另一端要接收完整个消息才能响应它。这就像来回抛球的游戏：在任何时刻，只有一个人能控制球，而且只有控制球的人才能将球抛回去 (发送消息)。</p>
<p>客户端用一个单独的数据包将查询传给服务器。这也是为什么当查询的语句很长的时候参数 <code>max_allowed_packet</code> 就特别重要了。一旦客户端发送了请求，它能做的事情就只是等待结果了。</p>
<p>相反的，一般服务器响应给用户的数据通常很多，由多个数据包组成。当服务器开始响应客户端请求时，客户端必须完整地接收整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据（因为半双工模式下，服务器发消息时，客户端没法告诉它：“你别发了”）。这种情况下，客户端若接收完整的结果，然后取前面几条需要的结果，或者接收完几条结果后就“粗暴”地断开连接，都不是好主意。这也是在必要的时候一定要在查询中加上 LIMIT 限制的原因（LIMIT 直接在服务器层面上把多余的数据行过滤了）。</p>
<p>换一种方式解释这种行为：当客户端从服务器取数据时，看起来是一个拉数据的过程，但实际上是 MySQL在向客户端推送数据的过程。客户端不断地接收从服务器推送的数据，客户端也没法让服务器停下来。客户端像是“从消防水管喝水”(这是一个术语)。</p>
<p>多数连接 MySQL 的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。默认一般是获得全部结果集并缓存到内存中。MySQL 通常需要等所有的数据都已经发送给客户端才能释放这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束、早点释放相应的资源。<br>当使用多数连接MySQL的库函数从MySQL获取数据时，其结果看起来都像是从MySQL 服务器获取数据，而实际上都是从这个库函数的缓存获取数据。多数情况下这没什么问题，但是如果需要返回一个很大的结果集的时候，这样做并不好，因为库函数会花很多时间和内存来存储所有的结果集。如果能够尽早开始处理这些结果集，就能大大减少内存的消耗，这种情况下可以不使用缓存来记录结果而是直接处理。这样做的缺点是，对于服务器来说，需要查询完成后才能释放资源，所以在和客户端交互的整个过程中，服务器的资源都是被这个查询所占用的注8</p>
<p>mysql客户端与服务器之间的通信协议是半双工的，在任何一个时刻，只能由客户端或者服务器发送数据给彼此，而两者不能同时发生<br> 当客户端发送sql查询语句给服务器后，它剩下的工作就只有等待了<br> 一般服务器响应给用户的数据特别多，由多个数据包组成，当服务器开始响应客户端请求时，客户端必须完整的接受完整个返回结果后才能给予响应，以致于客户端可能会接收到不需要的数据并丢弃，为了解决这种情况，可以采用limit限制返回的行数</p>
<h4 id="库函数缓存"><a href="#库函数缓存" class="headerlink" title="库函数缓存"></a>库函数缓存</h4><p>当使用多数连接mysql的库函数对mysql获取数据时，其结果看起来都像是从mysql服务器获取数据，但实际上是从这个库函数的缓存中获取数据，当库函数查询的结果记录小还没什么，但是如果是很大的结果集，那么效率就会有影响<br>这种情况下，可以设置不使用缓存来记录结果，而是直接处理</p>
<h3 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h3><p>在解析一个查询语句之前，如果查询缓存是打开的，那么mysql会优先检查这个查询是否查询命中缓存中的数据，它通过一个大小写敏感的hash查找实现，如果命中了查询缓存，这时还需要检查用户的权限，这些权限也一并保存在缓存中的，所以不需要查表，如果权限通过，那么直接就从缓存中取数据</p>
<h3 id="查询优化处理"><a href="#查询优化处理" class="headerlink" title="查询优化处理"></a>查询优化处理</h3><p>查询的生命周期经过缓存后，下一步就是需要将sql语句转化成一个执行计划，mysql再按照这个执行计划和存储引擎进行交互，这个过程包含多个子阶段：<br> 解析sql，预处理，优化sql执行计划<br> mysql通过语法解析器解析sql，通过关键字将sql语句进行解析，并生成一颗解析树，并使用mysql语法规则验证和解析查询，这里可以说是对sql语句字面上进行验证<br> 预处理阶段，则根据mysql规则进一步检查解析树是否合法，这里将会更深层次对sql做验证，比如验证表名，字段名是否合法等<br> 现在语法树被认为是合法的了，并且由优化器将其转化成了执行计划，一条sql有很多条执行计划，mysql优化器使用基于成本的优化器，将从这多条执行计划中选择成本最低的一条</p>
<blockquote>
<p>执行一次where条件比较的成本，可以通过last_query_cost变量值来查看当前查询成本<br><code>show status like ‘last_query_cost’</code></p>
</blockquote>
<p>很多种情况都会导致mysql优化器选择错误的执行计划： </p>
<ol>
<li>统计信息不准确</li>
<li>执行计划中的成本估算不等同于实际执行的成本，即使统计信息精准，优化器给出的执行计划也不一定是最优的，比如某个执行计划虽然要读取更多的页面，但是它的成本更小，因为这些页面都是顺序读取或者这些页面都在内存中，那么它的访问成本将更小</li>
<li>mysql优化器的最优可能跟你想的最优不一样，你可能需要的是执行时间尽可能短，但mysql基于成本模型选择最优，所以有些时候不一定执行的时间是最短的</li>
<li>mysql从不考虑并发执行的查询，这可能会影响到当前执行的查询</li>
<li>mysql也不是在任何时候都是基于成本的优化，也会基于一些固定规则，比如存在全文搜索的match子句，则在全文索引的时候使用全文索引</li>
<li>mysql并不考虑不受其控制的操作的成本，例如执行存储过程或用户自定义函数</li>
<li>优化器有时候无法估算所有可能的执行计划，所以它可能错过实际上最优的执行计划</li>
</ol>
<p>mysql的查询优化分两种：</p>
<ul>
<li><strong>静态优化</strong>，在编译时就完成，只优化一次，比如where查询条件中的常量值，将where条件通过简单的代数运算转化为另一种等价的方式</li>
<li><strong>动态优化</strong>，又称为编译时优化，跟查询的上下文有关，比如where条件中的取值，索引条目，对应的数据行数等</li>
</ul>
<p>​    </p>
<p><strong>mysql能够处理的优化类型：</strong></p>
<ol>
<li><p>重新定义关联表顺序</p>
</li>
<li><p>将外连接转化为内连接<br>使用等价变换原则，(5&#x3D;5 and a&gt;5) &#x3D;&#x3D;&gt; a&gt;5, (a&lt;b and b&#x3D;c) and a&#x3D;5 &#x3D;&#x3D;&gt; b&gt;5 a&lt;b b&#x3D;c。优化count(),min(),max()<br>min()取b-tree最左端的记录<br>max()取b-tree最右端的记录</p>
</li>
<li><p>预估并转化为常数<br>当mysql检测到一个表达式可以转化为常数的时候，就会一直把该表达式当做常数进行优化处理，例如用户自定义的变量，在查询中没有发生变化时就可以转化为一个常数，或者在索引列上执行min(),甚至在主键或者唯一索引查找语句也可以转化为常数表达式</p>
</li>
<li><p>索引覆盖扫描</p>
</li>
<li><p>子查询优化</p>
</li>
<li><p>提前终止查询，not exist<br>提前终止查询有两种情况可以达到，一种使用Limit，还有一种是发现了不成立的条件</p>
</li>
<li><p>等值传播<br>如果两个列的值通过等值关联，那么mysql能够把其中一个列的where条件传递到另一个列上</p>
</li>
</ol>
<h3 id="数据与索引的统计信息"><a href="#数据与索引的统计信息" class="headerlink" title="数据与索引的统计信息"></a>数据与索引的统计信息</h3><p>mysql架构有多个层次组成，在服务器层有查询优化器，却没有保存数据和索引的统计信息，统计信息由存储引擎实现，所以查询优化器在优化查询时，需要向存储引擎获取相应的统计信息，包括每个表或者索引有多少页面，每个表的每个索引基数是多少，数据行和索引长度、索引的分布等</p>
<h3 id="mysql中的关联查询"><a href="#mysql中的关联查询" class="headerlink" title="mysql中的关联查询"></a>mysql中的关联查询</h3><p>mysql中的关联一词包含的意义比一般意义上理解的更要广泛，总的来说，mysql认为每一次查询都是一次关联，并不局限于一个查询需要用到大于两个表才叫关联<br> 对于union查询，mysql先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成union查询，在mysql的概念中，每个查询都是一次关联，所以读取临时表也是一次关联<br> mysql关联执行的策略是对任何关联都执行嵌套循环关联操作：先从一个表中查出一条记录，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止，然后根据各个表匹配的行，返回查询中需要的列，mysql会尝试在最后一个表中找到所有匹配的行，如果最后一个表无法找到，就返回上一层关联表继续查找</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6008583-ffd63d4195e8f234.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/308/format/webp" alt="img"></p>
<h3 id="关联查询优化器"><a href="#关联查询优化器" class="headerlink" title="关联查询优化器"></a>关联查询优化器</h3><p>mysql优化器最重要的一部分就是关联查询优化，它决定了多个表关联时的顺序，mysql会根据扫描的行数选择合理的关联顺序，目的是为了让查询进行更少的嵌套循环和回溯操作，当然如果优化器给定的关联顺序并不是最优的，那么可以通过添加STRAIGHT_JOIN关键字重写查询，让优化器按照给定的表顺序进行关联，但是如果关联表多了，比如超过了N个表进行关联，那么需要检查n的阶乘中关联顺序，当搜索空间非常大的时候，优化器不可能给逐一评估每一种关联顺序，优化器选择使用贪婪搜索的方式查找最优</p>
<h3 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h3><p>无论如何排序都是一个成本很高的操作，所以从性能角度考虑，应尽可能避免排序或者尽可能避免对大数据量数据进行排序，如果排序数据量小，则可以在内存中排序，如果数据量大，则需要使用磁盘，不过这个过程mysql统一称为文件排序<br> 如果排序的数据量小于排序缓冲区，mysql使用内存进行快速排序操作，如果数据量大于排序缓冲区，那么mysql会先将数据切块，对独立的块进行排序并将排序结果存放在磁盘，然后将各个排好序的块进行合并，最后返回排序结果<br> mysql排序有两种方式：</p>
<ol>
<li>读取行指针与排序列，根据排序列排好序后再通过行指针查询最后的结果，这需要两次数据传输（旧版本使用）</li>
<li>先读取查询所需要的所有列，然后根据排序列进行排序，最后直接返回结果（新版本使用）<br>对于order by操作，如果排序列全在第一个表，那么在关联第一个表的时候就已经进行文件排序，除此之外的所有情况，mysql会先将关联的结果存放到一个临时表中，然后再进行文件排序</li>
</ol>
<h3 id="返回结果给客户端"><a href="#返回结果给客户端" class="headerlink" title="返回结果给客户端"></a>返回结果给客户端</h3><p>查询执行的最后一个阶段是将查询结果返回给客户端，mysql将查询结果返回给客户端是一个增量、逐步返回的过程，一旦服务器处理完最后一个关联表，开始生成第一条记录时，mysql就可以开始向客户端逐步返回结果集了<br> 这样做的好处在于：</p>
<ol>
<li>服务器无需存储大量的结果，也就不会因此消耗太多内存</li>
<li>这样的处理也让mysql客户端第一时间获得返回的结果数据</li>
</ol>
<h3 id="mysql查询优化器的局限性"><a href="#mysql查询优化器的局限性" class="headerlink" title="mysql查询优化器的局限性"></a>mysql查询优化器的局限性</h3><h4 id="关联子查询"><a href="#关联子查询" class="headerlink" title="关联子查询"></a>关联子查询</h4><p>mysql的子查询实现的非常糟糕，最糟糕的一类查询就是where条件中包含in()的子查询<br> 对于关联子查询，通过explain进行分析时，select_type为dependent subquery<br> 可以用两种方法来解决关联子查询的问题：</p>
<ol>
<li>将关联子查询转化为内连接</li>
<li>通过group_concat将需要的列用,拼接而不是直接使用查询<br>我们在查询时，一旦使用了distinct或者groupby，那么在查询的执行过程中，通常需要产生临时中间表</li>
</ol>
<h3 id="特定类型查询优化"><a href="#特定类型查询优化" class="headerlink" title="特定类型查询优化"></a>特定类型查询优化</h3><h4 id="优化-COUNT-查询"><a href="#优化-COUNT-查询" class="headerlink" title="优化 COUNT()查询"></a>优化 COUNT()查询</h4><p>COUNT() 聚合函数的作用：</p>
<ul>
<li><strong>统计某个列值的数量</strong>，要求列值非空（不统计NULL），如果在COUNT() 的括号中指定了列或者列的表达式，则统计的就是这个表达式有效的结果数</li>
<li><strong>统计结果集的行数</strong>。当括号内表达式不可能非空时，实际上就是在统计行数。例如，使用COUNT(*) 的时候，通配符 * 不会展开成所有的列，实际上它会直接忽略列而直接统计行数</li>
<li><strong>最常见的错误</strong>：括号内指定了一个列却希望统计结果集的行数。如果想知道行数，最好使用COUNT(*) ，这样意义清晰，性能也会很好</li>
</ul>
<blockquote>
<p>count(table.*) 的使用是错误的</p>
</blockquote>
<p>MyISAM 的神话</p>
<p>一个误解是：MyISAM 的 COUNT() 总是非常快，不过这是有前提条件的，即**没有任何 WHERE 条件的 COUNT( <em>) 才非常快**，因为无需时间计算表的行数，可以直接利用存储引擎获得这个值。如果 Mysql 知道某列 col 不可能为 NULL ，那么 COUNT(col) 将被优化为 COUNT(</em>) 。</p>
<p>简单的优化</p>
<p>有时候可以使用 MyISAM 在 COUNT(*) 全表非常快的特征，来加速一些特定的 COUNT() 查询。</p>
<p><img src="/2022/12/24/MySQL/image-20231022154716839.png" alt="image-20231022154716839"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 统计color字段有多少种颜色，即统计某个字段不同值的个数</span><br><span class="line">SELECT <span class="title function_">COUNT</span><span class="params">(color = <span class="string">&#x27;red&#x27;</span> OR NULL)</span> AS <span class="string">&#x27;red&#x27;</span>, COUNT(color = <span class="string">&#x27;blue&#x27;</span> OR NULL) AS <span class="string">&#x27;blue&#x27;</span> FROM items;</span><br><span class="line"></span><br><span class="line">SELECT <span class="title function_">SUM</span><span class="params">(IF(color = <span class="string">&#x27;red&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)</span>) AS <span class="string">&#x27;red&#x27;</span>, SUM(IF(color = <span class="string">&#x27;blue&#x27;</span>, <span class="number">1</span>, <span class="number">0</span>)) AS <span class="string">&#x27;blue&#x27;</span> FROM items;</span><br></pre></td></tr></table></figure>

<p>使用近似值</p>
<p>某些业务场景不要求使用完全精确的 COUNT 值，可以使用近似值代替。EXPLAIN 出来的优化器估算的行数就是不错的近似值，因为不会真正执行查询，所以成本很低。</p>
<p>例如，统计网站的当前活跃数是多少，这个活跃数保存在缓存中，过期时间是30分钟，它就是近似值。如果精确统计在线人数，WHERE 条件很复杂，不仅要剔除非活跃用户，还要剔除一些默认ID的用户，去掉这些约束条件对总量的影响很小，但能而极大的提高性能。进一步的优化可以尝试删除 DISTINCT 这样的约束避免文件排序。</p>
<h4 id="优化关联查询"><a href="#优化关联查询" class="headerlink" title="优化关联查询"></a>优化关联查询</h4><ul>
<li><strong>确保 on 或者 using 子句中的列上有索引</strong>。在创建索引的时候需要考虑到关联的顺序，比如 A , B 表用 col 列进行关联，关联顺序为 B、A，,那么就不需要再B表上建立索引，一般来说<strong>只需要在关联顺序的第二个表的相应列上创建索引</strong>。</li>
<li><strong>确保 GROUP BY 和 ORDER BY 上的表达式只涉及一列</strong>，这样才能使用索引</li>
</ul>
<h4 id="优化子查询"><a href="#优化子查询" class="headerlink" title="优化子查询"></a>优化子查询</h4><p>尽量使用关联查询代替子查询，但是，mysql5.6之后就可以忽略这个建议了</p>
<h4 id="优化union的限制"><a href="#优化union的限制" class="headerlink" title="优化union的限制"></a>优化union的限制</h4><p>如果希望各个子句先排好序在合并结果集，就需要分别在各个子句中排序并使用limit<br> 例如，将两个子查询结合起来，并取前20条记录</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">select</span> first_name,last_name <span class="keyword">from</span> actor order <span class="keyword">by</span> last_name limit <span class="number">20</span>)</span><br><span class="line"><span class="function">union <span class="title">all</span> </span></span><br><span class="line"><span class="function">(<span class="params"><span class="keyword">select</span> first_name, last_name <span class="keyword">from</span> customer order <span class="keyword">by</span> last_name limit <span class="number">20</span></span>)</span></span><br><span class="line"><span class="function">order <span class="keyword">by</span> last_name</span></span><br><span class="line"><span class="function">limit 20</span>;</span><br></pre></td></tr></table></figure>

<p>这样中间表中就只有40条数据,需要注意的是通过两个查询合并的记录顺序并不是一定的，需要对全局进行order by 和limit操作<br> mysql对union[all]查询总是以创建并填充临时表的方式来执行union查询,没有特别说明要去重，就一定要加上all，因为union会给临时表加上distinct，这回导致整个数据临时表的唯一性检查</p>
<h4 id="在同一个表查询与更新"><a href="#在同一个表查询与更新" class="headerlink" title="在同一个表查询与更新"></a>在同一个表查询与更新</h4><p>mysql不允许对同一张表同时进行查询和更新操作，可以通过多表关联更新来解决</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">update tbl inner <span class="title">join</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">select</span> type, count(*</span>) <span class="keyword">as</span> cnt <span class="keyword">from</span> tbl <span class="keyword">group</span> <span class="keyword">by</span> type</span></span><br><span class="line"><span class="function">) <span class="keyword">as</span> der <span class="title">using</span>(<span class="params">type</span>) </span></span><br><span class="line"><span class="function"><span class="keyword">set</span> tbl.cnt</span> = der.cnt</span><br></pre></td></tr></table></figure>

<h4 id="优化-GROUP-BY-和-DISTINCT"><a href="#优化-GROUP-BY-和-DISTINCT" class="headerlink" title="优化 GROUP BY 和 DISTINCT"></a>优化 GROUP BY 和 DISTINCT</h4><p>很多场景下，Mysql 都使用相同的方法优化这两种查询，事实上，Mysql 优化器在内部处理时相互转化这两种查询。他们都使用索引进行优化，这是最有效的方法。</p>
<p>当无法使用索引的时候，GROUP BY 使用</p>
<p>Mysql 采用两种(临时表和文件排序)来做分组，这里可以通过hint:SQL_SMALL_RESULT,SQL_BIG_RESULT来让优化器按照你的方式运行<br> 在使用groupby按照表中某一列进行分组的时候，通常采用标识列(也就是外键表的标识列)来进行分组效率会比其他列分组效率高</p>
<p><img src="https://upload-images.jianshu.io/upload_images/6008583-427dfdfe55b60dfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600/format/webp" alt="img"></p>
<p>在分组查询的select语句中直接使用非分组列，通常都不是什么好主意<br> <code>select actor.first_name, actor.last_name, count(*) from film_actor inner join actor using (film_id) group by film_actor.actor_id</code><br> 可能替换成下面的语句更加满足关系理论，但是使用子查询需要创建和填充临时表，而子查询中创建的临时表时没有任何索引的<br> <code>select actor.first_name, actor.last_name, c.cnt from actor inner join ( select actor_id, count(*) as cnt from film_actor group by actor_id ) as c using(actor_id)</code><br> 如果没有显示的使用orderby子句指定排序列，当查询使用group by 的时候，默认会使用排序列进行排序，如果不关心排序，而这种排序又导致了文件排序，那么可以通过group by null来禁用排序，也可以使用DESC,ASC让查询结果按照需要的方向进行排序</p>
<h4 id="LIMIT-分页优化-（没理解）"><a href="#LIMIT-分页优化-（没理解）" class="headerlink" title="&#x3D;&#x3D;LIMIT 分页优化&#x3D;&#x3D;（没理解）"></a>&#x3D;&#x3D;LIMIT 分页优化&#x3D;&#x3D;（没理解）</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mccand1234/article/details/116265162">https://blog.csdn.net/mccand1234/article/details/116265162</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jpfss/p/8709111.html">https://www.cnblogs.com/jpfss/p/8709111.html</a></p>
<p><a target="_blank" rel="noopener" href="https://chatgpt.com/share/67568556-1588-800a-bed1-c09351bede62">https://chatgpt.com/share/67568556-1588-800a-bed1-c09351bede62</a></p>
<p>在进行 LIMIT 分页的时候，我们通常会使用 LIMIT 加上偏移量的办法实现，同时加上合适的 ORDER BY 子句，如果有对应的索引，效率通常会不错。</p>
<p>但是如果偏移量很大，比如，LIMIT 10000, 20 ，Mysql 会搜索 10020条记录并取最后20条记录，抛弃掉前面10000 条记录，优化可以采取在分页中限制分页的数量，或者优化大偏移量的性能。</p>
<p>优化此类分页查询的一个最简单的办法就是尽可能的使用<strong>索引覆盖扫描</strong>，而不是查询所有的列，然后根据需要再做一次关联查询再返回操作所需要的列。偏移量很大的情况下，性能提升大。</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> film.id, film.description </span><br><span class="line"><span class="keyword">from</span> film </span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> title </span><br><span class="line">limit <span class="number">50</span>, <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>如果上面的film表非常大，那么上面的查询最好是改写成下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> film.id, film.description </span><br><span class="line"><span class="keyword">from</span> film </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> ( <span class="keyword">select</span> film.id <span class="keyword">from</span> film </span><br><span class="line">            <span class="keyword">order</span> <span class="keyword">by</span> film.title 		</span><br><span class="line">            limit <span class="number">50</span>, <span class="number">5</span>) <span class="keyword">as</span> tmp  </span><br><span class="line"><span class="keyword">using</span>(film.id)</span><br></pre></td></tr></table></figure>

<p>这里其实使用的是<strong>延迟关联</strong>的技术，他让 mysql 扫描尽可能少的页面，获取需要访问的记录后再根据关联列回原表查询需要的列.</p>
<p>也可以使用<strong>范围查询</strong>，前提是已经知道需要查询的范围，比如上面的查询语句可以改写为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br></pre></td></tr></table></figure>



<p> <code>select film.id, film.description from film where id between 50 and 54;</code><br> 分页查询limit与offset,其实是offset的问题，他会让数据库扫描大量不需要的记录行然后再抛弃掉，可以使用书签方式记录上一次访问的数据位置，下次直接从书签位置进行访问，那么就可以避免使用offset，但使用这种方式的前提是表主键单调递增，没有删除<br> 使用下面的查询获取第一组数据<br> <code>select * from rental order by rental_id desc limit 20;</code><br> 假设上面返回的是16049到16030的记录，那么下一页就可以直接从16030访问<br> select * from rental where rental_id &lt; 16030 order by rental_id desc limit 20;</p>
<p>解决 OFFSET 的问题：</p>
<p>OFFSET 过大会导致扫描大量不需要的行然后抛弃掉，<strong>使用书签</strong>记录上次取数据的位置，下次就可以直接从书签位置开始扫描，避免使用 OFFSET。</p>
<p>例如，若需要按照租借记录做翻页，那么可以根据最新一条租借记录向后追溯，这种做法可行，因为租借记录的主键单调增长。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sakila.rental</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>假设上面查询返回的主键是16 049到16 030的租借记录，那么下一页查询就可以从16 030这个点开始</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sakila.rental</span><br><span class="line"><span class="keyword">WHERE</span> rental_id <span class="operator">&lt;</span> <span class="number">16030</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> LIMIT <span class="number">20</span>;</span><br></pre></td></tr></table></figure>











<h4 id="优化union查询"><a href="#优化union查询" class="headerlink" title="优化union查询"></a>优化union查询</h4><p>mysql总是通过创建并填充临时表的方式来执行union查询，除非确实需要服务器消除重复的行，否则就一定要使用union all，这一点很重要，如果没有加all，mysql会给临时表加上distinct选项，这导致整个临时表的数据需要做唯一性验证，即使加上了all,mysql仍然会用临时表存储结果，事实上，mysql总是将结果放入临时表然后在读出，在返回给客户端</p>

      
       
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 王才雨
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
